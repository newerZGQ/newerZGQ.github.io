<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Lock原理]]></title>
      <url>/2019/05/06/Lock%E5%8E%9F%E7%90%86/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Activity的四种启动方式]]></title>
      <url>/2019/05/06/Android-Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h4 id="Android四种启动方式"><a href="#Android四种启动方式" class="headerlink" title="Android四种启动方式"></a>Android四种启动方式</h4><p>Activity有四种启动方式：<br>以下是Android developer介绍的，但是实际情况会有所出入<br>| 使用场景         | Launch Mode    | 是否多实例 | 介绍                                                                                                                                                                                                                  |<br>| —————- | ————– | ———- | ——————————————————————————————————————————————————————————————————————— |<br>| 绝大多数使用场景 | standard       | 是         | 默认模式，系统总会在目标任务栈中创建一个新实例，并把intent传给它                                                                                                                                                      |<br>| 绝大多数使用场景 | singleTop      | 根据情况   | 如果一个实例存在且位于目标任务栈的顶端，那么系统会将intent通过onNewIntent传给该activity，而不会创建一个新实例                                                                                                         |<br>| 特殊场景使用     | singleTask     | 否         | 系统创建一个新的任务栈和一个新的activity实例，将activity实例放在栈底。但是，如果已经有一个这个Activity的实例，系统会回调这个实例的onNewIntent方法，而不会创建新实例（注意：此处介绍与实际情况有出入，后面会详细介绍） |<br>| 特殊场景使用     | singleInstance | 否         | 和singleTask几乎一样，不同的是，singleInstance存在的任务栈，不会有其他任何activity，该Activity是其所在任务栈内唯一的一个Activity                                                                                      |</p>
<a id="more"></a>
<h5 id="standard和singleTop"><a href="#standard和singleTop" class="headerlink" title="standard和singleTop"></a>standard和singleTop</h5><p>这两个模式看似简单，其实仔细思考还是有一些需要注意的点的。<br>我们从最简单的开始测试，现有如下两个Activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.MainActivity&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;</span><br><span class="line">    android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.Main2Activity&quot;</span><br><span class="line">    android:label=&quot;@string/title_activity_main2&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;</span><br><span class="line">    android:theme=&quot;@style/AppTheme.NoActionBar&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>测试流程MainActivity-&gt;Main2Activity-&gt;Main2Activity，打印当前任务栈，发现只有两个Activity：栈底MainActivity，栈顶Main2Activity，并且，在第二次启动Main2Activity时，没有创建新实例，而是回调了Main2Activity的onNewIntent方法。<br>对于standard和singleTop，如无特别操作，新建的实例都会压入默认任务栈，上面两次启动Activity都是在默认的任务栈中。那么对于这种类型的Activity，我们可以让他们启动在另一个任务中么？答案是肯定的。<br>我们在启动Main2Activity时，Intent可以设置Flag：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br></pre></td></tr></table></figure></p>
<p>根据官方文档，当设置了FLAG_ACTIVITY_NEW_TASK之后，会使用一个新的任务来承接要启动的Activity，但是实际情况是这样么？还是MainActivity-&gt;Main2Activity-&gt;Main2Activity的启动顺序，打印任务栈，发现还是只有一个任务栈，Main2Activity表现的和没有加Flag时一模一样。而出现这种情况的原因就是我们没有设置Main2Activity的taskAffinity。    </p>
<blockquote>
<p>taskAffinity: 每个Activity都有一个taskAffinity，表示这个Activity在启动时如果需要选择任务栈，那么选择的依据就是taskAffinity，为什么说如果需要选择呢？这是因为standard和singleTop模式下，即便设置了taskAffinity参数，Activity在启动后会直接进入到启动它的Activity所在的栈，而不会考虑根据taskAffinity去选择，除非在启动时给intent添加FLAG_ACTIVITY_NEW_TASK FLAG，这相当于给了Activity选择任务栈的权利，taskAffinity也会生效。而singleTask和singleInstance在整个系统中是单例，所以天生在启动时需要遍历所有任务栈，判断当前是否存在实例，如果有实例，则将已存在实例的上方Activity弹出，回调onNewIntent。</p>
</blockquote>
<p>将上面manifest修改如下，给Main2Activity添加taskAffinity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.MainActivity&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;</span><br><span class="line">    android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.Main2Activity&quot;</span><br><span class="line">    android:label=&quot;@string/title_activity_main2&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;</span><br><span class="line">    android:taskAffinity=&quot;com.test&quot;</span><br><span class="line">    android:theme=&quot;@style/AppTheme.NoActionBar&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>测试流程MainActivity-&gt;Main2Activity-&gt;Main2Activity，打印所有任务栈，这里给出打印任务栈代码，打印出每个任务栈的Activity数量、affiliatedTaskId、栈底Activity、栈顶Activity。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void printActivities(AppCompatActivity activity)&#123;</span><br><span class="line">    ActivityManager activityManager = (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    List&lt;ActivityManager.AppTask&gt; appTasks =  activityManager.getAppTasks();</span><br><span class="line">    for (int i = 0; i &lt; appTasks.size(); i++) &#123;</span><br><span class="line">        Util.print(&quot;numActivities: &quot; + appTasks.get(i).getTaskInfo().numActivities + &quot;\n&quot;);</span><br><span class="line">        Util.print(&quot;affiliatedTaskId: &quot; + appTasks.get(i).getTaskInfo().affiliatedTaskId + &quot;\n&quot;);</span><br><span class="line">        Util.print(&quot;baseActivity: &quot; + appTasks.get(i).getTaskInfo().baseActivity + &quot;\n&quot;);</span><br><span class="line">        Util.print(&quot;topActivity: &quot; + appTasks.get(i).getTaskInfo().topActivity + &quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Util.print(&quot;================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">04-29 00:39:30.563 8113-8113/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 00:39:30.567 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 287 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">04-29 00:39:33.104 8113-8113/study.zgq.com.androidstudy D/nanwei: total tasks: 2</span><br><span class="line">04-29 00:39:33.108 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 288 baseActivity: Main2Activity topActivity: Main2Activity</span><br><span class="line">04-29 00:39:33.110 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 287 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">04-29 00:39:34.099 8113-8113/study.zgq.com.androidstudy D/nanwei: +++++++++++++&gt;&gt;&gt;&gt;new intent</span><br><span class="line">04-29 00:39:35.653 8113-8113/study.zgq.com.androidstudy D/nanwei: total tasks: 2</span><br><span class="line">04-29 00:39:35.656 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 288 baseActivity: Main2Activity topActivity: Main2Activity</span><br><span class="line">04-29 00:39:35.661 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 287 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，第一次启动Main2Activity后有两个任务栈，Main2Activity于一个新的任务栈中，且处于前台。再次启动Main2Activity，发现两个任务栈状态均未改变，但是回调了Main2Activity的onNewIntent。<br>那么，我们在第二个栈中重新启动MainActivity呢？也就是MainActivity-&gt;Main2Activity-&gt;Main2Activity-&gt;MainActivity的启动顺序，这里是结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">04-29 00:57:33.090 8522-8522/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 00:57:33.093 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 290 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">04-29 00:57:35.830 8522-8522/study.zgq.com.androidstudy D/nanwei: total tasks: 2</span><br><span class="line">04-29 00:57:35.832 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 291 baseActivity: Main2Activity topActivity: Main2Activity</span><br><span class="line">04-29 00:57:35.835 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 290 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">04-29 00:57:38.594 8522-8522/study.zgq.com.androidstudy D/nanwei: total tasks: 2</span><br><span class="line">04-29 00:57:38.597 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 291 baseActivity: Main2Activity topActivity: MainActivity</span><br><span class="line">04-29 00:57:38.602 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 290 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看出来，在第二个任务栈中新创建了一个MainActivity。那么，我们可以将新创建的MainActivity压入第一个任务栈么？答案也是可以的：先修改manifest，给MainActivity指定taskAffinity：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.MainActivity&quot;</span><br><span class="line">    android:label=&quot;@string/app_name&quot;</span><br><span class="line">    android:taskAffinity=&quot;com.test.main&quot;</span><br><span class="line">    android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.Main2Activity&quot;</span><br><span class="line">    android:label=&quot;@string/title_activity_main2&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;</span><br><span class="line">    android:taskAffinity=&quot;com.test&quot;</span><br><span class="line">    android:theme=&quot;@style/AppTheme.NoActionBar&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>同时在从Main2Activity启动MainActivity时添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br></pre></td></tr></table></figure></p>
<p>还是按照MainActivity-&gt;Main2Activity-&gt;Main2Activity-&gt;MainActivity的启动顺序，看结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">04-29 01:08:54.490 8840-8840/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 01:08:54.493 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 292 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">04-29 01:08:57.141 8840-8840/study.zgq.com.androidstudy D/nanwei: total tasks: 2</span><br><span class="line">04-29 01:08:57.145 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 293 baseActivity: Main2Activity topActivity: Main2Activity</span><br><span class="line">04-29 01:08:57.148 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 292 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">04-29 01:09:00.084 8840-8840/study.zgq.com.androidstudy D/nanwei: total tasks: 2</span><br><span class="line">04-29 01:09:00.089 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 292 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">04-29 01:09:00.090 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 293 baseActivity: Main2Activity topActivity: Main2Activity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看出来，在初始task内重新创建了一个MainActivity。   </p>
<p>上面我们使用了一个Flag：FLAG_ACTIVITY_NEW_TASK，其实还有一个常见的Flag是FLAG_ACTIVITY_CLEAR_TOP，顾名思义，在启动Activity时，如果目标栈内已经有了实例，那么会弹出其上的所有Activity，然后回调onNewIntent方法(Activity launchMode为singleTop)或者销毁栈内的实例以及其上面的实例，重新创建新实例（Activity launchMode为standard）。举例如下：有MainActivity和Main2Activity，launchMode都是standard，启动顺序MainActivity-&gt;Main2Activity-&gt;MainActivity，其中MainActivity-&gt;Main2Activity是直接调用启动，Main2Activity-&gt;MainActivity时intent添加flag：FLAG_ACTIVITY_CLEAR_TOP。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">04-29 22:49:51.307 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onCreate</span><br><span class="line">04-29 22:49:51.687 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume</span><br><span class="line">04-29 22:49:54.863 19805-19805/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 22:49:54.866 19805-19805/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 308 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br><span class="line">04-29 22:49:56.152 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onPause</span><br><span class="line">04-29 22:49:56.680 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onStop</span><br><span class="line">04-29 22:49:57.132 19805-19805/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 22:49:57.135 19805-19805/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 308 baseActivity: MainActivity topActivity: Main2Activity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br><span class="line">04-29 22:49:58.135 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onCreate</span><br><span class="line">04-29 22:49:58.167 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume</span><br><span class="line">04-29 22:49:59.280 19805-19805/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 22:49:59.284 19805-19805/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 308 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出来，standard模式的activity被带有FLAG_ACTIVITY_CLEAR_TOP的intent重新启动时，重新经历一次完整的生命周期，也就是说会弹出自身以及其上的所有activity，并重新创建一个新的实例，这也迎合了standard模式在任何情况下都会重新创建一个新实例。<br>接着上面的例子，如果MainActivity launchMode是singleTop，那么结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">04-29 22:43:57.198 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onCreate</span><br><span class="line">04-29 22:43:57.597 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume</span><br><span class="line">04-29 22:44:00.439 19471-19471/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 22:44:00.444 19471-19471/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 307 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br><span class="line">04-29 22:44:01.589 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onPause</span><br><span class="line">04-29 22:44:02.151 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onStop</span><br><span class="line">04-29 22:44:02.692 19471-19471/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 22:44:02.694 19471-19471/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 307 baseActivity: MainActivity topActivity: Main2Activity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br><span class="line">04-29 22:44:03.967 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onNewIntent</span><br><span class="line">04-29 22:44:03.968 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume</span><br><span class="line">04-29 22:44:05.160 19471-19471/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 22:44:05.165 19471-19471/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 307 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br></pre></td></tr></table></figure></p>
<p>可见singleTop模式的activity在被带有FLAG_ACTIVITY_CLEAR_TOP的intent启动时，会弹出其上所有activity，并回调onNewIntent，而不会创建新实例。这也迎合了singleTop可以（注意，只是可以）维持一个实例的特性。需要注意的是，FLAG_ACTIVITY_CLEAR_TOP起作用的是离栈顶最近的Activity，什么意思呢？比如当前栈内从低向上为A-A-A-B，然后B通过FLAG_ACTIVITY_CLEAR_TOP启动A，那么结果是A-A-A。</p>
<h5 id="singleTask和singleInstance"><a href="#singleTask和singleInstance" class="headerlink" title="singleTask和singleInstance"></a>singleTask和singleInstance</h5><p>我们知道，假设有launchMode为singleTask的Activity1，如果任务栈中已经有了一个Activity1的实例，那么当重新要启动一个新的Activity1时，不会创建新的实例，而会将Activity1上的所有Activity全部弹出栈，然后回调onNewIntent。也就是说，同一个栈中，只能有一个Activity1的实例。那么，如果不同栈中呢？能同时各出现一个实例么？答案是否定的，为什么呢？因为如果要使同一个Activity的多个实例处于不同任务栈中，那么这个Activity势必要有多个不同的taskAffinity，而Android是不支持多个taskAffinity的，这也违反task的设计理念。所以singleTask的Activity在系统中唯一实例。<br>需要提醒的是，官方文档中对于singleTask的解释：”系统创建一个新的任务栈和一个新的activity实例，将activity实例放在栈底“，上面这句话其实是有待商榷的，因为他的实现是有限制的，如果我们仅仅将Activity的launchMode设置为singleTask，那么在启动时，并不会像上面所说，创建新的任务栈然后放入栈底，二是和standard模式一样，直接创建一个新的放入栈顶。如下例：MainActivity是standard模式，Main2Activity是singleTask模式，启动顺序MainActivity-&gt;Main2Activity。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">04-29 23:15:20.774 21777-21777/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 23:15:20.779 21777-21777/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 316 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br><span class="line">04-29 23:15:23.071 21777-21777/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 23:15:23.075 21777-21777/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 316 baseActivity: MainActivity topActivity: Main2Activity</span><br><span class="line">    ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br></pre></td></tr></table></figure></p>
<p>从结果可以看出，Main2Activity的表现和standard模式一致，那么怎么才能出现文档的情况呢？那就是设置Main2Activity的taskAffinity，可以说，taskAffinity是判断是否创建新任务栈的唯一考量标准。     </p>
<p>而singleInstance和singleTask的特性基本一致，区别在于，singleInstance是唯一一个存在于任务栈的activity，不可能有其他的activity，比如有MainActivity(standard)和Main2Activity(singleInstance)，MainActivity启动Main2Activity，结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">04-29 23:31:36.685 22677-22677/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 23:31:36.690 22677-22677/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 318 baseActivity: MainActivity topActivity: MainActivity</span><br><span class="line">04-29 23:31:36.691 22677-22677/study.zgq.com.androidstudy D/nanwei: ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br><span class="line">04-29 23:31:40.102 22677-22677/study.zgq.com.androidstudy D/nanwei: total tasks: 1</span><br><span class="line">04-29 23:31:40.104 22677-22677/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 319 baseActivity: Main2Activity topActivity: Main2Activity</span><br><span class="line">================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔</span><br></pre></td></tr></table></figure></p>
<p>可以看出，taskAffinityId发生了变化，也即是说，启动Main2Activity后，新建了一个新的任务栈，然后把Main2Activity放入栈底。</p>
<p>总结</p>
<ol>
<li>standard模式任何时候都会重新创建实例，包括被FLAG_ACTIVITY_CLEAR_TOP启动时</li>
<li>对于能维护一个单例的模式，在使用FLAG_ACTIVITY_CLEAR_TOP时，都会回调onNewIntent，singleTop具有（注意，只是具有，并不是肯定是只有一个实例）维持同一个实例的特性，singleTask和singleInstance都是单例</li>
<li>taskAffinity和singleInstance是考量是否创建新任务栈的唯二参考</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[java虚拟机结构]]></title>
      <url>/2019/05/05/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<ul>
<li>pc寄存器</li>
<li><p>虚拟机栈</p>
<ul>
<li>栈帧<ul>
<li>随着方法调用创建，随着方法结束</li>
<li>可以在堆中分配</li>
<li>局部变量表</li>
<li>操作数栈，真正的计算发生在这里</li>
<li>当前方法所属类的运行时常量池</li>
</ul>
</li>
</ul>
</li>
<li><p>堆</p>
</li>
<li>本地方法栈<ul>
<li>c stack</li>
</ul>
</li>
<li>方法区<ul>
<li>内存共享</li>
<li>堆的逻辑部分，可以不实现垃圾回收</li>
<li>运行时常量池<ul>
<li>加载类或接口到虚拟机后，就会创建运行时常量池</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[单例]]></title>
      <url>/2019/05/03/%E5%8D%95%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h4 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h4><p>单例模式可以使一个类只有一个对象，能减少频繁创建对象的时间和空间开销。<br>单例模式需要注意的点</p>
<ol>
<li>构造方法私有</li>
<li>如果是延迟加载，对象实例需要私有；</li>
<li>注意线程安全</li>
</ol>
<a id="more"></a>
<h5 id="单线程单例"><a href="#单线程单例" class="headerlink" title="单线程单例"></a>单线程单例</h5><p>单线程模式下一个典型的单例模式代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SingleInstance1 &#123;</span><br><span class="line">    private static SingleInstance1 instance;</span><br><span class="line">    private SingleInstance1() &#123;&#125;</span><br><span class="line">    public static SingleInstance1 getInstance()&#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new SingleInstance1();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单线程下是没问题的，但多线程下会出现创建出多个实例的情况。</p>
<h5 id="多线程单例"><a href="#多线程单例" class="headerlink" title="多线程单例"></a>多线程单例</h5><p>上面的代码无法保证线程安全，解决方法也很简单，加锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SingleInstance2 &#123;</span><br><span class="line">    private static SingleInstance2 instance;</span><br><span class="line">    private SingleInstance2()&#123;&#125;</span><br><span class="line">    public synchronized static SingleInstance2 getInstance()&#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new SingleInstance2();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加锁固然简单，但是也带来了性能的损耗，每次请求实例时都要请求锁，且如果两个线程同时请求获得对象实例时，要排队等待。<br>其实呢，为了保证线程安全，也就是保证不会出现多个实例，我们只要对<code>instance = new SingleInstance2()</code>加锁即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SingleInstance3 &#123;</span><br><span class="line">    private volatile static SingleInstance3 instance;</span><br><span class="line">    private SingleInstance3() &#123;&#125;</span><br><span class="line">    public static SingleInstance3 getInstance()&#123;</span><br><span class="line">        if (instance == null) &#123;                          //1</span><br><span class="line">            synchronized (SingleInstance3.class)&#123;        //2</span><br><span class="line">                instance = new SingleInstance3();        //3</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这样呢有重新暴露出了线程安全的问题，比如线程A在代码1处判断为空后，资源让给线程B，线程B在1处同样判断为空后，资源返回给A，A获得锁，创建实例返回，B获得资源然后获得锁，同样还是会重新创建实例。怎么解决呢？就是在获得锁之后，重新进行一次空判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SingleInstance3 &#123;</span><br><span class="line">    private volatile static SingleInstance3 instance;</span><br><span class="line">    private SingleInstance3() &#123;&#125;</span><br><span class="line">    public static SingleInstance3 getInstance()&#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (SingleInstance3.class)&#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new SingleInstance3(); //1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码看似完美，其实还是有隐藏问题，什么问题呢？<br>问题出在<code>instance = new SingleInstance3()</code>这行代码上，其实new一个新对象并不是一个原子操作，是分步的：    </p>
<ol>
<li>memory=allocate()分配对象的内存空间。</li>
<li>createInstance()初始化对象</li>
<li>instance=memory 设置instance指向刚分配的内存<br>大致来讲就是上面三步，但是由于java指令重排序优化的存在，会导致第二步和第三步没有绝对的先后顺序，在实例运行过程中，完全有可能出现1-&gt;3-&gt;2的顺序，那么表现在上面的代码中是什么情况呢：<br>线程A执行到代码1处，先分配对象内存空间，再将instance指向刚分配的空间，然后资源让给线程B，线程B检查instance时候为空，判断结果是非空，直接返回使用，这时返回的是还未完全初始化好的实例，使用的话肯定会出错。解决办法是使用volatile修饰instance，volatile的重要作用就是禁止指令重排序，保证不会出现1-&gt;3-&gt;2的执行顺序，同时volatile保证在写之前会同步最新的数据</li>
</ol>
<p>happens-before<br>volatile变量规则：这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[死锁知识点]]></title>
      <url>/2019/05/03/%E6%AD%BB%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>两个线程分别是线程1和线程2。线程1执行过程中，先获得对象a的锁，然后要再获得b的锁才能继续执行代码；而线程2正巧相反，先获得对象b的锁，然后要再获得a的锁才能继续执行代码。这时，两个线程都等着对方解锁，才能继续执行，这时，两个线程就进入等待状态，最终不会有线程执行。这就变成了死锁。</p>
<h4 id="简单的死锁代码"><a href="#简单的死锁代码" class="headerlink" title="简单的死锁代码"></a>简单的死锁代码</h4><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockTest implements Algorithm &#123;</span><br><span class="line">    public Object object1 = new Object();</span><br><span class="line">    public Object object2 = new Object();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execut() &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Utils.printString(&quot;=====&gt;&gt;thread 1 running&quot;);</span><br><span class="line">                Lock1.test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Utils.printString(&quot;=====&gt;&gt;thread 2 running&quot;);</span><br><span class="line">                Lock2.test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Lock1 &#123;</span><br><span class="line">        public static synchronized void test()&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Utils.printString(Thread.currentThread().getName() + &quot; get lock1&quot;);</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">                Utils.printString(Thread.currentThread().getName() + &quot; try to get lock2&quot;);</span><br><span class="line">                Lock2.test();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Lock2 &#123;</span><br><span class="line">        public static synchronized void test()&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Utils.printString(Thread.currentThread().getName() + &quot; get lock2&quot;);</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                Utils.printString(Thread.currentThread().getName() + &quot; try to get lock1&quot;);</span><br><span class="line">                Lock1.test();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=====&gt;&gt;thread 1 running</span><br><span class="line">=====&gt;&gt;thread 2 running</span><br><span class="line">Thread-0 get lock1</span><br><span class="line">Thread-1 get lock2</span><br><span class="line">Thread-0 try to get lock2</span><br><span class="line">Thread-1 try to get lock1</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[关于注解应该知道的]]></title>
      <url>/2019/05/03/%E5%85%B3%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/</url>
      <content type="html"><![CDATA[<h4 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h4><p>其实注解并不复杂，使用注解一定会有三个过程：定义注解，使用注解，读取注解。我们一步一步来看：</p>
<h5 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h5><p>定义没什么好说的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Six&#123;</span><br><span class="line">    String name() default &quot;nanwei&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用<code>@interface</code>定义注解</li>
<li><code>@Target</code>和<code>@Retention</code>是元注解，就是注解的注解。。。。。，一共四种<ol>
<li>Target表示注解的作用目标，看代码</li>
</ol>
</li>
</ol>
<a id="more"></a>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="line">public @interface Target &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns an array of the kinds of elements an annotation type</span><br><span class="line">     * can be applied to.</span><br><span class="line">     * @return an array of the kinds of elements an annotation type</span><br><span class="line">     * can be applied to</span><br><span class="line">     */</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  ElementType是一个枚举类，包括type，field，method等常见的注解目标</p>
<ol>
<li><p>Retention定义注解的保留策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.SOURCE)   //注解仅存在于源码中，在class字节码文件中不包含</span><br><span class="line">@Retention(RetentionPolicy.CLASS)     // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)  // 注解会在class字节码文件中存在，在运行时可以通过反射获取到，正常来说定义在运行时才能发挥大作用</span><br></pre></td></tr></table></figure>
</li>
<li><p>Document：说明该注解将被包含在javadoc中，生成java文档的时候会用到</p>
</li>
<li>Inherited：说明子类可以继承父类中的该注解，这里要注意的是，仅类的注解可以被集成，接口的不行，类内的变量和方法也不行<ol>
<li>定义值，关键字default表默认值，仅支持基本类型和String，不支持Object，因为注解参数是一种编译时常量，那时候还没有对象呢，这算是java的一个设计缺陷吧，不知道以后会不会改进</li>
</ol>
</li>
</ol>
<h5 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h5><p>使用注解就很简单了，Override什么的我们也经常用，上面我们自己定义的也一样用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Algorithm&#123;</span><br><span class="line">    @Six(name=&quot;666&quot;)</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到name这个类变量有一个Six注解，参数666，好了，我们新建一个Student类，打印它的名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student = new Student();</span><br><span class="line">Utils.printString(&quot;=======&gt;&gt;&gt;&gt;1: &quot; + student.name);</span><br></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=======&gt;&gt;&gt;&gt;1: null</span><br></pre></td></tr></table></figure></p>
<p>好像这个注解并没有起什么作用，这是因为，这个注解虽然被编译进了class文件，加载类之后也进入了运行时，但是因为我们没有做解析这个注解的操作，所以没有生效，那么怎么解析呢？使用反射，这就是解析注解这一步</p>
<h5 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class SixProcessor &#123;</span><br><span class="line">    public static Student process(Student student) &#123;</span><br><span class="line">        Field[] fields = student.getClass().getFields();</span><br><span class="line">        for (int i = 0; i &lt; fields.length; i++) &#123;</span><br><span class="line">            Six six = fields[i].getAnnotation(Six.class);</span><br><span class="line">            if (six != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    student.getClass().getMethod(&quot;setName&quot;, String.class).invoke(student, six.name());</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，上面对Student对象的所有类变量遍历，检查是否有Six注解，如果有，则把注解的参数值赋给Student的name：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SixProcessor.process(student);</span><br><span class="line">Utils.printString(&quot;=======&gt;&gt;&gt;&gt;2: &quot; + student.name);</span><br></pre></td></tr></table></figure></p>
<p>结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=======&gt;&gt;&gt;&gt;2: 666</span><br></pre></td></tr></table></figure></p>
<h4 id="注解有什么作用呢"><a href="#注解有什么作用呢" class="headerlink" title="注解有什么作用呢"></a>注解有什么作用呢</h4><p>基于上述注解的特性，注解的主要作用有：</p>
<ol>
<li>编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】             </li>
<li>代码分析：通过代码里标识的元数据对代码进行分析【使用反射】            </li>
<li>编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[new的时候发生了什么]]></title>
      <url>/2019/04/09/new%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>ClassLoader是负责加载类的对象。ClassLoader类是一个抽象类，给定一个类的二进制名（任何一个类都有一个根据JLS规范定义的String类型的二进制名，ClassLoader中使用该名进行加载，其实在jni开发中，用的也是这个，详见jni tips），典型的策略是将二进制名转换成文件名然后从文件系统读取class文件。<br>每个class都包含一个classloader的引用，数组类型的class不是有classloader创建的，而是在运行时由java runtime自动创建，数组类型获取classloader时，返回的是数组元素的类型。如果数组元素是基本类型或者是由bootstrap classloader加载的类（比如rt.jar包），那么没有classloader。<br>如下代码：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Utils.printString(&quot;string class: &quot; + String.class);</span><br><span class="line">Utils.printString(&quot;string class classloader: &quot; + String.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">int[] intArr = &#123;0,4,1&#125;;</span><br><span class="line">Utils.printString(&quot;int array class: &quot; + intArr.getClass());</span><br><span class="line">Utils.printString(&quot;int array classloader: &quot; + intArr.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">String[] stringArr = &#123;&quot;545&quot;&#125;;</span><br><span class="line">Utils.printString(&quot;string array class loader: &quot; + stringArr.getClass());</span><br><span class="line">Utils.printString(&quot;string array class loader: &quot; + stringArr.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">ClassLoaderTest[] tests = &#123;new ClassLoaderTest()&#125;;</span><br><span class="line">Utils.printString(&quot;refre array class: &quot; + tests.getClass());</span><br><span class="line">Utils.printString(&quot;refre array class loader: &quot; + tests.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string class: class java.lang.String</span><br><span class="line">string class classloader: null</span><br><span class="line">int array class: class [I</span><br><span class="line">int array classloader: null</span><br><span class="line">string array classloader: class [Ljava.lang.String;</span><br><span class="line">string array classloader: null</span><br><span class="line">refre array class: class [Lcom.zgq.java.ClassLoaderTest;</span><br><span class="line">refre array classloader: sun.misc.Launcher$AppClassLoader@4b67cf4d</span><br></pre></td></tr></table></figure></p>
<p>由上面得到结论</p>
<ol>
<li>数组类型的ClassLoader是其元素的ClassLoader，如果元素ClassLoader为空，那么数组ClassLoader也为空</li>
<li>由于String在rt.jar包中，是有bootstrap加载的，所以getClassLoader返回空</li>
<li>int数组的class类型是[I，java语言规范中，[表示数组类型，I表示int</li>
</ol>
<p>程序中继承classloader来实现自己的classloader，这样可以延用jvm的动态加载机制。<br>类加载器常用于安全管理机制，保证安全域。<br>ClassLoader使用代理模式来寻找类或者资源，每个ClassLoader都有一个父ClassLoader，当要请求查找一个新的类或者资源时，ClassLoader的实例自身在搜索前，会让父ClassLoader先去查找。jvm内建的ClassLoader叫bootstrap classloader，这个加载器没有父加载器，但是可以作为其他类加载器的父引用。<br>支持同步加载的类加载器叫parallel capable class loader，这样的类加载器在初始化的时候需要注册方法<code>ClassLoader.registerAsParallelCapable</code>，注意ClassLoader默认注册了改方法，但是，他的子类如果想支持同步还要重新注册。<br>某些条件下，代理模型并不是严格分级的，ClassLoader需要支持并发，否则加载类的过程可能引起死锁。详见loadClass方法。<br>一般情况下，jvm从本地文件系统加载类，比如在UNIX系统下，会直接从CLASSPATH环境变量指定的路径中加载。但是，有时候类文件是从其他方法比如网络上下载下来，这时我们可以使用defineClass方法将byte数组转换成类文件。新定义的类可以通过<code>Class.newInstance</code>创建实例。<br>自定义类加载器，需要注意两个方法，一个是defineClass，是一个final方法，由ClassLoader定义，这个方法把我们读入的字节数组转换成Class对象。另一个是要覆写findClass方法，这个方法会在委托失败后被调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line">    String host;</span><br><span class="line">    int port;</span><br><span class="line">    public Class findClass(String name) &#123;</span><br><span class="line">        byte[] b = loadClassData(name);</span><br><span class="line">        return defineClass(name, b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    private byte[] loadClassData(String name) &#123;</span><br><span class="line">        // load the class data from the connection</span><br><span class="line">         . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类加载器的加载流程为：因为没有指定父加载器，所以会先由bootstrap class loader加载，<code>bootstrap class loader</code>加载失败后再由<code>NetworkClassLoader</code>定义的<code>findClass</code>加载类</p>
<h4 id="数组的类"><a href="#数组的类" class="headerlink" title="数组的类"></a>数组的类</h4><p>数组类型的ClassLoader有可能是bootstrapclassloader，也可能是用户自定义ClassLoader。如果元素类型为C的数组已经被初始化过，也就是说已经有classLoader加载过元素类型为C的数组，那么，这时候已经有了该元素类型的数组类型，等再次创建该元素类型的数组时，不需要创建新的数组类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这时JVM已经有了一个class为[Ljava.lang.string的数组类型</span><br><span class="line">String[] stringArr = &#123;&quot;545&quot;&#125;;</span><br><span class="line">//这时JVM不会再创建一个[Ljava.lang.string的类型</span><br><span class="line">String[] stringAr1 = &#123;&quot;444&quot;&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果数组元素是引用类型，那么也会按照一般规则向上递归，加载所有父类。</li>
<li>JVM根据数组元素类型和数组的维度(注意是维度，不是长度，一维数组是[,二维数组是[[)创建数组类型<ol>
<li>如果数组元素是引用类型，那么结果数组类型的ClassLoader和元素的ClassLoader一致，否则就是bootstrap ClassLoader</li>
<li>任何情况下，JVM都将(1)里的ClassLoader作为数组类型的初识ClassLoader</li>
<li>如果数组元素是引用类型，那么数组类型的访问权限由元素的访问权限决定，否则就是public</li>
</ol>
</li>
</ol>
<h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p>类从被加载到JVM中开始，到卸载为止，整个生命周期包括加载、连接、初始化、使用、卸载，其中连接又分为三步：验证、准备、解析。<br><img src="/2019/04/09/new的时候发生了什么/类生命周期.png" alt="" title="类生命周期">    </p>
<p><img src="/2019/04/09/new的时候发生了什么/类加载过程.png" alt="" title="类加载过程">    </p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html" target="_blank" rel="noopener">官方文档在这里</a>，java虚拟机规范第五章详细讲了类加载过程的几个阶段，章首有一段非常概括的话：java虚拟机动态的加载、链接和初始化类和接口。加载是虚拟机根据特定的名称查找类或者接口的二进制表示，然后从这个二进制表示创建类或接口的过程。链接是为了让类或者接口能被虚拟机执行，而将类或接口并入虚拟机运行时的过程。类或接口的初始化过程就是执行类或接口的初始化方法<clinit>。<br>文档从5个方面阐述了类和接口的加载过程：</clinit></p>
<ol>
<li>运行时常量池，虚拟机从类或接口的二进制表示中获取字符引用，其实就是使用class文件中的常量池表构建运行时常量池。</li>
<li>虚拟机启动时是怎样的加载、链接、初始化过程</li>
<li>类或者接口的二进制表现是如何被类加载器加载并创建类和接口</li>
<li>详细解释链接过程</li>
<li>类和接口的初始化过程</li>
<li>绑定本地方法的概念</li>
</ol>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>虚拟机的内存结构中，有块逻辑区域叫方法区，方法区是可供各个线程共享的运行时内存区域。方法区与传统语言中编译代码存储区非常相似，存储了每个类的结构信息，例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，还有一些特殊函数，比如类、实例、接口的初始化函数。方法区是堆的逻辑组成部分，但是简单的虚拟机可以不实现垃圾回收与压缩，方法区大小可以固定也可以动态扩展，但如果方法区内存不足，会报OutOfMemoryError。<br>在创建类或接口时，虚拟机会根据类或接口的二进制表示中的常量池表来构造运行时常量池,运行时常量池初始时都是符号引用，这些符号是按照以下方法在类或接口的二进制表示中得出的，以类或接口的名称为例：    </p>
<ol>
<li>类或接口的符号引用来自常量池表中的CONSTANT_Class_info，这种引用提供类或接口的名称<ol>
<li>对于非数组的类或接口，这个名称就是类或接口的二进制名称</li>
<li>对于n维数组，会以n个[开头，后面跟数组元素类型</li>
<li>如果数组元素类型是基本类型，有对应的字段描述符，比如int以I表示</li>
<li>如果数组元素类型是引用类型，则以L加上元素的二进制名称，并以;结束</li>
</ol>
</li>
<li>类或接口中的字段的符号引用来自类或接口的二进制表示中的CONSTANT_Filedref_info结构，这种引用包括了字段名称和描述符，以及指向字段所属类或接口的符号引用<br>此外还有方法、方法句柄、方法类型以及调用点限定符的符号引用，这里不在赘述<br>…..<br>需要注意的是字符串常量，字符串常量是指向String类实例的引用，它来自类或接口的二进制表示中的CONSTANT_String_info结构。CONSTANT_String_info给出了由Unicode码点序列组成的字符串常量。java规定，相同的字符串常量，也就是包含同一份Unicode码点序列的常量，必须指向同一个String实例。此外，如果在任意字符串上调用String.intern方法，那么其返回的String实例，必须和直接以常量形式出现的字符串实例完全相同，即下式永远为true：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里要注意的是字符串的创建方式对引用值的影响，举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这样创建的字符串，会先检查方法区中字符串常量池中是否有值相等的实例，如果有，直接返回那个实例的引用给a，否则创建一个值为test的实例，再将引用返回给a</span><br><span class="line">String a = &quot;test&quot;;</span><br><span class="line">String b = &quot;test&quot;;</span><br><span class="line">Utils.printString(&quot;a == b is&quot; + (a == b));</span><br><span class="line">//这样创建的字符串，会先在堆上创建一个String实例，引用地址返回给c，然后JVM会去方法区中的字符串常量池查看是否有&quot;test&quot;字符串的对象，没有的话就分配一个空间来存放&quot;test&quot;，并将其空间地址存入堆中new出来的对象中；直接将那个实例存入堆中new出来的对象中</span><br><span class="line">String c = new String(&quot;test&quot;);</span><br><span class="line">String d = new String(&quot;test&quot;);</span><br><span class="line">Utils.printString(&quot;c == d is&quot; + (c == d));</span><br><span class="line">Utils.printString(&quot;a == c is&quot; + (a == c));</span><br></pre></td></tr></table></figure></p>
<p>所以上面代码结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a == b is true</span><br><span class="line">c == d is false</span><br><span class="line">a == c is false</span><br></pre></td></tr></table></figure></p>
<p>而上面intern方法的作用就是，如果字符串常量池中存在值相等的字符串实例，则返回，否则在字符串常量池中创建一个实例并返回。</p>
<h5 id="虚拟机启动"><a href="#虚拟机启动" class="headerlink" title="虚拟机启动"></a>虚拟机启动</h5><p>引导类加载器（boostrap class loader）创建一个初始类，然后虚拟机链接该初始类，初始化它并调用他的void main(String[] args)方法</p>
<h5 id="创建和加载"><a href="#创建和加载" class="headerlink" title="创建和加载"></a>创建和加载</h5><p>如果要创建标记为N的类或接口C，需要在java虚拟机的方法区上为C创建与虚拟机实现相匹配的内部表示。C的创建是由另一个类D触发的，它通过自己的运行时常量池引用了C，比如D中包含C的引用。当然，反射或者一些特殊方法也可能触发。<br>类加载器L可能直接定义或委托其他类加载器的方式来创建C，如果L直接定义了C，那么说L是C的定义加载器。而类加载器在加载时，有可能将加载请求委托给别的类加载器完成，那么这时候可以说是L导致了C的加载，或者说L是C的初始加载器。<br>虚拟机运行时，类或者接口不仅仅由它的名称来确定，而是由名称和类加载器共同确定<br>D触发创建C，如果D是由引导类加载器加载，那么C也由引导类加载器加载，如果D由用户自定义类加载器加载，那C也由用户自定义类加载器加载。也就是说两者一致。    </p>
<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>链接类或接口包括验证和准备类或接口，它的直接父类，它的直接父接口，它的元素类型（如果是一个数组）。解析这个类或者接口的符号引用是可选的。<br>java虚拟机允许灵活的选择链接时机，但必须抱枕</p>
<ol>
<li>链接前成功加载过</li>
<li>初始化前成功验证和准备过</li>
<li>当程序执行某个可能直接或间接链接一个类或接口的工作时，而在链接过程中出错，那错误的抛出点应该在执行动作的点<br>虚拟机没有强制规定解析符号引用的时机，可以在使用到类或接口的符号引用时才去逐一解析（延迟解析），也可以在验证类的时候就解析每个引用（预先解析）。    <h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6>确保类或者接口的二进制表示在结构上是正确的。验证静态约束和结构化约束，见4.9节。<br>如果虚拟机尝试验证类或接口，但因为抛出LinkageError或LinkageError子类的实例而导致失败，则之后对此类的验证总会因为相同原因失败。    <h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h6>准备阶段的任务是创建类或者接口的静态字段，并用默认值初始化这些字段。这个阶段不会执行任何的虚拟机字节码指令。<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><blockquote>
<p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<br>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那么引用的目标一定是已经存在于内存中      </p>
</blockquote>
</li>
</ol>
<p>解析是根据运行时常量池里的符号引用来动态决定具体值的过程。或者说解析就是把符号引用转换成直接引用的过程：    </p>
<ol>
<li>运行时常量池里字段的符号引用作为字段的”唯一标识符“（class+NameAndType），确定其是什么引用类型，从而由jvm定位到该类的结构体的内存地址</li>
<li>运行时常量池里字段的符号引用作为方法的”唯一标识符“（class+NameAndType），确定改方法是哪个类的，再根据NameAndType从方法表中找到对应的方法<br>同理还有类和接口解析，普通方法解析<br>……<br>其至于这个过程发生了什么，参照知乎收藏。这里先不展开描述。<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5>初始化对类和接口来说，就是执行它的初始化方法<clinit>。到了这个阶段才真正开始执行类中定义的Java程序代码（或者说是字节码）。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。</clinit></li>
</ol>
<p>tip</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[null是什么]]></title>
      <url>/2019/04/09/null%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<h5 id="null是什么"><a href="#null是什么" class="headerlink" title="null是什么"></a>null是什么</h5><p>我们会围绕这几个问题进行探讨</p>
<ol>
<li>null属于什么类型</li>
<li>null是某个具体的实例么</li>
<li>null是什么</li>
<li>null在内存中怎么表示<br>我们从null属于什么类型说起</li>
</ol>
<a id="more"></a>
<p>在Java Language Specification <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-ReferenceType" target="_blank" rel="noopener">chapter4–Types, Values, and Variables</a>中有介绍.<br>java中数据有两种类型，基本类型和引用类型，基本类型又分NumericType和boolean，NumericType就包括我们常说的整型（int，long，short，byte，char）以及浮点型（float，double）。那么除了这两种类型之外，JLS里着重说了null这种特殊的类型。</p>
<blockquote>
<p>There is also a special null type, the type of the expression null (§3.10.7, §15.8.1), which has no name.<br>Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type.<br>The null reference is the only possible value of an expression of null type.<br>The null reference can always be assigned or cast to any reference type (§5.2, §5.3, §5.5).<br>In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type.</p>
</blockquote>
<p>这里说null是一种特殊的类型，这个类型表示它的字面意思null，并且没有名称。因为null类型没有名称，所以我们不能声明一个null类型的对象，也不能把别的类型转换成null类型。<br>null类型唯一可能的值就是null引用，虽然有点拗口，理解成，null表示的就是他的字面意思就好了。<br>null引用可以赋给任何引用类型，也可以转换成任意引用类型。<br>程序员就把null看成字面意思就好了。<br>所以null究竟是什么类型JLS已经说清楚了，针对上面的介绍我写了一个类验证了下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class NullTest implements Algorithm &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execut() &#123;</span><br><span class="line">        ((Anything)null).printStatic();</span><br><span class="line">        Utils.printString(&quot;&quot; + ((Anything)null));</span><br><span class="line">        ((Anything)null).print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Anything &#123;</span><br><span class="line">        public static void printStatic()&#123;</span><br><span class="line">            Utils.printString(&quot;in static&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void print()&#123;</span><br><span class="line">            Utils.printString(&quot;in not static&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面程序的运行结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">in static</span><br><span class="line">null</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">	at com.zgq.java.NullTest.execut(NullTest.java:14)</span><br><span class="line">	at com.zgq.Main.main(Main.java:15)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)</span><br></pre></td></tr></table></figure></p>
<p>可见静态方法是可以输出的，因为是类的方法，而null转对象结果还是null。用null去调实例方法自然要报空指针。<br>说到这第二个问题就很明显了，null显然不是某个具体的示例。<br>那么，null是什么呢？这个问题很难直接回答，或者说很难按照正常的逻辑去回答，我们在学java的时候，会有一种感觉，一切都是对象，一切且有源头，任何对象任何类我都能从源码去一窥一二，可是null不行，我们无法直接拿出证据去精确的描述它，但是我们可以更实际一些的从他的作用来分析null是什么：       </p>
<ol>
<li>java中，null == null是永远返回true的      </li>
<li>对于非空引用t，<code>t.equals(null)</code>返回false    </li>
<li>null是一切引用类型的初始值    </li>
<li>null用来表示不存在的对象    </li>
<li>null表示未知的值    </li>
<li>null表示某种情况的终点      </li>
<li>HashMap中的key和value都可以是null，但这就带来一个问题：假设一个map，key和value都是Integer，map中包含一个键值对4-null，那么map.get(4)返回值是null，如果map中没有键值4，那么返回值还是null，这就产生语义冲突。当然java的HashTable是不存在这个问题的，这里不细说。      </li>
</ol>
<p>null在内存里是什么样的？<br>我们从其他方面侧面看下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = null;</span><br></pre></td></tr></table></figure></p>
<p>上面这行代码做的唯一一件事就是给s分配一个引用的内存空间，可能是32位，也可能64位，和硬件及java版本有关，这里不会给null分配任何的内存空间，因为null不是一个具体的对象。它像一个占位符一样表示这个引用还没有指向具体的对象。可能这个占位符就是个0，谁知道呢？</p>
<p><del>以下为个人想法，首先null这种特殊的引用类型在内存中肯定是存在的（废话），但是怎么存在的呢？我们看下equals方法</del><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <del>我们知道t.equals(null)返回false，可见对null的equals判断是在运算符中做的，线索断了，暂时未找到切入点。</del></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[对于枚举enum该知道的]]></title>
      <url>/2019/04/08/%E5%AF%B9%E4%BA%8E%E6%9E%9A%E4%B8%BEenum%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/</url>
      <content type="html"><![CDATA[<h4 id="枚举的由来"><a href="#枚举的由来" class="headerlink" title="枚举的由来"></a>枚举的由来</h4><p>首先是枚举类型的由来，在编程语言还没有引入枚举类型之前，程序员用来表示枚举类型的模式一般是声明一组具名的int常量，比如表示水果Fruit：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final int APPLE_FUJI = 0;</span><br><span class="line">public static final int APPLE_PIPPIN = 1;</span><br><span class="line">public static final int ORANGE_NAVEL = 2;</span><br><span class="line">public static final int ORANGE_TEMPLE = 3;</span><br></pre></td></tr></table></figure></p>
<p>这叫int枚举模式，这种模式有很多缺陷，在类型安全性和使用方便性上没有任何帮助。因为都是int类型，所以需要apple类型的时候传入orange编译器也不会报错。甚至apple和orange之间还能使用<code>==</code>进行比较而不会出现编译错误，这样带来的后果是灾难性的，隐藏的bug很难找出来。另外这种模式对于debug也很不方便（都是数字，没有太大用处）。也有一种模式使用String代替int，叫String枚举模式，但是导致性能问题，因为很依赖字符串操作；而且字符串书写错误也会造成很多问题，因为编译时并不会报错。</p>
<a id="more"></a>
<p>所以java1.5开始，提出了enum类型，也就是今天的主角。使用枚举写上面的代码是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Apple &#123;</span><br><span class="line">    FUJI,PIPPIN</span><br><span class="line">&#125;</span><br><span class="line">public enum Orange &#123;</span><br><span class="line">    NAVEL,TEMPLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看着简单，其实内部还是挺复杂的，而且功能也非常强悍。</p>
<h4 id="枚举的核心"><a href="#枚举的核心" class="headerlink" title="枚举的核心"></a>枚举的核心</h4><p>首先要明确的是枚举的本质还是int值。但是这个int值没有完全的暴露给开发者（当然可以通过ordinal获得，其实就是序数），事实上大部分情况我们都不需要这个int值。<br>枚举类型背后的基本想法很简单，枚举就是通过公有静态final域为每个枚举常量导出实例的类。<br>枚举没有可以访问的构造器，所以是真正的final。我们不能继承枚举，不能new枚举实例，甚至可能没有实例（如果没有生命枚举常量）。也就是说枚举是实例受控的。<br>想要了解一个枚举背后的东西，我们反编译下，看看class文件就明白了，我们反编译下Apple枚举：<br><img src="/2019/04/08/对于枚举enum该知道的/enum_apple_class.jpg" alt="" title="Apple枚举反编译-1"><br>可以看到，编译后的Apple其实就是一个继承了Enum的普通类，只是多了一个ACC_ENUM标志位。<br><img src="/2019/04/08/对于枚举enum该知道的/enum_apple_field.jpg" alt="" title="Apple枚举反编译-2"><br>在看class的内容，成员变量里有两个static final变量，分别是FUJI和PIPPIN，这就是我们声明的那两个枚举变量。这两个变量都有final、static、enum标志位。<br>当然这里的例子只是讲了最简单的枚举，枚举的巧妙用法在后面说，同时也会通过反编译获得更多的信息。</p>
<h4 id="枚举的用法-方法和域"><a href="#枚举的用法-方法和域" class="headerlink" title="枚举的用法-方法和域"></a>枚举的用法-方法和域</h4><p>枚举允许添加任意的方法和域，这使得我们可以将数据与枚举变量关联起来，这个特性会极大的增强枚举的能力。比如下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public enum Person &#123;</span><br><span class="line">    MAN(20),WOMEN(15);</span><br><span class="line">    private final int height;</span><br><span class="line">    private Person(int height)&#123;</span><br><span class="line">        this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getHeight()&#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getWeight()&#123;</span><br><span class="line">        switch (this)&#123;</span><br><span class="line">            case MAN:</span><br><span class="line">                return height * 10;</span><br><span class="line">            case WOMEN:</span><br><span class="line">                return height * 5;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个可以返回男女身高体重，还能根据类型区分计算的Person类，是不是很方便,我们反编译下看看：<br><img src="/2019/04/08/对于枚举enum该知道的/enum_person_field.jpg" alt="" title="Person枚举反编译-1"><br>常量池多了一个int类型的非静态height变量，说明这是变量是要由对象维护的，哪个对象呢？自然是Person的两个实例MAN和WOMAN。<br><img src="/2019/04/08/对于枚举enum该知道的/enum_person_method.jpg" alt="" title="Person枚举反编译-2"><br>这里多了两个非静态的getHeight和getWeight方法。所以说，在编译器编译过后，枚举就是一个普通类。</p>
<h4 id="枚举的用法-枚举变量和行为"><a href="#枚举的用法-枚举变量和行为" class="headerlink" title="枚举的用法-枚举变量和行为"></a>枚举的用法-枚举变量和行为</h4><p>上面介绍的方法几乎能满足所有情况了，但是还是有写情况不满足。比如下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public enum Fruit &#123;</span><br><span class="line">    APPLE(5, 30),</span><br><span class="line">    ORANGE(2, 40);</span><br><span class="line">    private final int size;</span><br><span class="line">    private final int num;</span><br><span class="line">    Fruit(int size, int num)&#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getNum()&#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getTotalWeight()&#123;</span><br><span class="line">        switch (this)&#123;</span><br><span class="line">            case APPLE:</span><br><span class="line">                return size * num + 1;</span><br><span class="line">            case ORANGE:</span><br><span class="line">                return size * num + 2;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return size * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算每种水果的重量的时候会根据不同水果区别计算，那么，假设，有一天新加了BANANA这个水果，但却忘了给switch增加相应的条件，那么返回结果必然是错的。这个时候就可以考虑使用抽象方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public enum Fruit &#123;</span><br><span class="line">    APPLE(5, 30)&#123;</span><br><span class="line">        @Override</span><br><span class="line">        int getCustomWeight(int size, int num) &#123;</span><br><span class="line">            return size * num + 5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ORANGE(2, 40)&#123;</span><br><span class="line">        @Override</span><br><span class="line">        int getCustomWeight(int size, int num) &#123;</span><br><span class="line">            return size * num + 6;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private final int size;</span><br><span class="line">    private final int num;</span><br><span class="line"></span><br><span class="line">    Fruit(int size, int num)&#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract int getCustomWeight(int size, int num);</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getNum()&#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样在声明新的枚举常量时必须实现这个抽象方法，也就不会忘了。一看到这个抽象方法，直觉告诉我们，既然编译后都是普通类，有需要实现抽象方法，那肯定会有新的类产生了，反编译看下<br><img src="/2019/04/08/对于枚举enum该知道的/enum_fruit_inner.jpg" alt="" title="Fruit枚举反编译-1"><br>果然，编译后生成了三个内部类，其中前两个分别实现了抽象方法，因为javap不能直接反编译内部类，所以这里无法判断这两个内部类的继承关系，不过应该是继承了外部类，因为下图猜测的：<br><img src="/2019/04/08/对于枚举enum该知道的/enum_fruit_object.jpg" alt="" title="Fruit枚举反编译-2"><br>Fruit拥有的两个实例类型都还是Fruit，所以是Fruit$1和Fruit$2分别继承了Fruit并实现了抽象方法，也就是说具体起作用的是这两个实现类。另外由于Fruit是抽象类，所以还需要一个Fruit$3还继承实现它。</p>
<h4 id="枚举策略"><a href="#枚举策略" class="headerlink" title="枚举策略"></a>枚举策略</h4><p>通过上面的分析介绍，我们知道，当希望将枚举常量与数据以及行为联系起来时，可以通过switch语句，缺点是不够安全，可能忘了相应的case，也可以通过抽象方法，但是这可能会导致大量样板代码的出现，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public enum Fruit &#123;</span><br><span class="line">    APPLE(5, 30)&#123;</span><br><span class="line">        @Override</span><br><span class="line">        int getCustomWeight(int size, int num) &#123;</span><br><span class="line">            return size * num + 5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    APPLE_1(5, 30)&#123;</span><br><span class="line">        @Override</span><br><span class="line">        int getCustomWeight(int size, int num) &#123;</span><br><span class="line">            return size * num + 5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ORANGE(2, 40)&#123;</span><br><span class="line">        @Override</span><br><span class="line">        int getCustomWeight(int size, int num) &#123;</span><br><span class="line">            return size * num + 6;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private final int size;</span><br><span class="line">    private final int num;</span><br><span class="line"></span><br><span class="line">    Fruit(int size, int num)&#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract int getCustomWeight(int size, int num);</span><br><span class="line"></span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNum()&#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getTotalWeight()&#123;</span><br><span class="line">        switch (this)&#123;</span><br><span class="line">            case APPLE:</span><br><span class="line">                return size * num + 1;</span><br><span class="line">            case ORANGE:</span><br><span class="line">                return size * num + 2;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return size * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里Apple和Apple_1的重量计算方式一模一样，但又不得不都实现一遍，这就是缺陷，那么这时候枚举策略的代码方式就有用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public enum  Flower &#123;</span><br><span class="line">    Rose_Red(Pricetype.Rose),Rose_Yellow(Pricetype.Rose),Tulip(Pricetype.Tulip);</span><br><span class="line"></span><br><span class="line">    private Pricetype pricetype;</span><br><span class="line">    private Flower(Pricetype pricetype)&#123;</span><br><span class="line">        this.pricetype = pricetype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getTotalMoney(int num) &#123;</span><br><span class="line">        return pricetype.price(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private enum Pricetype &#123;</span><br><span class="line">        Rose&#123;</span><br><span class="line">            @Override</span><br><span class="line">            int price(int num) &#123;</span><br><span class="line">                return num * 5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, Tulip &#123;</span><br><span class="line">            @Override</span><br><span class="line">            int price(int num) &#123;</span><br><span class="line">                return num * 6;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        abstract int price(int num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="几个方法"><a href="#几个方法" class="headerlink" title="几个方法"></a>几个方法</h4><p><code>valueOf</code>:valueOf让我们根据枚举常量的String名得到枚举常量，Enum类里有实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) &#123;</span><br><span class="line">    //Class类里专门为枚举类维护了一个map，存储String与Enum的键值对</span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">    if (result != null)</span><br><span class="line">        return result;</span><br><span class="line">    if (name == null)</span><br><span class="line">        throw new NullPointerException(&quot;Name is null&quot;);</span><br><span class="line">    throw new IllegalArgumentException(</span><br><span class="line">        &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>values</code>:遍历所有枚举，顺序是序数，该方法在编译时生成</p>
<p>end</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[volatile]]></title>
      <url>/2019/04/07/volatile/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[生产者消费者模式]]></title>
      <url>/2019/04/07/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者问题能够让我们对并发编程的理解加深。生产者消费者模式，主要探讨的问题是，两个线程（生产者与消费者），一块共享区域，生产者负责生产同时操作共享区域，消费者负责消费同时操作共享区域，在这个过程中，生产者与消费者没有任何耦合，互相不关心对方的行为，那么这种情况下，考虑如下场景：<br>假如共享区域有商品5个，消费者消耗一个商品后去检查数量时，消费者期待的是还剩下4个，但是由于没有做线程并发协作，在消耗完商品后的时间点，生产者刚好生产好一个商品并要将商品数量+1，在+1之后，消费者才去检查数量，这时候的数量还是5与他的期望不符，这就是问题所在，我们讨论的也都是要解决这个问题。<br>当然，除了上述假设情况之外，我们还得考虑，共享区域的数据变化如何阻塞及唤醒线程    </p>
<ol>
<li>如果共享数据区已满的话，阻塞生产者继续生产数据放置入内    </li>
<li>如果共享数据区为空的话，阻塞消费者继续消费数据<br>其实说到底，就是要实现线程同步，java中实现线程同步的方法主要有</li>
<li><code>Sychronized</code>，对应的要使用Object的wait和notify机制</li>
<li><code>Lock</code>，对应的要使用Lock的Condition的await/signal机制<br>另外，使用BlockingQueue也能实现生产者消费者模式</li>
</ol>
<a id="more"></a>
<h4 id="wait-notify机制"><a href="#wait-notify机制" class="headerlink" title="wait notify机制"></a>wait notify机制</h4><p>java的Object类里有这么几个方法至关重要</p>
<ol>
<li>wait<br>该方法用来将当前线程置入休眠状态，直到接到这个对象调用了notify或者notifyAll，或者超过一个指定的超时时长。<br>当前线程必须拥有这个对象的monitor，也就是必须获得这个对象的锁才能调用，否则会报java.lang.IllegalMonitorStateException错误。<br>该方法会将当前线程（就是获得锁的那个，假设为线程A）放进这个对象的wait set中，并且线程A会放弃所有获取对该对象锁的主张，线程A停止执行并进入休眠，直到下面四个情况之一出现：    <ul>
<li>其他线程调用该对象的notify，并且线程A刚好被选中唤醒（是否被选中与操作系统实现有关）</li>
<li>其他线程调用该对象的notifyAll</li>
<li>其他线程打断线程A，中断线程会抛出InterruptedException异常，因此，sleep和wait都要catch或者抛出这个异常</li>
<li>指定的超时时长已经过去，如果超时时长为0，那么线程会直接进入休眠<br>线程A被唤醒后会和其他被唤醒的线程竞争获得对象锁，一旦成功获得锁，线程A的锁信息就会全部记录下来，然后线程A就可以从wait中返回，并继续执行下去。<br>wait只能出现在循环中，因为唤醒的时候可能还是不满足执行条件<br>如果在线程wait前或者wait中被打断，那么会抛出一个InterruptedException异常，并且直到对象锁状态被重新存储后才会抛出。<br>在调用 wait()之前，线程必须要获得该对象的对象监视器锁，即只能在同步方法或同步块中调用 wait()方法。调用wait()方法之后，当前线程会释放锁。如果调用wait()方法时，线程并未获取到锁的话，则会抛出IllegalMonitorStateException异常，这是以个RuntimeException。如果再次获取到锁的话，当前线程才能从wait()方法处成功返回。</li>
</ul>
</li>
<li>wait(long timeout)<br>timeout时间后会唤醒线程，重新竞争锁。timeout是最长时间，具体时长会有误差</li>
<li><p>wait(long timeout, long nanos)<br>文档里说是为了更精确的唤醒时间<code>1000000*timeout+nanos</code>，但是代码里这么写的（java 1.8）,看不出来哪里精确了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">    if (timeout &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                            &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (nanos &gt; 0) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>notify()<br>在等待队列中唤醒一个线程，选择规则由系统具体实现，被唤醒的线程要和其他线程公平竞争，重新获得锁才能继续执行下去。该方法只能在当前线程获得锁的情况下才能调用，也就是说必须在Sychronized代码中。一次只能有一个线程拥有对象的监视器。</p>
</li>
<li>notifyAll<br>该方法与 notify ()方法的工作方式相同，重要的一点差异是：<br>notifyAll 使所有原来在该对象上 wait 的线程统统退出WAITTING状态，使得他们全部从等待队列中移入到同步队列中去，等待下一次能够有机会获取到对象监视器锁。<h5 id="wait-notify实现的生产者消费者模式"><a href="#wait-notify实现的生产者消费者模式" class="headerlink" title="wait notify实现的生产者消费者模式"></a>wait notify实现的生产者消费者模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package com.zgq.java;</span><br><span class="line"></span><br><span class="line">import com.zgq.Algorithm;</span><br><span class="line">import com.zgq.Utils;</span><br><span class="line"></span><br><span class="line">import java.util.Objects;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zgq on 2019/4/6.</span><br><span class="line"> */</span><br><span class="line">public class ProducerConsumer implements Algorithm&#123;</span><br><span class="line"></span><br><span class="line">    public static final Object LOCK = new Object();</span><br><span class="line">    public static int count = 0;</span><br><span class="line">    public static final int FULL = 10;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execut() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">            new Thread(new Producer(&quot;producer&quot; + i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">            new Thread(new Consumer(&quot;consumer&quot; + i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Producer implements Runnable &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public Producer(String name)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                synchronized (LOCK) &#123;</span><br><span class="line">                    Utils.printString(name + &quot; lock&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        while (count &gt;= FULL) &#123;</span><br><span class="line">                            Utils.printString(name + &quot; wait&quot;);</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                        Thread.sleep(500);</span><br><span class="line">                        count++;</span><br><span class="line">                        Utils.printString(name + &quot; product 1 &quot; + &quot; now is &quot; + count);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        LOCK.notifyAll();</span><br><span class="line">                        Utils.printString(name + &quot; unlock&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Consumer implements Runnable &#123;</span><br><span class="line">        public String name;</span><br><span class="line">        public Consumer(String name)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                synchronized (LOCK) &#123;</span><br><span class="line">                    Utils.printString(name + &quot; lock&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        while (count &lt;= 0) &#123;</span><br><span class="line">                            Utils.printString(name + &quot; wait&quot;);</span><br><span class="line">                            LOCK.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                        count--;</span><br><span class="line">                        Utils.printString(name + &quot; consume 1 &quot; + &quot; now is &quot; + count);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        LOCK.notifyAll();</span><br><span class="line">                        Utils.printString(name + &quot; unlock&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>使用Lock实现消费者生产者模式与wait-notify相差不多，Lock中Condition的await/signalAll可以达到相同的效果，Lock具体用法这里不深究，具体可以看下篇博客。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package com.zgq.java;</span><br><span class="line"></span><br><span class="line">import com.zgq.Algorithm;</span><br><span class="line">import com.zgq.Utils;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zgq on 2019/4/6.</span><br><span class="line"> */</span><br><span class="line">public class ProducerConsumer1 implements Algorithm &#123;</span><br><span class="line"></span><br><span class="line">    public static final Lock LOCK = new ReentrantLock();</span><br><span class="line">    public static Condition NOTFULL = LOCK.newCondition();</span><br><span class="line">    public static Condition NOTEMPTY = LOCK.newCondition();</span><br><span class="line">    public static int count = 0;</span><br><span class="line">    public static final int FULL = 10;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execut() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(new Producer(&quot;producer&quot; + i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(new Consumer(&quot;consumer&quot; + i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Producer implements Runnable &#123;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        public Producer(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                LOCK.lock();</span><br><span class="line">                Utils.printString(name + &quot; lock&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    while (count &gt;= FULL) &#123;</span><br><span class="line">                        Utils.printString(name + &quot; wait&quot;);</span><br><span class="line">                        NOTFULL.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(20);</span><br><span class="line">                    count++;</span><br><span class="line">                    Utils.printString(name + &quot; product 1 &quot; + &quot; now is &quot; + count);</span><br><span class="line">                    NOTEMPTY.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    LOCK.unlock();</span><br><span class="line">                    Utils.printString(name + &quot; unlock&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class Consumer implements Runnable &#123;</span><br><span class="line">        public String name;</span><br><span class="line"></span><br><span class="line">        public Consumer(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                LOCK.lock();</span><br><span class="line">                Utils.printString(name + &quot; lock&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    while (count &lt;= 0) &#123;</span><br><span class="line">                        Utils.printString(name + &quot; wait&quot;);</span><br><span class="line">                        NOTEMPTY.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(50);</span><br><span class="line">                    count--;</span><br><span class="line">                    Utils.printString(name + &quot; consume 1 &quot; + &quot; now is &quot; + count);</span><br><span class="line">                    NOTFULL.signal();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    LOCK.unlock();</span><br><span class="line">                    Utils.printString(name + &quot; unlock&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="BlockingQueue实现"><a href="#BlockingQueue实现" class="headerlink" title="BlockingQueue实现"></a>BlockingQueue实现</h4><p>BlockingQueue是一个接口，LinkedBlockingDeque是他的一个实现类，我们看下部分实现代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E takeFirst() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        E x;</span><br><span class="line">        while ( (x = unlinkFirst()) == null)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是lock实现</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>这里用了BlockingQueue的具体实现类LinkedBlockingDeque。链表实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.zgq.java;</span><br><span class="line"></span><br><span class="line">import com.zgq.Algorithm;</span><br><span class="line">import com.zgq.Utils;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zgq on 2019/4/6.</span><br><span class="line"> */</span><br><span class="line">public class ProducerConsumer2 implements Algorithm &#123;</span><br><span class="line"></span><br><span class="line">    public static BlockingQueue storage = new LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    public static final int FULL = 10;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execut() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(new Producer(&quot;producer&quot; + i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(new Consumer(&quot;consumer&quot; + i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Producer implements Runnable &#123;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        public Producer(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(20);</span><br><span class="line">                    if (storage.size() &lt; FULL) &#123;</span><br><span class="line">                        Random random = new Random();</span><br><span class="line">                        int k = random.nextInt();</span><br><span class="line">                        storage.add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Utils.printString(name + &quot; product 1 &quot; + &quot; now is &quot; + storage.size());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Consumer implements Runnable &#123;</span><br><span class="line">        public String name;</span><br><span class="line"></span><br><span class="line">        public Consumer(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(50);</span><br><span class="line">                    if (storage.size() &gt; 0) &#123;</span><br><span class="line">                        storage.take();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Utils.printString(name + &quot; consume 1 &quot; + &quot; now is &quot; + storage.size());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，使用BlockingQueue来实现生产者-消费者很简洁，这正是利用了BlockingQueue插入和获取数据附加阻塞操作的特性。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Java线程安全(1)-Sychronized]]></title>
      <url>/2019/04/07/Sychronized/</url>
      <content type="html"><![CDATA[<h4 id="java锁"><a href="#java锁" class="headerlink" title="java锁"></a>java锁</h4><p>java的锁机制并不复杂，谈到锁一般会提到关键字Sychronized和类Lock以及cas策略，提到锁的分类会提到可重入锁、可中断锁、公平锁/非公平锁、乐观锁/悲观锁等等，其实了解了原理之后，一切都会豁然开朗。我们一步一步来。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>在了解锁机制之前，我们得先清除为什么会有锁，原因是保证线程安全。在编程中，当多个线程都要对某一变量进行操作时，我们必须保证这些线程在自己操作后所得的结果是正确的，这就是线程安全。而在java中，根据线程安全强度由强至弱排序，将操作共享数据氛围以下五类：<br>不可变：数据不可变，线程安全也就无从谈起<br>绝对线程安全：几乎无法实现<br>相对线程安全：我们通常说的线程安全<br>线程兼容：值对象本身不是线程安全的，但是我们可以通过调用手段达到安全。<br>线程对立：无论何种情况，无论调用端使用何种方式，都无法使用并发代码，因为java天生支持多线程，所以这个思想无用<br>所以我们在java中说的并发同步指的就是相对线程安全和线程兼容这两个概念。</p>
<a id="more"></a>
<h4 id="java中线程安全的实现方式"><a href="#java中线程安全的实现方式" class="headerlink" title="java中线程安全的实现方式"></a>java中线程安全的实现方式</h4><p>互斥同步：就是我们常说的锁机制<br>非阻塞同步：CAS<br>无同步方案</p>
<h4 id="Sychronized"><a href="#Sychronized" class="headerlink" title="Sychronized"></a>Sychronized</h4><p>首先是关键字Sychronized，这是java中最早的也是最常用的锁，这个锁的原理是什么呢？<br>首先，java中对象在内存中存储时分为三块区域，对象头，实例数据，对齐补充，对象头中对象哈希吗，分代年龄，指向锁记录的指针，指向重量级锁的指针等等。我们今天只关注指向重量级锁的指针。该指针指向一个由c++实现的monitor类的对象，每个对象实例都有一个monitor实例，monitor中记录着当前占有该对象的线程，以及等待中的线程，这就是对象的wait方法和notify方法生效的原因。<br>对下面代码中的SychronizedTest类编译出来的class文件进行反编译，命令<code>javap -verbose</code>，查看有同步代码块的print和print1方法，如下图（注意，只有方法中有使用Sychronized同步的代码块才会有这两个code，直接修饰方法不会有，但是会使用<code>ACC_SYNCHRONIZED</code>标志位,比如代码里的<code>print1</code>方法）<br><img src="/2019/04/07/Sychronized/monitor.jpg" alt="" title="monitor code"><br>关于这两条指令的作用，我们直接参考JVM规范中描述：<br>monitorenter:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</span><br><span class="line">• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</span><br><span class="line">• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</span><br><span class="line">• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor&apos;s entry count is zero, then tries again to gain ownership.</span><br></pre></td></tr></table></figure></p>
<p>这段话的大概意思为：</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：<br>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。<br>2.如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.<br>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权</p>
<p>monitorexit:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</span><br><span class="line">The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</span><br></pre></td></tr></table></figure></p>
<p>这段话的大概意思为：<br>执行monitorexit的线程必须是objectref所对应的monitor的所有者。<br>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<p>通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p>
<p>我们再来看一下同步方法的反编译结果：<br><img src="/2019/04/07/Sychronized/acc_sychronized.jpg" alt="" title="monitor code"><br>从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>
<h4 id="Sychronized使用"><a href="#Sychronized使用" class="headerlink" title="Sychronized使用"></a>Sychronized使用</h4><p>Sychronized可以对对象加锁，也可以对类加锁，至于怎么生效主要看1.修饰的是什么，这个影响到竞争的是对象锁还是类锁；2.a对象的锁、b对象的锁以及类的锁之间不存在竞争冲突，具体表现在：<br>对对象加锁，那么只有该对象进入同被Sychronized修饰的方法时才会去竞争锁<br>对类加锁或者修饰静态方法，那就是对类加锁，这时候，所有该类的对象进入Sychronized修饰的静态方法时都需要先竞争类锁，也就是所谓的类锁对所有对象生效<br>其实说了这么多，总结起来无非3句话<br>1.对象锁是由对象维护的，类锁是由类的对象维护的，两者并不冲突。这里的不冲突表现在，当Sychronized修饰的静态方法被锁定时，Sychronized修饰的非静态方法仍可以进入，未被Sychronized修饰的方法也可以进入。<br>2.只有请求同一个锁的时候才会发生同步问题<br>3.代码块只会锁定代码块，其余部分可以被其他线程调用    </p>
<p>那么Sychronized怎么使用呢？下面是使用Sychronized实现两种加锁方式，并不会发生冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package com.zgq.java;</span><br><span class="line"></span><br><span class="line">import com.zgq.Algorithm;</span><br><span class="line">import com.zgq.Utils;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zgq on 2019/4/6.</span><br><span class="line"> */</span><br><span class="line">public class SychronizedTest implements Algorithm &#123;</span><br><span class="line">    private SychronizedTest test1;</span><br><span class="line">    private SychronizedTest test2;</span><br><span class="line">    private static int count = 5;</span><br><span class="line"></span><br><span class="line">    public SychronizedTest()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void execut() &#123;</span><br><span class="line">        test1 = new SychronizedTest();</span><br><span class="line">        new Thread(new Test1(&quot;thread 1&quot;, test1)).start();</span><br><span class="line">        new Thread(new Test2(&quot;thread 2&quot;, test1)).start();</span><br><span class="line">        new Thread(new Test3(&quot;thread 3&quot;, test1)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print(String name) throws InterruptedException &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            Utils.printString(name + &quot; in and sleep&quot;);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            count--;</span><br><span class="line">            Utils.printString(name + &quot; run count = &quot; + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void print1(String name) throws InterruptedException &#123;</span><br><span class="line">        Utils.printString(name + &quot; in and sleep&quot;);</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        count--;</span><br><span class="line">        Utils.printString(name + &quot; run count = &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">    public void print2(String name) throws InterruptedException &#123;</span><br><span class="line">        Utils.printString(name + &quot; in and sleep&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        count--;</span><br><span class="line">        Utils.printString(name + &quot; run count = &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Test1 implements Runnable &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private SychronizedTest test;</span><br><span class="line">        private Test1(String name, SychronizedTest test) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.test = test;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                test.print1(name);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Test2 implements Runnable &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private SychronizedTest test;</span><br><span class="line">        private Test2(String name, SychronizedTest test) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.test = test;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                test.print(name);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Test3 implements Runnable &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private SychronizedTest test;</span><br><span class="line">        private Test3(String name, SychronizedTest test) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.test = test;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                test.print2(name);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码最终输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread 1 in and sleep</span><br><span class="line">thread 2 in and sleep</span><br><span class="line">thread 3 in and sleep</span><br><span class="line">thread 2 run count = 4</span><br><span class="line">thread 1 run count = 3</span><br><span class="line">thread 3 run count = 2</span><br></pre></td></tr></table></figure></p>
<p>没有同步，可见非同步方法、同步方法、静态同步方法之间因为不会竞争同一锁，所以不会出现同步问题。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[制作抖音视频]]></title>
      <url>/2019/02/23/%E5%88%B6%E4%BD%9C%E6%8A%96%E9%9F%B3%E8%A7%86%E9%A2%91/</url>
      <content type="html"><![CDATA[<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>短视频在近两年大火，尤其抖音快手等，一个庞大的新媒体流量入口已然成型，刚好工作中接触短视频较多，就想自己运营个抖音号，本来以为市场上已有的一些手机app应该可以满足需求，没想到不是模板固定就是体验太差，又或者输出视频清晰度不够，就干脆拿一些用过的视频工具来做了</p>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li>iMovie：主要用来截取片段，当然FFmpeg也完全可以胜任，但是视觉化的iMovie或者其他商业软件会更方便</li>
<li>ffmpeg：主要用来裁剪视频添加水印<h4 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h4></li>
<li>官网 <a href="https://ffmpeg.org/ffmpeg.html" target="_blank" rel="noopener">https://ffmpeg.org/ffmpeg.html</a></li>
<li>命令基本公式<br><code>ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...</code></li>
</ul>
<a id="more"></a>
<ul>
<li>滤镜<ul>
<li>文档 <a href="https://ffmpeg.org/ffmpeg-filters.html" target="_blank" rel="noopener">https://ffmpeg.org/ffmpeg-filters.html</a></li>
<li>ffmpeg的滤镜使用的是libavfilter，几个连续的滤镜成为filtergraphs，ffmpeg有Simple filtergraphs和Complex filtergraphs两种</li>
<li>Simple filtergraphs<ul>
<li>只有一个输入和一个输出，且输入输出类型相同</li>
<li>指令<code>-vf</code>，是<code>-filter:v</code>的简称，v即video。<ul>
<li>tip：<code>-af</code>是音频滤镜，全称<code>-filter:a即audio</code><br><img src="/2019/02/23/制作抖音视频/1.jpg" alt="" title="Simple filtergraphs"></li>
</ul>
</li>
</ul>
</li>
<li>Complex filtergraphs<ul>
<li>多个输入输出</li>
<li>指令<code>-filter_complex</code><br><img src="/2019/02/23/制作抖音视频/2.jpg" alt="" title="Complex filtergraphs"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul>
<li>下载下来电影后，用tunesKit video cutter或者ffmpeg进行大致的片段选取，这一步主要是为了减少剪辑文件的大小</li>
<li>如果需要转格式，使用ffmpeg或者aimersoft video converter ultimate</li>
<li>使用iMovie进行细致的剪辑，输出视频</li>
<li>如果视频比例不合适，比如16：9，这种在抖音里看起来显得有点扁，屏幕利用率较低，可以先进行裁剪<ul>
<li><code>ffmpeg -i source.mp4 -vf crop=1440:1080:240:0 output.mp4</code><ul>
<li><code>-i</code> 表示输入文件</li>
<li><code>-vf</code> 简单滤镜图</li>
<li><code>crop</code>是一个裁剪滤镜，<a href="https://ffmpeg.org/ffmpeg-filters.html#crop，" target="_blank" rel="noopener">https://ffmpeg.org/ffmpeg-filters.html#crop，</a> 需要四个参数，1440:1080:240:0分别指输出视频的宽，高，源视频内容在输出视频中的位置，原点是视频左上角</li>
</ul>
</li>
</ul>
</li>
<li>使用ffmpeg将视频比例改为16：9，多余地方黑色填充<ul>
<li><code>ffmpeg -i source.mp4 -vf pad=1920:3413:0:1150:black -y output.mp4</code><ul>
<li><code>-pad</code>: <a href="https://ffmpeg.org/ffmpeg-filters.html#pad-1，" target="_blank" rel="noopener">https://ffmpeg.org/ffmpeg-filters.html#pad-1，</a> 文档解释：Add paddings to the input image, and place the original input at the provided x, y coordinates.意思很明显了，pad就是padding</li>
<li><code>-y</code>: Overwrite output files without asking</li>
</ul>
</li>
</ul>
</li>
<li>加水印<ul>
<li><code>ffmpeg -i source.mp4 -vf &quot;movie=overlay.png,scale=480:50[watermask];[in][watermask] overlay=200:2000[out]&quot; -y out.mp4</code></li>
<li><code>-movie</code>: Read audio and/or video stream(s) from a movie container,使用<code>scale</code>进行缩放，输出第一次结果watermask，中括号中为label，ffmpeg中使用<code>[]</code>打标表示某一个流，可以在后面进行引用</li>
<li><code>[in]</code>:primary input，指代主输入流</li>
<li><code>[watermask]</code>，第一个滤镜的产出名字，当然名字可以随便取</li>
<li><code>overlay</code>:It takes two inputs and has one output. The first input is the “main” video on which the second input is overlaid,打水印的主要操作</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 视频 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Weex系列(1)-环境与工具]]></title>
      <url>/2018/11/29/Weex%E7%B3%BB%E5%88%97-1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h4 id="什么是Weex"><a href="#什么是Weex" class="headerlink" title="什么是Weex"></a>什么是Weex</h4><p>Weex官网的一句话介绍：Weex 是一个使用 Web 开发体验来开发高性能原生应用的框架。<br>Weex是由阿里巴巴开发的，基于先进Web技术，使用同一套代码来构建 Android、iOS 和 Web 应用。具体来讲，在集成了 WeexSDK 之后，你可以使用 JavaScript 和现代流行的前端框架来开发移动应用。</p>
<ul>
<li>支持的前端框架<ul>
<li>Vue.js</li>
<li>Rax</li>
</ul>
</li>
</ul>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><a id="more"></a>
<p>关于环境，<a href="http://weex.apache.org/cn/guide/set-up-env.html" target="_blank" rel="noopener">官网介绍</a>已经非常详细了<br>需要注意的是</p>
<ul>
<li>在 package.json 中，已经配置好了几个常用的 npm script，分别是：<ul>
<li>build: 源码打包，生成 JS Bundle</li>
<li>dev: webpack watch 模式，方便开发</li>
<li>serve: 开启HotReload服务器，代码改动的将会实时同步到网页中</li>
</ul>
</li>
<li>Weex 官方提供了 weex-toolkit 的脚手架工具来辅助开发和调试，通过<code>install -g weex-toolkit</code>安装后就可以使用<code>weex</code>命令来创建weex工程了</li>
</ul>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><ul>
<li>创建一个Weex项目<br><code>weex create awesome-project</code><br>执行完命令后，在 <code>awesome-project</code> 目录中就创建了一个使用 Weex 和 Vue 的模板项目。</li>
<li>开启服务<br><code>npm start</code><br>执行完命令后，根据终端提示访问相应网站即可即时浏览效果，使用weex官方app playground也能在手机上进行预览</li>
<li><p>客户端安装包打包</p>
<ul>
<li><p>添加或移除平台</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weex platform add ios</span><br><span class="line">weex platform add android</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weex platform add ios</span><br><span class="line">weex platform add android</span><br></pre></td></tr></table></figure>
<p>查看平台列表<br><code>weex platform list</code></p>
</li>
<li><p>运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weex run ios</span><br><span class="line">weex run android</span><br><span class="line">weex run web</span><br></pre></td></tr></table></figure>
<p>这样运行会直接打出客户端包并进行安装，因此需要提前配置好ios或android的开发环境</p>
</li>
</ul>
</li>
<li><p>输出客户端工程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run pack:ios</span><br><span class="line">npm run pack:android</span><br></pre></td></tr></table></figure>
<p>执行完命令后，在项目中会生成一个新的文件夹platforms，工程就放在这个文件夹中。</p>
</li>
<li>目录结构<br>需要重点关注的几个文件或文件夹（待续）<ul>
<li>configs/config.js</li>
<li>package.json</li>
</ul>
</li>
</ul>
<h4 id="Native端的集成"><a href="#Native端的集成" class="headerlink" title="Native端的集成"></a>Native端的集成</h4><p>输出客户端工程后，可以非常直观的看出Weex SDK的使用方式，但是，我们大部分情况并不是使用输出的工程继续开发，那么怎么接入weex到既有项目呢？</p>
<ul>
<li><p>集成sdk<br>集成sdk的坑有点多，这里要着重说一下Android集成，主要参考<a href="http://weex.apache.org/cn/guide/integrate-to-your-app.html" target="_blank" rel="noopener">Android集成Weex sdk</a></p>
<ul>
<li>中文官网中参考代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;</span><br><span class="line">compile &apos;com.android.support:support-v4:23.1.1&apos;</span><br><span class="line">compile &apos;com.android.support:appcompat-v7:23.1.1&apos;</span><br><span class="line">compile &apos;com.alibaba:fastjson:1.1.46.android&apos;</span><br><span class="line">compile &apos;com.taobao.android:weex_sdk:0.5.1@aar&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意上面的weex_sdk版本是0.5.1，这本来是没有问题的，但是因为weex在0.10.0版本之后全面支持vue2.0，而前面文档中<code>weex create</code>命令创建出来的项目是基于vue2.0的，这会导致在加载编译出的jsbundle时会报错<code>ReferenceError: Vue is not defined</code><br>而英文文档就没有这个问题，英文文档给出的版本是0.18.0，改成0.18.0后虽然能解决上面的问题，但是在load本地jsbundle时又出现失败的错误，所以我使用的是0.16.0。目前weex的版本迭代还是比较频繁的，但是不建议使用最新的，问题会比较多。</p>
</li>
<li>示例代码<ul>
<li><a href="https://github.com/newerZGQ/WeexDemo" target="_blank" rel="noopener">仓库地址</a></li>
</ul>
</li>
</ul>
<h4 id="编译jsbundle"><a href="#编译jsbundle" class="headerlink" title="编译jsbundle"></a>编译jsbundle</h4><ul>
<li>命令<code>npm run build</code><br>其实就是运行package.json内定义得build脚本，运行成功后将dist文件夹复制到客户端工程（或者放在云端动态加载），然后使用weex实例进行渲染即可，这个在示例代码中有所体现</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Weex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AnyTest-Introductin]]></title>
      <url>/2018/11/03/AnyTest-Introduction/</url>
      <content type="html"><![CDATA[<h1 id="AnyTest"><a href="#AnyTest" class="headerlink" title="AnyTest"></a>AnyTest</h1><h2 id="这是什么"><a href="#这是什么" class="headerlink" title="这是什么"></a>这是什么</h2><p>这是一个非常有意思的希望能够提高学生或者文字记忆者效率的一款应用。这款app基于MVP模式，使用Realm进行数据存储，使用RxJava完成异步调用，使用lombok减少代码量，使用butterknife进行view绑定，使用dagger2完成依赖注入，可以说这个项目是使用了相对来说比较新潮的技术来开发的，这也是我做这个项目的初衷，就是接触更多的技术。如果你也对这些项目有兴趣，不防在这里集中的了解一下。</p>
<a id="more"></a>
<h2 id="为什么做"><a href="#为什么做" class="headerlink" title="为什么做"></a>为什么做</h2><p>在我还未成为一名coder之前，有一次因为工作原因，需要记忆大量的题目，题目类型都是比较常见的填空题选择题之类，但是因为题库的书不便于随身携带，就萌发写一个app的想法，希望这个app可以解析文档，并将题目内容完整的存储在app上，并且按照题目类别以不同方式进行展示和交互，帮助记忆，这就是AnyTest的由来。</p>
<h2 id="有什么特点"><a href="#有什么特点" class="headerlink" title="有什么特点"></a>有什么特点</h2><ul>
<li>解析文档<br>把文档整理成类似<a href="https://github.com/newerZGQ/AnyTest/blob/master/Rim/src/main/assets/sample.txt" target="_blank" rel="noopener">这个文件</a>之后放入sd卡中，打开app点击‘+’号选择该文件即可进行解析。文档解析是基于字符的，对文档格式要求较高。</li>
<li>支持题目类型<br>目前支持填空题、判断题、单选题、多选题以及简答题，每种题目都支持交互学习，支持收藏功能</li>
<li>任务管理<br>可以设置文档是否进入学习状态<br>每个解析的文档都可以单独设置每日学习量<br>查看最近一周的学习记录<br>支持每个文档的答题正确率<h2 id="这个项目用了什么"><a href="#这个项目用了什么" class="headerlink" title="这个项目用了什么"></a>这个项目用了什么</h2></li>
<li>MVP模式<br><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">googlesamples/android-architecture</a>这个仓库中对google推崇的MVP模式有非常相近的介绍。</li>
<li>Realm<br><a href="https://realm.io/" target="_blank" rel="noopener">Realm</a>是一个移动端的存储方案，区别于传统sqlite的表的概念，Realm中的增删改查都是针对对象的，也就是说，你查询的结果直接就是一个对象，非常的便捷。Realm中的对象会有多种状态，用于分辨是否可进行修改等操作。另外，Realm还提供了方便的数据库检索app，更加直观的查看当前的数据库内容。</li>
<li>Dagger2<br><a href="https://google.github.io/dagger/" target="_blank" rel="noopener">Dagger2</a>依赖注入的神器，Dagger2相对于Dagger也有很大提升。</li>
<li>lombok<br><a href="https://projectlombok.org/" target="_blank" rel="noopener">lombok</a><br>自动生成代码的神器，远离get和set</li>
<li>RxJava<br><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li>
<li>butterknife<br><a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">butterknife</a><h2 id="这个app能做什么"><a href="#这个app能做什么" class="headerlink" title="这个app能做什么"></a>这个app能做什么</h2><img src="/2018/11/03/AnyTest-Introduction/new.png" title="Introduction">
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 项目 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyTest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java-collection]]></title>
      <url>/2018/02/27/java-collection/</url>
      <content type="html"><![CDATA[<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p><img src="/2018/02/27/java-collection/collection.png" alt=""></p>
<h3 id="重要的接口"><a href="#重要的接口" class="headerlink" title="重要的接口"></a>重要的接口</h3><ol>
<li><p>List（有序、可重复）<br>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</p>
</li>
<li><p>Set（无序、不能重复）<br>Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。</p>
</li>
<li><p>Map（键值对、键唯一、值不唯一）<br>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。</p>
</li>
</ol>
<a id="more"></a>
<p>对比如下<br><img src="/2018/02/27/java-collection/collection-1.jpeg" alt=""></p>
<ol>
<li><p>List，允许重复元素</p>
<p>ArrayList:基于数组实现</p>
<p>Vector:基于数组实现，方法都是同步的(Synchronized),是线程安全的</p>
<p>LinkedList:基于链表实现，两者都有序</p>
</li>
<li><p>Set，不允许有重复值</p>
<p>HashSet基于HashMap实现，只不过Key-Value里面的value都是同一个object，因为是基于hashmap（散列表）实现，所以自然是无序的</p>
<p>TreeSet基于TreeMap实现，只不过Key-Value里面的value都是同一个object，因为是基于TreeMap（红黑树）实现，所以自然是有序的</p>
</li>
<li><p>Map，键值对，key唯一，value可重复</p>
<p>HashMap：最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的</p>
<p>Hashtable:与HashMap类似，也是散列表实现，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。</p>
<p>TreeMap：基于红黑树实现，实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，因为无法比较，非同步的</p>
<p>LinkedHashMap：保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。这是因为LinkedHashMap中的Node有before和after两个引用，分别指向前一个和后一个节点</p>
<p>ConcurrentHashMap：线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。java1.7和1.8的实现有很大区别，见<a href="https://www.cnblogs.com/study-everyday/p/6430462.html" target="_blank" rel="noopener">https://www.cnblogs.com/study-everyday/p/6430462.html</a></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[floor-ceiling-round]]></title>
      <url>/2018/02/09/floor-ceiling/</url>
      <content type="html"><![CDATA[<h2 id="趣味"><a href="#趣味" class="headerlink" title="趣味"></a>趣味</h2><h4 id="floor和ceiling"><a href="#floor和ceiling" class="headerlink" title="floor和ceiling"></a>floor和ceiling</h4><p>为什么向下取整用floor（小于等于给定值n的最大整数），向上取整用ceiling（大于等于给定值n的最小值）。<br>想想在一个房间里，有地板floor（代表整数m），天花板ceiling(代表m+1)，n位于地板和天花板之间，floor不就是小于等于n的最大整数么，ceiling也类似，真是形象~<br>round是指距离最近的整数，比如11.6距离12最近，11.4距离11最近，-11.6距离-12最近，-11.4距离-11最近，需要注意的是.5这个点，.5这个点永远属于数轴右边，比如11.5距离12最近，-11.5距离-11最近</p>
<h4 id="round"><a href="#round" class="headerlink" title="round"></a>round</h4><p>round是指距离最近的整数，这就涉及到.5的情况怎么处理，不管正数还是负数，round后的.5都是返回数轴右边的整数</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[search-algorithm]]></title>
      <url>/2018/02/08/search-algorithm/</url>
      <content type="html"><![CDATA[<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>符号表的主要目的是将一个键和一个值联系起来，可以根据键获得值。我们会用多种方式实现这种数据结构，不仅能高效的插入和查找，还可以进行其他方便的操作。这里我们还会讨论java中符号表的实现。为了熟悉kotlin这里所有的算法都将使用kotlin来实现。</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol>
<li>每个键对应一个值</li>
<li>键值均不允许null（java中hashmap是可以为空的）</li>
<li>删除操作，有延时删除（先置空再删除）和即时删除（直接删除）</li>
<li>迭代，便利所有键</li>
<li>键的等价性，equals判断是否相等，如果使用了comparable接口来进行比较，那么保证equals与compareTo返回值一致。<br><em>总有人问hashmap是否有序，hashmap在使用时对键没有要求，不需要实现接口Iterable，也就是说键无法比较，那么怎么可能是有序的呢</em></li>
</ol>
<a id="more"></a>
<h2 id="基于无序链表的顺序查找"><a href="#基于无序链表的顺序查找" class="headerlink" title="基于无序链表的顺序查找"></a>基于无序链表的顺序查找</h2><p>基于链表的实现，在查找时只能是顺序查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//kt中泛型的使用</span><br><span class="line">class Search&lt;Key : Comparable&lt;Key&gt;,Value&gt;&#123;</span><br><span class="line">  //如果可能为null，则需要加？修饰</span><br><span class="line">    private var first: Node? = null</span><br><span class="line">    private var N: Int = 0</span><br><span class="line">    fun put(key: Key,value: Value)&#123;</span><br><span class="line">        var x:Node? = first</span><br><span class="line">        while (x != null)&#123;</span><br><span class="line">            if (x.key!!.compareTo(key) == 0)&#123;</span><br><span class="line">                x.value = value</span><br><span class="line">                return</span><br><span class="line">            &#125;else x = x.next</span><br><span class="line">        &#125;</span><br><span class="line">        this.first = Node(key,value, first)</span><br><span class="line">        N++</span><br><span class="line">    &#125;</span><br><span class="line">    //返回值有可能为null也需要加？修饰</span><br><span class="line">    fun get(key: Key): Value?&#123;</span><br><span class="line">        var tmp = first</span><br><span class="line">        while (tmp != null)&#123;</span><br><span class="line">            if (tmp.key!!.compareTo(key) == 0) return tmp.value</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        &#125;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun delete(key:Key)&#123;</span><br><span class="line">        if (first == null)&#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if (first?.key?.compareTo(key) == 0) &#123;</span><br><span class="line">            first = first?.next</span><br><span class="line">            N--</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var tmp = first</span><br><span class="line">        var pre : Node? = null</span><br><span class="line"></span><br><span class="line">        while (tmp != null)&#123;</span><br><span class="line">            if (tmp.key.compareTo(key) == 0)&#123;</span><br><span class="line">                pre?.next = tmp.next</span><br><span class="line">                N--</span><br><span class="line">                return</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                pre = tmp</span><br><span class="line">                tmp = tmp.next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun size(): Int &#123;</span><br><span class="line">        return N</span><br><span class="line">    &#125;</span><br><span class="line">    //内部类，还有嵌套类，有区别，构造函数在类声明后面</span><br><span class="line">    inner class Node(val key: Key, var value: Value, var next: Node?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于无序链表的查找，未命中的查找和插入操作都需要N次比较。向一个空表中连续插入N个键需要$~\frac{N^2}{2}$次比较。所以基于无需链表的实现效率很低。</p>
<h2 id="基于有序数组的二分查找"><a href="#基于有序数组的二分查找" class="headerlink" title="基于有序数组的二分查找"></a>基于有序数组的二分查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">class BinarySearch(var N: Int)&#123;</span><br><span class="line"></span><br><span class="line">    var keys = arrayOfNulls&lt;String&gt;(N)</span><br><span class="line">    var values = arrayOfNulls&lt;String&gt;(N)</span><br><span class="line">    //指示当前最后一个元素的位置</span><br><span class="line">    var index: Int = -1</span><br><span class="line"></span><br><span class="line">    fun put(key:String,value:String)&#123;</span><br><span class="line">        //i指向大于key的第一个位置</span><br><span class="line">        val i = rank(key)</span><br><span class="line">        //如果存在直接更新并返回</span><br><span class="line">        if (i&lt;=index &amp;&amp; key.compareTo(keys[i]!!) == 0)&#123;</span><br><span class="line">            values[i] = value</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        //不存在key的话，将所有大于key的元素全部向后移动一位，再插入</span><br><span class="line">        relocation(i,index,keys,values)</span><br><span class="line">        keys[i] = key</span><br><span class="line">        values[i] = value</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这是最直接的二分查找</span><br><span class="line">    fun get(key:String):String?&#123;</span><br><span class="line">        var i = rank(key,0,index)</span><br><span class="line">        if (i&lt;=index &amp;&amp; key.compareTo(keys[i]!!) == 0)&#123;</span><br><span class="line">            return values[i]</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun delete(key:String)&#123;</span><br><span class="line">        var i = rank(key)</span><br><span class="line">        if (key.compareTo(keys[i]!!) == 0)&#123;</span><br><span class="line">            relocationReserv(i+1,index,keys,values)</span><br><span class="line">            index--</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果表中存在key，rank方法返回key的位置，也就是小于key的键的数量</span><br><span class="line">    //如果表中不存在key，rank方法还是返回小于key的键的数量</span><br><span class="line">    //下面是递归实现</span><br><span class="line">    private fun rank(key:String, lo:Int, hi:Int):Int&#123;</span><br><span class="line">        if (hi&lt;lo) return lo</span><br><span class="line">        var mid = lo + (hi-lo)/2</span><br><span class="line">        val com = key.compareTo(keys[mid]!!)</span><br><span class="line">        if (com &gt; 0) return rank(key,mid+1,hi)</span><br><span class="line">        else if (com &lt; 0) return rank(key,lo,mid-1)</span><br><span class="line">        return mid</span><br><span class="line">    &#125;</span><br><span class="line">    //迭代实现</span><br><span class="line">    private fun rank(key: String):Int&#123;</span><br><span class="line">        var lo = 0</span><br><span class="line">        var hi = index</span><br><span class="line">        while (lo &lt;= hi)&#123;</span><br><span class="line">            var mid = lo+(hi-lo)/2</span><br><span class="line">            var com = key.compareTo(keys[mid]!!)</span><br><span class="line">            if (com == 0) return mid</span><br><span class="line">            else if (com&gt;0) lo = mid+1</span><br><span class="line">            else if (com&lt;0) hi = mid-1</span><br><span class="line">        &#125;</span><br><span class="line">        return lo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回一定范围内的key</span><br><span class="line">    fun rangeKeys(loKey:String, hiKey: String): Iterable&lt;String&gt; &#123;</span><br><span class="line">        var result = ArrayList&lt;String&gt;(N)</span><br><span class="line">        var lo = rank(loKey)</span><br><span class="line">        var hi = rank(hiKey)</span><br><span class="line">        for (i in lo..hi)&#123;</span><br><span class="line">            result.add(keys[i]!!)</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun relocation(start:Int, end: Int, array1: Array&lt;String?&gt;, array2: Array&lt;String?&gt;)&#123;</span><br><span class="line">        val max = array1.size-1</span><br><span class="line">        for (i in end downTo start)&#123;</span><br><span class="line">            if (i &lt; max)&#123;</span><br><span class="line">                array1[i+1] = array1[i]</span><br><span class="line">                array2[i+1] = array2[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun relocationReserv(start:Int,end: Int, array1: Array&lt;String?&gt;, array2: Array&lt;String?&gt;)&#123;</span><br><span class="line">        val max = array1.size-1</span><br><span class="line">        for (i in start..end)&#123;</span><br><span class="line">            if (i&lt;=max)&#123;</span><br><span class="line">                array1[i-1] = array1[i]</span><br><span class="line">                array2[i-1] = array2[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array1[end] = null</span><br><span class="line">        array2[end] = null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分查找很快，在N个键的有序数组中进行二分查找最多需要(lgN+1)次比较（无论是否成功）。插入一个新元素在最坏的情况下要访问数组~2N次，因此向一个空符号表中插入N个元素在最坏情况下需要访问$~N^2$次数组。也就是说，基于有序数组实现的符号表插入效率低下，这是一个缺陷。</p>
<h2 id="基于链表和有序数组的符号表实现比较"><a href="#基于链表和有序数组的符号表实现比较" class="headerlink" title="基于链表和有序数组的符号表实现比较"></a>基于链表和有序数组的符号表实现比较</h2><p><img src="/2018/02/08/search-algorithm/table_implement_by_list_and_array.png" alt=""></p>
<p><img src="/2018/02/08/search-algorithm/table_implements.png" alt=""></p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>要支持高效的插入操作，需要支持二分查找的链式结构，但单链表显然无法满足，因为二分查找的高效来自于可以通过索引快速的入得任何数组的中间元素，但得到链表中间元素的唯一方法就是遍历。将二分查找和链表的灵活性结合起来，我们需要更复杂的数据结构，就是二叉查找树。</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现<em>二叉查找树和二叉堆</em>。<br>二叉树的根结点所在的层数为1，根结点的孩子结点所在的层数为2，以此下去。深度是指所有结点中最深的结点所在的层数。<br>二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其叶子结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。<br>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2n+1。深度为k的完全二叉树，至少有2^（k-1)个节点，至多有2^k-1个节点。<br>二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态：<br>(1)空二叉树<br>(2)只有一个根结点的二叉树<br>(3)只有左子树<br>(4)只有右子树<br>(5)完全二叉树<br>注意：尽管二叉树与树有许多相似之处，但二叉树不是树的特殊情形。</p>
<h5 id="二叉树类型"><a href="#二叉树类型" class="headerlink" title="二叉树类型"></a>二叉树类型</h5><ol>
<li>完全二叉树</li>
<li>满二叉树</li>
<li>平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<h5 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h5>树的结点：包含一个数据元素及若干指向子树的分支；<br>孩子结点：结点的子树的根称为该结点的孩子；<br>双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；<br>兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点；<br>祖先结点: 从根到该结点的所经分支上的所有结点；<br>子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙；<br>结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；<br>树的深度：树中最大的结点层<br>结点的度：结点子树的个数<br>树的度： 树中最大的结点度。<br>叶子结点：也叫终端结点，是度为 0 的结点；<br>分枝结点：度不为0的结点；<br>有序树：子树有序的树，如：家族树；<br>无序树：不考虑子树的顺序；<h5 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h5>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，<em>树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示</em>。<br>设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。<br>如何记忆三种遍历：<br>注意，DLR是先<em>根</em>次序遍历，即判断先中后的方式是看何时访问双亲节点，而LR永远都是先左后右的顺序。<h4 id="二叉树实现"><a href="#二叉树实现" class="headerlink" title="二叉树实现"></a>二叉树实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">package com.zgq;</span><br><span class="line"></span><br><span class="line">public class BST &lt;Key extends Comparable&lt;Key&gt;,Value&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    private class Node&#123;</span><br><span class="line">        private Key key;</span><br><span class="line">        private Value value;</span><br><span class="line">        private int N;</span><br><span class="line">        private Node left,right;</span><br><span class="line">        private Node(Key key,Value value,int N)&#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.N = N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(Key key, Value value)&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node put(Node root,Key key,Value value)&#123;</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return new Node(key,value,1);</span><br><span class="line">        &#125;</span><br><span class="line">        int cmp = key.compareTo(root.key);</span><br><span class="line">        if (cmp &gt; 0)&#123;</span><br><span class="line">            root.right = put(root.right,key,value);</span><br><span class="line">        &#125;else if (cmp &lt; 0)&#123;</span><br><span class="line">            root.left = put(root.left,key,value);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            root.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        root.N = sizeOf(root.left) + sizeOf(root.right) + 1;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Value get(Key key)&#123;</span><br><span class="line">        return get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Value get(Node root, Key key)&#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        int cmp = key.compareTo(root.key);</span><br><span class="line">        if (cmp &gt; 0) return get(root.right,key);</span><br><span class="line">        else if (cmp &lt; 0) return get(root.left,key);</span><br><span class="line">        else return root.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size()&#123;</span><br><span class="line">        return sizeOf(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int sizeOf(Node root)&#123;</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line">        return root.N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Value max()&#123;</span><br><span class="line">        return max(root).value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node max(Node root)&#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        if (root.right == null) return root;</span><br><span class="line">        return max(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Value min()&#123;</span><br><span class="line">        return min(root).value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node min(Node root)&#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        if (root.left == null) return root;</span><br><span class="line">        return min(root.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete(Key key)&#123;</span><br><span class="line">        delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    //删除节点并返回根节点</span><br><span class="line">    private Node delete(Node root,Key key)&#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        int cmp = key.compareTo(root.key);</span><br><span class="line">        //在右子树中进行删除，同时保证root的右节点指向删除后得根节点</span><br><span class="line">        if (cmp &gt; 0) root.right = delete(root.right,key);</span><br><span class="line">        else if (cmp &lt; 0) root.left = delete(root.left,key);</span><br><span class="line">        else &#123;</span><br><span class="line">            //如果找到节点，则分步删除</span><br><span class="line">            //左子树为空，则返回右子树根节点</span><br><span class="line">            if (root.left == null) return root.right;</span><br><span class="line">            //右子树为空，则返回左子树根节点</span><br><span class="line">            if (root.right == null) return root.left;</span><br><span class="line">            //左右都不为空，则将右子树中最小的节点copy到要删除节点root的位置，同时新root的左子树链接原root的左子树，新root的右子树链接删除最小节点后得右子树</span><br><span class="line">            Node t = root;</span><br><span class="line">            root = min(root.right);</span><br><span class="line">            root.left = t.left;</span><br><span class="line">            root.right = deleteMin(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        root.N = sizeOf(root.left) + sizeOf(root.right) + 1;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteMin()&#123;</span><br><span class="line">        root = deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node deleteMin(Node root)&#123;</span><br><span class="line">        if (root.left == null) return root.right;</span><br><span class="line">        root.left = deleteMin(root.left);</span><br><span class="line">        root.N = sizeOf(root.left) + sizeOf(root.right) + 1;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteMax()&#123;</span><br><span class="line">        root = deleteMax(root);</span><br><span class="line">    &#125;</span><br><span class="line">    //删除最大节点并返回根节点</span><br><span class="line">    private Node deleteMax(Node root)&#123;</span><br><span class="line">        if (root.right == null) return root.left;</span><br><span class="line">        //递归实现</span><br><span class="line">        root.right = deleteMax(root.right);</span><br><span class="line">        root.N = sizeOf(root.left) + sizeOf(root.right) + 1;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        public Key floor(Key key)&#123;</span><br><span class="line">        return floor(root,key).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node floor(Node root, Key key)&#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        int cmp = key.compareTo(root.key);</span><br><span class="line">        if (cmp == 0) return root;</span><br><span class="line">        else if (cmp &lt; 0) &#123;</span><br><span class="line">            return floor(root.left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        Node t = floor(root.right,key);</span><br><span class="line">        if (t != null) return t;</span><br><span class="line">        else return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Key ceiling(Key key)&#123;</span><br><span class="line">        return ceiling(root,key).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node ceiling(Node root, Key key)&#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        int cmp = key.compareTo(root.key);</span><br><span class="line">        if (cmp == 0) return root;</span><br><span class="line">        else if (cmp &gt; 0) &#123;</span><br><span class="line">            return ceiling(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        Node t = ceiling(root.left,key);</span><br><span class="line">        if (t != null) return t;</span><br><span class="line">        else return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回比key小的节点数量</span><br><span class="line">    public int rank(Key key)&#123;</span><br><span class="line">        return rank(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int rank(Node root, Key key)&#123;</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line">        int cmp = key.compareTo(root.key);</span><br><span class="line">        if (cmp &lt; 0) return rank(root.left,key);</span><br><span class="line">        //注意这里，当key比root节点大时，返回root的子节点数量+对root右子树做rank操作的结果+1</span><br><span class="line">        else if (cmp &gt; 0) return 1 + sizeOf(root.left) + rank(root.right,key);</span><br><span class="line">        else return sizeOf(root.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回排名为k的元素，从0开始排</span><br><span class="line">    public Key select(int k)&#123;</span><br><span class="line">        return select(root,k).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node select(Node root, int k)&#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        int t = sizeOf(root.left);</span><br><span class="line">        if (t &lt; k) return select(root.right,k-t-1);</span><br><span class="line">        else if (t &gt; k) return select(root.left,k);</span><br><span class="line">        else return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //范围查找操作</span><br><span class="line">    //返回所有键，无序</span><br><span class="line">    public Iterable&lt;Key&gt; keys()&#123;</span><br><span class="line">        return keys(min(),max());</span><br><span class="line">    &#125;</span><br><span class="line">    //返回lo到hi之间的所有键</span><br><span class="line">    public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = new ArrayBlockingQueue&lt;&gt;(10);</span><br><span class="line">        keys(root,queue,lo,hi);</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void keys(Node root, Queue&lt;Key&gt; queue,Key lo,Key hi)&#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line">        int cmpLo = lo.compareTo(root.key);</span><br><span class="line">        int cmpHi = hi.compareTo(root.key);</span><br><span class="line">        if (cmpLo &lt;= 0 &amp;&amp; cmpHi &gt;= 0)&#123;</span><br><span class="line">            queue.add(root.key);</span><br><span class="line">        &#125;</span><br><span class="line">        if (cmpLo &lt; 0)&#123;</span><br><span class="line">            keys(root.left,queue,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">        if (cmpHi &gt; 0)&#123;</span><br><span class="line">            keys(root.right,queue,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printAllLDR()&#123;</span><br><span class="line">        printAllLDR(root);</span><br><span class="line">        System.out.print(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void printAllLDR(Node root)&#123;</span><br><span class="line">        if (root.left != null) &#123;</span><br><span class="line">            printAllLDR(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;*&quot; + root.key + &quot;*&quot;);</span><br><span class="line">        if (root.right != null) &#123;</span><br><span class="line">            printAllLDR(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用二叉查找树的算法运算时间取决于树的形状，而树的形状右取决于键被插入的先后顺序。在最好的情况下，N个节点的数是完全平衡的，每条空链到根节点的距离都是lgN。但是在最坏的情况下，搜索路径上可能有N个节点。<br>二叉查找树和快排有极高的相似度，根节点就是快排的切分元素。  </p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>在由N个随机键构造的二叉查找树中，查找命中平均所需比较次数~2lgN（约1.39lgN）。</li>
<li>在由N个随机键构造的二叉查找树中，插入操作和查找未命中平均所需比较次数~2lgN（约1.39lgN）。<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4></li>
<li>在一棵二叉查找树中，所有操作在最坏情况下所需时间都和树的高度成正比。</li>
<li>二叉树的优势还在于其支持高效的rank(),select(),delete()以及范围查找操作。</li>
<li>某些最坏的情况下仍有恶劣的性能。<h2 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h2>在一个含有N个节点的树中，我们希望树高为lgN，这样就能保证每次查找都能在树高次比较中结束，就像二分查找一样。但是在动态插入中保证树的完美平衡代价很大，这节将要解决这个问题。<h4 id="23查找树"><a href="#23查找树" class="headerlink" title="23查找树"></a>23查找树</h4><img src="/2018/02/08/search-algorithm/23-search-tree.png" alt=""><br>一颗完美平衡的23查找树中的所有空节点到根节点的距离都是相同的</li>
<li>查找，与二叉树类似</li>
<li>插入：插入操作较为麻烦，在二叉树中插入时，我们是先做一个查找，如果未命中，则把新节点挂在树的底部，这样的影响是树无法保证完美平衡性。使用23树可以避免这种情况。<h5 id="插入过程详解"><a href="#插入过程详解" class="headerlink" title="插入过程详解"></a>插入过程详解</h5></li>
<li>未命中查找结束与一个2节点，把2节点转换成3节点，再将新节点保存在其中即可。</li>
<li>树中只含有3节点，</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[颜色空间]]></title>
      <url>/2018/02/08/color-space/</url>
      <content type="html"><![CDATA[<p>RGB、YUV和HSV颜色空间模型<br><a href="https://www.cnblogs.com/justkong/p/6570914.html" target="_blank" rel="noopener">https://www.cnblogs.com/justkong/p/6570914.html</a></p>
<p>kiwiplayer的视频增强算法中，luma方法是将rgb颜色转换为yuv颜色空间来计算的。  </p>
<p>采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号。  </p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图像 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[algorithm-question]]></title>
      <url>/2018/01/27/algorithm-question/</url>
      <content type="html"><![CDATA[<h4 id="主键都相同，选择排序和插入排序谁快"><a href="#主键都相同，选择排序和插入排序谁快" class="headerlink" title="主键都相同，选择排序和插入排序谁快"></a>主键都相同，选择排序和插入排序谁快</h4><p>选择排序：比较N*(N-1)/2,交换0；<br>插入排序：比较N-1，交换0；<br>插入排序更快</p>
<h4 id="逆序数组，插入排序与选择排序"><a href="#逆序数组，插入排序与选择排序" class="headerlink" title="逆序数组，插入排序与选择排序"></a>逆序数组，插入排序与选择排序</h4><p>选择排序：比较N<em>(N-1)/2,交换N-1；<br>插入排序：比较N\</em>(N-1)/2,交换N*(N-1)/2；<br>插入排序更快</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[sort-algorithm]]></title>
      <url>/2018/01/23/sort-algorithm/</url>
      <content type="html"><![CDATA[<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>一般用于小型数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void selection(Comparable[] a)&#123;</span><br><span class="line">    for (int i = 0; i &lt; a.length; i++)&#123;</span><br><span class="line">        int min = i;</span><br><span class="line">        for (int j = i + 1 ; j &lt; a.length; j++)&#123;</span><br><span class="line">            if (a[min].compareTo(a[j]) &gt; 0)&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a,min,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>一般用于小型数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void insertion(Comparable[] a)&#123;</span><br><span class="line">    for (int i = 0; i &lt; a.length - 1; i++)&#123;</span><br><span class="line">        for (int j = i ; j &gt; 0 &amp;&amp; a[j-1].compareTo(a[j]) &gt; 0 ; j--)&#123;</span><br><span class="line">            exch(a,j-1,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>内循环是插入排序，第一个for循环相当于完成了所有h有序数组的插入排序。比较顺序是：</p>
<ol>
<li>第一个h有序数组的前一位插入排序</li>
<li>第二个h有序数组的前一位插入排序直到第h个有序数组的前一位插入排序</li>
<li>第一个h有序数组的前两位插入排序直到第h个有序数组的前两位插入排序</li>
<li>同理，直到第h个有序数组的所有位数插入排序</li>
</ol>
<p>下面程序中的h不断减小直到为1，这个时候数组就是有序的了。<br>这个程序中，<code>h = 3*h +1</code>,即1，4，13·····，这个序列叫递增序列，递增序列的选择有很多，可以在运行时计算得到，也可以保存在数组中。递增序列的选择会直接影响希尔排序的性能，在普通情况下，<code>h = 3*h +1</code>足够满足我们。<br>希尔排序的优势在于可以处理中型数组，且不会占用额外的空间。<br>希尔排序与选择排序和插入排序相比，希尔排序也可以用于大型数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void shell(Comparable[] a)&#123;</span><br><span class="line">    int h = 1;</span><br><span class="line">    int N = a.length;</span><br><span class="line">    while(h &lt; N/3) h = h*3 + 1;</span><br><span class="line">    while (h&gt;=1) &#123;</span><br><span class="line">        for (int i = h; i &lt; N; i++) &#123;</span><br><span class="line">            for (int j = i; j &gt;= h &amp;&amp; a[j].compareTo(a[j-h]) &lt; 0; j -= h)</span><br><span class="line">                exch(a,j,j-h);</span><br><span class="line">        &#125;</span><br><span class="line">        h = h/3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序，时间复杂度为NlogN，它的主要缺点是需要额外空间，切额外空间的大小与N成正比。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Merge &#123;</span><br><span class="line"></span><br><span class="line">    private static Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    public static void sort(Comparable[] a)&#123;</span><br><span class="line">        aux = new Comparable[a.length];</span><br><span class="line">        sort(a, 0, a.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //自顶向下递归进行归并排序</span><br><span class="line">    private static void sort(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">        if (hi &lt;= lo) return;</span><br><span class="line">        sort(a,lo,lo + (hi - lo)/2);</span><br><span class="line">        sort(a,lo + (hi - lo)/2 + 1,hi);</span><br><span class="line">        merge(a,lo,hi,lo + (hi - lo)/2);</span><br><span class="line">    &#125;</span><br><span class="line">    //归并方法</span><br><span class="line">    private static void merge(Comparable[] a, int lo, int hi, int mid)&#123;</span><br><span class="line">        for (int i = lo; i &lt;= hi; i++)&#123;</span><br><span class="line">            aux[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int i = lo;</span><br><span class="line">        int j = mid + 1;</span><br><span class="line">        for (int k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">            if (j &gt; hi) a[k] = aux[i++];</span><br><span class="line">            else if (i &gt; mid) a[k] = aux[j++];</span><br><span class="line">            else if (aux[i].compareTo(aux[j])&gt;=0) a[k] = aux[j++];</span><br><span class="line">            else if (aux[i].compareTo(aux[j])&lt;0) a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>归并排序的优化</p>
<ol>
<li><p>对于小规模的数组不再递归，而使用简单的选择排序或者插入排序，因为这两种排序在小规模数组上速度很可能比归并快，一般情况下可以将归并排序缩短10%到15%。<br>在子数组长度小于一定值时（这里是4），使用插入排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">    if (hi &lt;= lo) return;</span><br><span class="line">    if ((hi - lo) &lt; 4)&#123;</span><br><span class="line">        insertion(a, lo, hi);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,lo,lo + (hi - lo)/2);</span><br><span class="line">    sort(a,lo + (hi - lo)/2 + 1,hi);</span><br><span class="line">    merge(a,lo,hi,lo + (hi - lo)/2);</span><br><span class="line">&#125;</span><br><span class="line">public static void insertion(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">    for (int i = lo + 1; i &lt;= hi; i++)&#123;</span><br><span class="line">        for (int j = i ; j &gt; lo &amp;&amp; a[j-1].compareTo(a[j]) &gt; 0 ; j--)&#123;</span><br><span class="line">            exch(a,j-1,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归并时两个子数组，如果左半边的最大值小于右半边的最小值，那么不用归并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">    if (hi &lt;= lo) return;</span><br><span class="line">    if ((hi - lo) &lt; 4)&#123;</span><br><span class="line">        insertion(a, lo, hi);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,lo,lo + (hi - lo)/2);</span><br><span class="line">    sort(a,lo + (hi - lo)/2 + 1,hi);</span><br><span class="line">    if (a[lo + (hi - lo)/2].compareTo(a[lo + (hi - lo)/2 + 1]) &lt; 0) return;</span><br><span class="line">    merge(a,lo,hi,lo + (hi - lo)/2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。</p>
</li>
</ol>
<p>下面代码是实现。实现的核心在于：</p>
<p>1) 每一层递归中，不论是使用插入排序，还是因为左半边右半边已经有序不需要归并，还是需要归并，都要保证dest的正确有序。<br>2) 进入下一层递归时，源数组和辅助数组角色交换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Merge &#123;</span><br><span class="line"></span><br><span class="line">    public static void sort(Comparable[] a)&#123;</span><br><span class="line">        Comparable[] aux = a.clone();</span><br><span class="line">        //注意，要把a放在dest位置上，否则源数组会少一次归并操作</span><br><span class="line">        sort(aux,a,0, a.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sort(Comparable[] src, Comparable[] dest, int lo, int hi)&#123;</span><br><span class="line">        if (hi &lt;= lo) return;</span><br><span class="line">        if ((hi - lo) &lt; 4)&#123;</span><br><span class="line">          //注意，小数组的插入排序要在dest上进行</span><br><span class="line">            insertion(dest, lo, hi);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //在进行下一层归并时，交换源数组和辅助数组，避免复制操作</span><br><span class="line">        sort(dest,src,lo,lo + (hi - lo)/2);</span><br><span class="line">        sort(dest,src,lo + (hi - lo)/2 + 1,hi);</span><br><span class="line">        if (src[lo + (hi - lo)/2].compareTo(src[lo + (hi - lo)/2 + 1]) &lt; 0) &#123;</span><br><span class="line">          //如果从源数组判断此次不需要归并，那么也将相应位置元素copy到dest，即保证dest的元素正确有序</span><br><span class="line">            System.arraycopy(src,lo,dest,lo,hi - lo + 1);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //归并排序时保证dest的正确有序，这样在返回上一层归并时，这里的dest可以作为上一层的辅助数组</span><br><span class="line">        merge(src,dest,lo,hi,lo + (hi - lo)/2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void merge(Comparable[] src, Comparable[] dest, int lo, int hi, int mid)&#123;</span><br><span class="line">        int i = lo;</span><br><span class="line">        int j = mid + 1;</span><br><span class="line">        for (int k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">            if (j &gt; hi) dest[k] = src[i++];</span><br><span class="line">            else if (i &gt; mid) dest[k] = src[j++];</span><br><span class="line">            else if (src[i].compareTo(src[j])&gt;=0) dest[k] = src[j++];</span><br><span class="line">            else if (src[i].compareTo(src[j])&lt;0) dest[k] = src[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void insertion(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">        for (int i = lo + 1; i &lt;= hi; i++)&#123;</span><br><span class="line">            for (int j = i ; j &gt; lo &amp;&amp; a[j-1].compareTo(a[j]) &gt; 0 ; j--)&#123;</span><br><span class="line">                exch(a,j-1,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的是自顶而下的归并，还有自底向上的归并。递归实现的归并排序是算法设计中<em>分治思想</em>的典型应用，即将一个大问题分解成小问题分别解决，再用小问题的答案来解决大问题。在自顶而下的递归中就是这样，在每一次递归中，都降低了数组长度，最后用最深处的微型数组归并结果，反过来求上层递归的答案。<br>其实，由于我们知道上层递归是如何使用下层递归的结果的，所以这里的归并排序可以不使用递归，利用循环，自底向上，先将卫星数组归并，比如先归并长度为1的数组，再归并长度为2的长度为4的，这样下去，将整个数组归并。这样的代码量更少。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a)&#123;</span><br><span class="line">    aux = new Comparable[a.length];</span><br><span class="line">    int N = a.length;</span><br><span class="line">    for (int sz = 1; sz &lt; N; sz *= 2)&#123;</span><br><span class="line">        for (int lo = 0; lo &lt; N - sz; lo = lo+sz*2)&#123;</span><br><span class="line">            int hi = min(lo+sz*2-1,N-1);</span><br><span class="line">            merge(a,lo,hi,lo + (hi-lo)/2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于比较的排序算法"><a href="#基于比较的排序算法" class="headerlink" title="基于比较的排序算法"></a>基于比较的排序算法</h3><p>我们讨论的都是基于比较的排序算法，这些算法的复杂度有上限。<br>命题：没有任何基于比较的算法能够保证使用少于lg(N!)~NlgN次比较将长度为N的数组排序。<br>证明：首先假设没有重复的主键，因为任何排序算法都应该能够处理这种情况。使用二叉树表示所有的比较。<br><img src="/2018/01/23/sort-algorithm/1.png" alt=""><br>上图是N=3的比较树，叶子节点表示排序完成，内部节点表示a[i]和a[j]的一次比较操作，左子树表示a[i]小于a[j]时进行的其他比较，右子树表示a[i]大于a[j]时的其他比较。从根节点到叶子节点的所有路径表示在实际排序中，可能遇到的所有比较。<br>比较树中至少应该有N!个叶子节点，因为长度为N的数组，共有N!中排列方式，如果某个比较树的叶子节点小于N!,那么肯定有一些排列顺序被遗漏，基于这个比较树的算法在使用时，对于某些输入就无法正确的排序。<br>在排序算法中，我们通常关心比较的次数，而最多比较次数就是比较树的高度。高为h的二叉树最多叶子节点$2^h$，比较树中的叶子节点（就是所有的比较路径）数量N!,那么就有$N!<2^h$, 即$h="">\log{N!}$<br>上面的式子告诉我们在设计排序算法时所能达到的最佳效果。即比较次数最低是NlgN。</2^h$,></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>归并排序虽然将算法时间复杂度降低到NlogN，但是需要一个与N成正比的辅助栈，而快排则避免了这个缺点，快排是原地排序，只需要一个很小的辅助栈。<br>快排的优点：</p>
<ol>
<li>时间复杂度为NlogN</li>
<li>原地排序，只需要一个很小的辅助栈</li>
<li>内循环比大多数排序都要小</li>
<li>归并和希尔排序比快排慢，原因就是他们在内循环中还有移动复制操作。<br>缺点：</li>
<li>脆弱，在实现时要非常小心才能避免低劣的性能，许多错误都能导致快排的性能只有平方级别。比如在切分不平衡时可能导致快排极为低效，例如第一次从最小元素切分，第二次从第二小元素切分，这样每次只能移动一个元素，导致一个大数组需要切分很多次，事实上，这种极端情况下会比较$$\frac{1}{2}N^2$$次，我们可以在快排前将数组打乱以避免这种情况。</li>
<li>快排效率依赖切分数组的效果，最好的情况是每次都能将数组对半分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Quick &#123;</span><br><span class="line">    public static void sort(Comparable[] a)&#123;</span><br><span class="line">        sort(a,0,a.length-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sort(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">        if (lo&gt;=hi) return;</span><br><span class="line">        int j = partition(a,lo,hi);</span><br><span class="line">        sort(a,lo,j-1);</span><br><span class="line">        sort(a,j+1,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int partition(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">        Comparable tmp = a[lo];</span><br><span class="line">        //因为lo位置的元素作为切分元素，所以这里本可以设置为lo+1，之所以设置为lo，是为了后面的先++lo做准备</span><br><span class="line">        int lf = lo;</span><br><span class="line">        //同理这里设置为hi+1，是为后面先--ri做准备</span><br><span class="line">        int ri = hi + 1;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">          //先判断界限，避免溢出，不停循环至第一个大于切分元素的位置</span><br><span class="line">            while (++lf &lt;= hi &amp;&amp; tmp.compareTo(a[lf]) &gt; 0);</span><br><span class="line">            while (--ri &gt;= lf &amp;&amp; tmp.compareTo(a[ri]) &lt; 0);</span><br><span class="line">            if (lf&gt;=ri) break;</span><br><span class="line">            exch(a,lf,ri);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a,lo,ri);</span><br><span class="line">        return ri;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>算法改进</p>
<ol>
<li>切换到插入排序，在微型数组长度较短的情况下，使用插入排序比继续递归要快，一般长度在5-15之间(大多数基于递归的排序都可以这样做)。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">    if (hi &gt; lo + 10) insertion(a,lo,hi);</span><br><span class="line">    if (lo&gt;=hi) return;</span><br><span class="line">    int j = partition(a,lo,hi);</span><br><span class="line">    sort(a,lo,j-1);</span><br><span class="line">    sort(a,j+1,hi);</span><br><span class="line">&#125;</span><br><span class="line">private static void insertion(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">    for (int i = lo; i &lt;= hi; i++)&#123;</span><br><span class="line">        for (int j = i; j &gt; lo &amp;&amp; a[j].compareTo(a[i]) &gt; 0; j--)&#123;</span><br><span class="line">            exch(a,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>三取样切分，使用子数组中一小部分元素的中位数来切分，人们发现将取样大小设为3并用大小居中的元素切分效果最好。还可以将切分元素放在数组末尾作为哨兵来去掉数组边界检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static int partition(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">    int x = median(a,lo,lo+1&gt;a.length-1?a.length-1:lo+1,lo+2&gt;a.length-1?a.length-1:lo+2);</span><br><span class="line">    Comparable tmp = a[x];</span><br><span class="line">    exch(a,x,lo);</span><br><span class="line">    int lf = lo;</span><br><span class="line">    int ri = hi + 1;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        while (++lf &lt;= hi &amp;&amp; tmp.compareTo(a[lf])&gt;0);</span><br><span class="line">        while (--ri &gt;= lf &amp;&amp; tmp.compareTo(a[ri]) &lt; 0);</span><br><span class="line">        if (lf&gt;=ri) break;</span><br><span class="line">        exch(a,lf,ri);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a,lo,ri);</span><br><span class="line">    return ri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int median(Comparable[] x, int a, int b, int c)&#123;</span><br><span class="line">    return x[a].compareTo(x[b])&gt;0 ?</span><br><span class="line">            (x[a].compareTo(x[c])&gt;0 ? (x[b].compareTo(x[c]) &gt; 0 ? b : c):a) :</span><br><span class="line">            (x[a].compareTo(x[c])&gt;0 ? a : (x[b].compareTo(x[c]) &gt; 0 ? c : b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三项切分快速排序</p>
</li>
</ol>
<p>对于包含大量重复元素的数组，使用三项切分将排序时间从线性对数降低到线性级别。性能优于普通快排<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void sort3Ways(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">    if (lo&gt;=hi) return;</span><br><span class="line">    Comparable tmp = a[lo];</span><br><span class="line">    int i = lo+1;</span><br><span class="line">    //始终等于tmp的最左位置</span><br><span class="line">    int lt = lo;</span><br><span class="line">    //一次循环结束后，gt刚好在等于tmp的最右位置</span><br><span class="line">    int gt = hi;</span><br><span class="line">    while(i&lt;=gt)&#123;</span><br><span class="line">        int m = tmp.compareTo(a[i]);</span><br><span class="line">        if (m&gt;0) exch(a,i++,lt++);</span><br><span class="line">        //这里的i没有+1，是因为从右边换过来的item大小未知，需要在进行一次比较</span><br><span class="line">        else if (m&lt;0) exch(a,i,gt--);</span><br><span class="line">        else i++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort3Ways(a,lo,lt-1);</span><br><span class="line">    sort3Ways(a,gt+1,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static void exch(Comparable[] source,int i, int j)&#123;</span><br><span class="line">    Comparable tmp = source[j];</span><br><span class="line">    source[j] = source[i];</span><br><span class="line">    source[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>队列中的元素有优先级，最大有限队列，最小优先队列。以最大优先队列为例，这样的数据结构要求支持两种操作，删除最大元素和插入元素，这里我们学习基于二叉堆数据结构的一种优先队列的经典实现方式，用数组保存元素并按照一定条件排序，以高效的实现删除最大元素和插入元素操作。<br>插入一列元素后一个一个的删除最小元素，就可以完成排序，堆排序算法就是源于优先队列的实现  </p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="数组实现（无序）"><a href="#数组实现（无序）" class="headerlink" title="数组实现（无序）"></a>数组实现（无序）</h5><p>参考下压栈的实现，插入时直接将元素插入到数组内，删除最大值时使用一个内循环获得最大元素，然后将最大元素与边界元素互换并删除最大元素。</p>
<h5 id="数组实现（有序）"><a href="#数组实现（有序）" class="headerlink" title="数组实现（有序）"></a>数组实现（有序）</h5><p>插入时将所有较大元素向右移动一格保持数组有序，这样最大元素始终在边界</p>
<h5 id="链表表示"><a href="#链表表示" class="headerlink" title="链表表示"></a>链表表示</h5><p>与数组实现类似，要么插入耗时删除高效，要么插入高效删除耗时</p>
<p>使用无序实现是惰性方法，我们仅在需要的时候才找出最大元素，使用有序实现是积极方法，在插入时保证有序。对于简单的队列和栈，所有操作都可以在常数时间内完成，而优先队列的最坏情况会达到线性时间。而基于数据结构<em>堆</em>的实现能保证插入和删除操作都能更快的执行。</p>
<h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p>数据结构二叉堆的定义：当一个二叉树的每个节点都大于等于他的两个子节点，它被称为堆有序，就是二叉堆。<br>根节点最大  </p>
<h4 id="数组实现二叉堆"><a href="#数组实现二叉堆" class="headerlink" title="数组实现二叉堆"></a>数组实现二叉堆</h4><p>位置k的节点的父节点的位置是<br>$\biggl\lfloor\frac{k}2\biggr\rfloor$，而他的两个子节点分别是2k和2k+1。这样在数组中使用索引在树中移动，很方便。根节点在数组索引为1的位置（不使用第一个位置）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MaxPQ &#123;</span><br><span class="line">    private Comparable[] pq;</span><br><span class="line">    private int N = 0;</span><br><span class="line">    public MaxPQ(int maxN)&#123;</span><br><span class="line">        pq = new Comparable[maxN + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入操作，先插入到二叉堆最后位置，再上浮，保证堆有序</span><br><span class="line">    public void insert(Comparable a)&#123;</span><br><span class="line">        pq[++N] = a;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当元素比父节点大时，上浮保证堆有序</span><br><span class="line">    private void swim(int k)&#123;</span><br><span class="line">        while(k&gt;1 &amp;&amp; pq[k].compareTo(pq[k/2]) &gt; 0)&#123;</span><br><span class="line">            exch(k,k/2);</span><br><span class="line">            k = k/2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //当元素比子节点小时，下潜保证堆有序</span><br><span class="line">    private void sink(int k)&#123;</span><br><span class="line">        while (2*k&lt;=N)&#123;</span><br><span class="line">            int j = 2*k;</span><br><span class="line">            if (j&lt;N &amp;&amp; pq[j].compareTo(pq[j+1]) &lt; 0) j++;</span><br><span class="line">            //如果父节点不比子节点小，结束循环</span><br><span class="line">            if (pq[k].compareTo(pq[j])&gt;0) break;</span><br><span class="line">            exch(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除最大节点分两步，现将最后的节点与首节点交换，再下潜首节点</span><br><span class="line">    public Comparable delMax()&#123;</span><br><span class="line">        Comparable max = pq[1];</span><br><span class="line">        exch(1,N--);</span><br><span class="line">        pq[N+1] = null;</span><br><span class="line">        sink(1);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void exch(int a, int b)&#123;</span><br><span class="line">        Comparable tmp = pq[a];</span><br><span class="line">        pq[a] = pq[b];</span><br><span class="line">        pq[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个含有N个元素的基于堆的优先队列，插入操作只需不超过lgN+1次比较，删除最大元素需要不超过2lgN次比较。</p>
<h4 id="优化二叉堆"><a href="#优化二叉堆" class="headerlink" title="优化二叉堆"></a>优化二叉堆</h4><ol>
<li>调整数组大小</li>
<li>索引优先队列，暂不研究</li>
</ol>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>我们可以把任意优先队列变成一种排序方法：将所有元素插入一个最小优先队列，再重复删除最小元素即可。我们基于堆实现一种排序方法。  </p>
<h5 id="基于堆的排序"><a href="#基于堆的排序" class="headerlink" title="基于堆的排序"></a>基于堆的排序</h5><ol>
<li>用数组实现堆，首先将所有元素直接插入数组中</li>
<li>将前半部分元素倒序做下潜操作</li>
<li>从最后一个元素开始逐个做下潜操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void sort(Comparable[] a)&#123;</span><br><span class="line">    //N是有效元素大小（除去首位）</span><br><span class="line">    int N = a.length-1;</span><br><span class="line">    for (int i = N/2; i &gt;= 1; i--)&#123;</span><br><span class="line">        sink(a,i,N);</span><br><span class="line">    &#125;</span><br><span class="line">    //将首位与最后一个交换，交换后，N减1（这是因为交换后最大元素已经在最后了，之后的操作与最后的最大元素无关），再做sink操作，</span><br><span class="line">    while(N&gt;1)&#123;</span><br><span class="line">        exch(a,N--,1);</span><br><span class="line">        sink(a,1,N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void exch(Comparable[] pq,int a, int b)&#123;</span><br><span class="line">    Comparable tmp = pq[a];</span><br><span class="line">    pq[a] = pq[b];</span><br><span class="line">    pq[b] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sink(Comparable[] pq,int k,int N)&#123;</span><br><span class="line">    while (2*k&lt;=N)&#123;</span><br><span class="line">        int j = 2*k;</span><br><span class="line">        if (j&lt;N &amp;&amp; pq[j].compareTo(pq[j+1]) &lt; 0) j++;</span><br><span class="line">        if (pq[k].compareTo(pq[j])&gt;0) break;</span><br><span class="line">        exch(pq,k,j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="堆排序优化"><a href="#堆排序优化" class="headerlink" title="堆排序优化"></a>堆排序优化</h5><p>先下沉再上浮：在下沉过程中可以将较大的元素直接放入堆底，再将其上浮，这样可以减少比较次数。<br>堆排序是目前已知的唯一能够同时最优利用空间和时间的方法。在最坏的情况下也能保证2NlgN次比较和恒定的额外空间。</p>
<h3 id="各算法对比"><a href="#各算法对比" class="headerlink" title="各算法对比"></a>各算法对比</h3>]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法分析]]></title>
      <url>/2018/01/21/algorithm-analysis/</url>
      <content type="html"><![CDATA[<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>一个程序开始运行到结束需要多少时间，需要使用多少内存，都需要进行算法分析，以求算法达到相对优的性能。算法的时间复杂度和空间复杂度合称为算法的复杂度。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h4 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h4><p>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中<strong>语句的执行次数</strong>成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为<strong>语句频度或时间频度</strong>。记为T(n)。</p>
<a id="more"></a>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p>
<p>一般情况下，$f(n)=N^b(\log{N})^c$</p>
<p>时间频度不同，但时间复杂度可能相同。如：T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。</p>
<p>按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p>
<p>最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。</p>
<p>指数阶0(2n)，显然，时间复杂度为指数阶0(2n)的算法效率极低，当n值稍大时就无法应用。</p>
<h4 id="求时间复杂度"><a href="#求时间复杂度" class="headerlink" title="求时间复杂度"></a>求时间复杂度</h4><ol>
<li>如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=91; y=100;</span><br><span class="line">while(y&gt;0)&#123;</span><br><span class="line">  if(x&gt;100) &#123;</span><br><span class="line">    x=x-10;</span><br><span class="line">    y--;</span><br><span class="line">  &#125; else x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解答： T(n)=O(1)，<br>这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到n没有?<br>没。这段程序的运行是和n无关的，<br>就算它再循环一万年，我们也不管他，只是一个常数阶的函数</p>
<ol>
<li>当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)(其实就是<strong>时间频度的最高阶</strong>,低阶忽略)决定的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=1;</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">        for(j=1;j&lt;=i;j++)</span><br><span class="line">           for(k=1;k&lt;=j;k++)</span><br><span class="line">               x++;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>该程序段中频度最大的语句是第五行<code>x++</code>，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析第五行的执行次数：<br>则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3)</p>
<ol>
<li>算法的时间复杂度不仅仅依赖于问题的规模，还与<strong>输入实例的初始状态</strong>有关。<br>在数值A[0..n-1]中查找给定值K的算法大致如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=n-1;</span><br><span class="line">while(i&gt;=0&amp;&amp;(A[i]!=k))</span><br><span class="line">      i--;</span><br><span class="line">return i;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。</p>
<p>其实在进行算法时间复杂度分析时，我们是假设与输入状态无关的，如果无法保证这一点，那就应该对算法做一下处理：</p>
<p>(1)对最坏情况下的性能保证<br>(2)使用随机化算法、操作序列、均摊分析等方法，详见算法p125</p>
<h4 id="时间复杂度评价性能"><a href="#时间复杂度评价性能" class="headerlink" title="时间复杂度评价性能"></a>时间复杂度评价性能</h4><p>有两个算法A1和A2求解同一问题，时间复杂度分别是T1(n)=100n2，T2(n)=5n3。</p>
<p>（1）当输入量n＜20时，有T1(n)＞T2(n)，后者花费的时间较少。</p>
<p>（2）随着问题规模n的增大，两个算法的时间开销之比5n3/100n2=n/20亦随着增大。即当问题规模较大时，算法A1比算法A2要有效地多。</p>
<p>它们的渐近时间复杂度O(n2)和O(n3)从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。　　</p>
<ol>
<li>固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。</li>
<li>可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。<br>一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))　　其中n为问题的规模，S(n)表示空间复杂度。</li>
</ol>
<h2 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h2><p>在实际算法实现中，时间和空间复杂度通常处于相对立的形势，经常会出现牺牲空间提高时间情况。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[atom_tips]]></title>
      <url>/2018/01/10/atom-tips/</url>
      <content type="html"><![CDATA[<h4 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1 快捷键"></a>1 快捷键</h4><ol>
<li>ctrl+tab切换标签页</li>
<li>ctrl+w 关闭当前标签页，ctrl+k  ctrl+w关闭所有标签页</li>
<li>ctrl+shift+\  切换到目录树，并定位到当前文件,在目录树中切换文件，按右箭头即可打开并回到工作区</li>
<li>ctrl+k ctrl+left arrow 或者 ctrl+k ctrl+right arrow可以在目录树和工作区切换</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tip </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法]]></title>
      <url>/2018/01/08/algorithm/</url>
      <content type="html"><![CDATA[<h4 id="1-开平方"><a href="#1-开平方" class="headerlink" title="1 开平方"></a>1 开平方</h4><p>求常数a的开平方，其实就是对于函数$f(x) = x^2 -a$求解$f(x) = 0$的$x$。这个函数在$x&gt;0$时单调递增，可以使用牛顿法逐步逼近。<br><img src="/2018/01/08/algorithm/sqrt.jpg" alt=""><br>如图所示，先取一个值$x_0$,假设$x_0$是解，判断$x_0$不是解之后，使用$x_0$点的倒数求$x_1$，以此方式逐渐逼近正解。示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static double sqrt(double s)&#123;</span><br><span class="line">  //当所求解与小于该值时，认为已求得正解</span><br><span class="line">    double err = 1E-15;</span><br><span class="line">    double t = s;</span><br><span class="line">    while(Math.abs(t - s/t) &gt; err)&#123;</span><br><span class="line">        t = (t + s/t)/2;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="2-float的表示方法"><a href="#2-float的表示方法" class="headerlink" title="2 float的表示方法"></a>2 float的表示方法</h4><p>java中flaot采用<a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754标准</a>，四字节32位0-31，分为三部分，符号位，指数位，尾数位。<br>|符号位 | 指数位 | 尾数位 |<br>|——-|——-|——-|<br>| 1bit | 8 bit | 23 bit|<br>(1).符号位(S)：最高位（31位）为符号位，表示整个浮点数的正负，0为正，1为负；<br>(2).指数位(E)：23-30位共8位为指数位。根据IEEE754说明，指数的底数可能为2或者10(java中使用2)，规定指数位减去127为指数，取值范围：-127~128，表达式为：$2^{E−127}$。另外，标准中，还规定了，当指数位8位全0或全1的时候，浮点数为非正规形式（这个时候尾数不一样了），所以指数位真正范围为：-126~127。<br>(3).尾数位(M)：0-22位共23位为尾数位，表示小数部分的尾数，即形式为1.M或0.M，至于什么时候是1，什么时候是0，则由指数和尾数共同决定。 小数部分最高有效位是1的数被称为正规（规格化）形式。小数部分最高有效位是0的数被称为非正规（非规格化）形式，其他情况是特殊值。 最终float的值 = $(-1)^{S} \cdot 2^{E-127} \cdot (1.M)$。<br>所以java中的float这样表示，以8.25为例：<br>首先将8.25转换为二进制1000.01，注意转换过程中整数部分与小数部分的区别，表示称二进制的科学计数法为$1.0001\cdot2^3$，也就是说,任何一个数都的科学计数法表示都为$1.xxxx\cdot2^3$，因为任何情况下，首位必为1，所以就省略首位1，将xxxx作为尾数位，所以虽然尾数位是23位，其实表示的是24位。然后指数3+127=130，把130转换成二进制保存在指数位。符号位为1。所以8.25在内存中的表达就是：<br><img src="/2018/01/08/algorithm/floating_point_artithmetic.gif" alt=""><br>这样就能解释float的精度问题了，float的有效位数由尾数位决定，23位尾数加上省略的尾数位最高位1，共24位，$2^24 = 16777216$，也就是说最高有效位数8位，但是16777216并不能覆盖所有8位数，所有最高有效位数是7位。另外，由于在计算过程中会出现四舍五入的情况，所以，在float中，前六位是绝对精确地，第七位可能不精确。<br>总结，float有效位数7位，精确度6位。</p>
<h4 id="3-判断素数"><a href="#3-判断素数" class="headerlink" title="3 判断素数"></a>3 判断素数</h4><p>原理：合数的最小质因子一定小于等于它的平方根。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static boolean isPrime(int n)&#123;</span><br><span class="line">    if (n &lt; 2) return false;</span><br><span class="line">    for (int i = 2; i * i &lt;= n; i++)&#123;</span><br><span class="line">        if (n%i == 0) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-调和数列与调和级数"><a href="#4-调和数列与调和级数" class="headerlink" title="4 调和数列与调和级数"></a>4 调和数列与调和级数</h4><p>调和数列是自然数的倒数构成的数列，其前n项和就是调和级数。求调和级数直接便利求和</p>
<h4 id="5-补码计算原理"><a href="#5-补码计算原理" class="headerlink" title="5 补码计算原理"></a>5 补码计算原理</h4><p>在计算机中，所有的数都是按照补码来存储并计算的，那么什么是补码呢？要完美的理解补码，就要完全抛开课本上以及博客上的关于原码高位不变低位取反加一的论调，并不是说他们是错的，只是取反加一以及最高位作为符号位的说法更适合计算方便，事实上计算机的计算方式确实是高位不变低位取反加一，但这种理解并不准确，相反完全增加了理解补码计算的难度。那么如何理解补码呢？<br>首先，要理解模。以钟表为例，假如现在是三点，如果要求将时间回退五个小时，你会怎么办？两种方法：</p>
<ol>
<li>顺时针拨动时针7格</li>
<li>逆时针拨动时针5格</li>
</ol>
<p>第二个方法理解起来非常简单，回退嘛，那就逆时针，这里要着重说的是第一种，为什么顺时针也能达到逆时针的效果呢？其实，顺时针拨动7格，就是拨动(12-5)格，这里的12就是模，模的存在，将处于模之内的数构成一个环，环内的数都可以通过正向增长或逆向增长的方式变为环内的另一个数(其实就是取膜运算%)。若数超过模，那么就做取模处理，所以值永远小于模。如果时钟的例子不明朗，那么以十进制为例，以10为模，那么，6加7是3，6减3也是3，这就是模10的“环”。<br>那么计算机中为什么要利用模来进行计算呢？<br>因为计算机中只有加法计算，没有减法，任何减法运算都必须转换为加上一个负数来进行。这就带来一个问题，怎么表示这个负数，并且保证计算结果正确呢？这个时候就要使用补码了。<br>现在知道，模有两个性质：</p>
<ol>
<li>存在一个环，当数持续增长到溢出时，会回到最小值</li>
<li>模内的数无论做多少次加减，其值始终小于模，模类似一个极值</li>
</ol>
<p>利用上述两个性质，我们可以将计算机的减法运算简化。<br>在模的范围内，两个相加等于的模得数互为补数，以模10为例，1和9，2和8都互为补数，那么，模范围内的减法$a-b$就可以变换为$a+b\text{的补数}$，还是以模10为例<br>$$5-1 = 5 + (10 -1) = 14  (1)$$<br>14溢出要取模，最终结果是4，计算正确。其实这个过程里的+10就相当于绕环一圈回到正确位置，并不影响计算结果，但也因为这一圈，消除了减法，转换成了加法计算。<br>那么，在计算机内是如何实现的呢？<br>计算机中实现时，牵扯到一个问题，那就是式1的(10-1)在内存中该如何表示，因为既然我们要使用$a+b\text{的补数}$的方式计算，那么$b\text{的补数}$必定要满足两个要求：</p>
<ol>
<li>避开减法运算，不能像式1那样还存在减法</li>
<li>在二进制中能直接通过位运算得到补数</li>
</ol>
<p>于是，大牛们想到了一个完美的办法，映射。<br>我们知道，长度为n的二进制数范围是$\left[0,2^n-1\right]$(后面成为集合Z)，共$2^n$个数,模为$2^n$。现在我们要表示$\left[-2^{n-1},2^{n-1}-1\right]$这个范围的数，也就是要把$\left[-2^{n-1},2^{n-1}-1\right]$内所有的数刚好映射到$\left[0,2^n-1\right]$上。主要分两部分：</p>
<ol>
<li>对于在$\left[0,2^{n-1}-1\right]$范围内的数，可以保持原样(这个对应求补码的正数不变)</li>
<li>对于在$\left[-2^{n-1},0\right)$的数，使用补数映射到Z上，即对于x，在Z上有$2^n-\left|x\right|$与之对应，也就是说负数用她的绝对值的补数来表达。这也解释了为什么$-2^{n-1}$可以使用$1000 0000 …$这样的二进制来表达，因为刚好映射上了啊！这个映射过程其实刚好对应求负数补码的过程：符号位不变并取反加一，但是事实上，在补码的计算中，并不存在符号位。</li>
</ol>
<p>那么，实际计算中，补码如何起作用呢？在上面的十进制例子中，式1，5-1的计算变换为5 + (10 -1)，加10相当于绕环一圈，计算结果14溢出取模后结果是4。也就是说，使用补数进行计算，只要<strong>真实结果</strong>没有溢出，那么可以直接拿补数相加的结果作为真实结果。<br>回到二进制，在任意的二进制加减法中，因为使用了上述原理(就是补码)计算，所以补码的计算结果可以直接作为<strong>正确结果</strong>。需要注意的是，不同于上述十进制的例子，在计算机中，如果补码计算结果在$\left[0,2^{n-1}-1\right]$内，那么，所得结果即为正确答案，如果补码计算结果在$\left[-2^{n-1},0\right)$内，那么，所得结果需要做一个反向映射才是正确答案，但是内存中存储的始终是未做反向映射的那个值。举例来说：<br>在8位计算机中，要把$\left[-128,127\right]$映射到$\left[0,255\right]$上，那么30-100其实就是30+(256-100) = 186,注意内存中始终存储的是186，但是当我们要读出来这个数时，cpu做了反映射 256-186 = 70，70就是所求的正确答案。</p>
<p>tip：其实映射的过程就是一个函数，函数图像为：</p>
<p><img src="/2018/01/08/algorithm/complement_map_figure.png" alt=""></p>
<p>函数值为补码，x为真实值，内存中按照补码存储，需要真实值时做反映射。</p>
<h6 id="所谓的符号位与取反加一"><a href="#所谓的符号位与取反加一" class="headerlink" title="所谓的符号位与取反加一"></a>所谓的符号位与取反加一</h6><p>我们知道，书本中说到补码的时候，都会从遵从原码反码补码的顺序，好像这三者是有着递进关系的，实际上并不是这样。但是我们所说的映射过程和由原码求补码是有一定关联的，下面以8位二进制为例作出解释。<br>首先8位二进制在内存中共有<code>0000 0000</code>到<code>1111 1111</code>共256中情况，可以表示[-128,127]的范围，根据上述的映射原理，这个范围要分两个部分对待[-128,0)和[0,127]：<br>对于数字2，2位于上图右半部分，补码映射函数是$f(x) = x$，<strong>其实这个函数映射关系就对应了书本上的正数的补码不变</strong>，所以补码是<code>0000 0010</code>,注意这个过程中并没有通过原码=&gt;补码来转换，而是直接用了映射，刚好对应。<br>对于数字-2，-2位于上图左半部分，补码映射函数$f(x) = 256 - \left|x\right|$，具体计算是什么样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 0000 0000 - 0000 0010</span><br><span class="line">= 1111 1111 + 0000 0001 - 0000 0010</span><br><span class="line">= (1111 1111 - 0000 0010) + 0000 0001</span><br><span class="line">= (1000 0000 + 0111 1111 - 0000 0000 - 0000 0010) + 0000 0001</span><br><span class="line">//第一个括号表示高位不变，第二个括号表示低位取反，最后加一</span><br><span class="line">= (1000 0000 - 0000 0000) + (0111 1111 - 0000 0010) + 0000 0001</span><br></pre></td></tr></table></figure>
<p>这说明所谓的取反加一并没有什么神秘，只是二进制中求补数的一种便捷的分配算法而已。</p>
<h6 id="关于反码"><a href="#关于反码" class="headerlink" title="关于反码"></a>关于反码</h6><p>我们知道，书本中说到补码的时候会从反码讲解过来，好像补码由反码加一而来，其实这么理解并不合适。上面已经说过补码的映射原理，其实求反码也是一个映射过程。还是以8位二进制为例，求反码的过程其实就是求原数字关于255的补数(对应到补码的模来理解，只不过这里的模是255)。</p>
<p>对于-2，反码计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 - 0000 0010</span><br><span class="line">= 1111 1111 - 0000 0010</span><br><span class="line">= (1000 0000 + 0111 1111 - 0000 0000 - 0000 0010)</span><br><span class="line">//第一个括号表示高位不变，第二个括号表示低位取反，同样取反的言论只是一个计算而已，真正起作用的是求补数</span><br><span class="line">= (1000 0000 - 0000 0000) + (0111 1111 - 0000 0010)</span><br></pre></td></tr></table></figure>
<p>那么求反码的过程还是把[-127,127]映射到[0,255]上。但是8位是可以表示256个数的，而模为255的时候只能表示255个数。多出一个怎么办？我们观察到，[-127,-1]会映射到[128，254]上，那反码255，也就是<code>1111 1111</code>表示什么呢？实际上，<code>1111 1111</code>在加一就是<code>0000 0000</code>，在反码计算中，这两个都可能代表0，一个是所谓的+0，一个是所谓的-0。也就是说，相比于补码，由于反码的模范围比它要表达的数范围大1，模的环出现了”裂缝”，被两个0打断，这也是计算机中补码优于反码计算的原因。</p>
<p>以2-2为例，解释两个0的现象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2-2</span><br><span class="line">= 0000 0010 + 1111 1111 - 0000 0010</span><br><span class="line">= 0000 0010 + 1111 1101</span><br><span class="line">= 1111 1111</span><br></pre></td></tr></table></figure>
<h4 id="5-int溢出"><a href="#5-int溢出" class="headerlink" title="5 int溢出"></a>5 int溢出</h4><p>根据补码的映射与模环的理解，对于int的溢出后的值，可以这样求，int最大值2147483647：</p>
<p>比如2147483648，位于图像左半边，根据映射关系2147483648表示<br>(2147483648 - 4294967296) = -2147483648</p>
<p>比如2147483649，位于图像左半边，根据映射关系2147483649表示<br>(2147483649 - 4294967296) = -2147483647</p>
<p>比如4294967297，先取模4294967297%4294967296为1，位于图像右半边，根据映射关系4294967297表示1</p>
<h6 id="关于int溢出例子"><a href="#关于int溢出例子" class="headerlink" title="关于int溢出例子"></a>关于int溢出例子</h6><p>Math.abs(-2147483648) = 2147483648，2147483648溢出，根据环，最后结果为-2147483648</p>
<h4 id="6-String的intern"><a href="#6-String的intern" class="headerlink" title="6 String的intern()"></a>6 String的intern()</h4><h4 id="7-1-0与1-0-0-0"><a href="#7-1-0与1-0-0-0" class="headerlink" title="7 1/0与1.0/0.0"></a>7 1/0与1.0/0.0</h4><p>前者是devide by zero异常，后者是无限大。<br>1/0出现异常的原因是，1除以0在计算机中无法计算，除法过程会无限持续，另外，即使默认1/0结果是无限大或者NAN也不行，因为在int中没有定义正无穷负无穷和nan，整数是有限的。<br>1.0/0.0结果是无穷大，这是因为float中的0并不完全是0，根据float在内存中的表达方式，0.0是极其接近0的一个小值，所以首先这个除法过程是可以进行的。另外在float中也定义了正负无穷，所以有结果。</p>
<h4 id="8-float的三个值"><a href="#8-float的三个值" class="headerlink" title="8 float的三个值"></a>8 float的三个值</h4><p>正无穷，负无穷，NaN。<br>1.0/0.0 = POSITIVE_INFINITY(正无穷),It is equal to the value returned by Float.intBitsToFloat(0x7f800000).<br>-1.0/0.0 = NEGATIVE_INFINITY(负无穷),It is equal to the value returned by Float.intBitsToFloat(0xff800000).<br>0.0/0.0 = NaN<br>POSITIVE_INFINITY - POSITIVE_INFINITY = NaN<br>另外需要注意的是，Float的MAX_VALUE和MIN_VALUE表示的是float所能表示的最大正数和最小正数(不是最小的负数)</p>
<p>double也有相似的三个值。</p>
<h4 id="9-负整数除法和模"><a href="#9-负整数除法和模" class="headerlink" title="9 负整数除法和模"></a>9 负整数除法和模</h4><p>-14/3 = -4 余 -2<br>14/-3 = -4 余  2<br>-14/-3 = 4 余 -2<br>遵循向零取整：什么意思呢？比如两个正数10和4相除，商2.5，向零取整为2，那么余10-4<em>2 = 2；<br>同理，在负数加入进来后，也遵循向零取整，如 -14/3，商-4.67，向零取整-4，那么余-14-(-4</em>3) = -2;再如14/-3商-4.67，向零取整-4，余14-(-3 * -4) = 2;</p>
<p>负数的模与上面同理。</p>
<h4 id="10-位运算符"><a href="#10-位运算符" class="headerlink" title="10 位运算符"></a>10 位运算符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; | ^</span><br></pre></td></tr></table></figure>
<h4 id="11-求整数的二进制字符串"><a href="#11-求整数的二进制字符串" class="headerlink" title="11 求整数的二进制字符串"></a>11 求整数的二进制字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String getBanaryString(int n)&#123;</span><br><span class="line">  String result = &quot;&quot;;</span><br><span class="line">  for(int i = n; i &gt;= 1 ; i /= 2)&#123;</span><br><span class="line">    result = i%2 + result;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-递归计算ln-N"><a href="#12-递归计算ln-N" class="headerlink" title="12 递归计算ln(N!)"></a>12 递归计算ln(N!)</h4><p>这个比较简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static double calLn(int n)&#123;</span><br><span class="line">    if(n == 1)&#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return calLn(n-1) + Math.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="13-递归计算二项分布"><a href="#13-递归计算二项分布" class="headerlink" title="13 递归计算二项分布"></a>13 递归计算二项分布</h4><p>算法4中的程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static double bino(int n, int k, double p)&#123;</span><br><span class="line">  if(n == 0 &amp;&amp; k == 0)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if(n &lt; 0 || k &lt; 0)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return p*bino(n-1,k-1,p) + (1-p)*bino(n-1,k,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在出口出增加$n<k$的判断，可以有效减少递归次数 <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static double bino(int n, int k, double p)&#123;</span><br><span class="line">  if(n == 0 &amp;&amp; k == 0)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if(n &lt; 0 || k &lt; 0 || n &lt; k)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return p*bino(n-1,k-1,p) + (1-p)*bino(n-1,k,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></k$的判断，可以有效减少递归次数></p>
<p>但是上面的程序递归深度还是很高，k值到50左右就很难算出来了，只能用空间还换取时间，使用数组缓存已经计算出来的结果，程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static double[][] M;</span><br><span class="line">public static double bino(int n, int k, double p)&#123;</span><br><span class="line">  num++;</span><br><span class="line">  if(n == 0 &amp;&amp; k == 0)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if(n &lt; 0 || k &lt; 0 || n &lt; k)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  if(M[n][k] == -1)&#123;</span><br><span class="line">    M[n][k] =  p*bino(n-1,k-1,p) + (1-p)*bino(n-1,k,p);</span><br><span class="line">  &#125;</span><br><span class="line">  return M[n][k];</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  int n = 100, k = 50;</span><br><span class="line">  double p = 0.5;</span><br><span class="line">  M = new double[n+1][k+1];</span><br><span class="line">  for(int i = 0; i &lt; n+1; i++)&#123;</span><br><span class="line">    for(int j = 0; j &lt; k+1; j++)&#123;</span><br><span class="line">      M[i][j] = -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(&quot;bino &quot; + bino(n,k,p)  + &quot; num = &quot; + num + &quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算速度足够快，n = 100, k = 50，递归5201次。</p>
<h6 id="使用循环实现"><a href="#使用循环实现" class="headerlink" title="使用循环实现"></a>使用循环实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用循环就是直接使用二项分布的公式了，代码没意思，不写了</span><br></pre></td></tr></table></figure>
<h4 id="14-求最大公约数"><a href="#14-求最大公约数" class="headerlink" title="14 求最大公约数"></a>14 求最大公约数</h4><p>辗转相除法<br>原理：两个正整数a和b（a&gt;b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。证明也很简单：<br>假设a,b最大公约数为t，则有a=mt,b=nt,a/b=c…r,那么，a=cb+r =&gt; r=a-cb,可以看出a-cb是a，b的线性组合，肯定能被t整除，而最大公约数肯定是小于余数的，所以就有上面的原理了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//循环</span><br><span class="line">public static int gcd(int m, int n)&#123;</span><br><span class="line">    int r = 0;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">      if ((r = m%n) == 0) &#123;</span><br><span class="line">        return n;</span><br><span class="line">      &#125;</span><br><span class="line">      m = n;</span><br><span class="line">      n = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//递归</span><br><span class="line">public static int gcd1(int m, int n)&#123;</span><br><span class="line">  if (m%n == 0) &#123;</span><br><span class="line">    return n;</span><br><span class="line">  &#125;</span><br><span class="line">  return gcd1(n,m%n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相减法<br>原理：两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数。证明略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static int gcd2(int m, int n)&#123;</span><br><span class="line">  int t = 0;</span><br><span class="line">  while(m != n)&#123;</span><br><span class="line">    if (m&gt;n) &#123;</span><br><span class="line">      m = m-n;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      n = n-m;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>辗转相除法的模运算在数字很大的时候效率不高，相减法在两个数相差很大的时候效率不高。<br>改进一下相减法并使用位运算可以提高效率：</p>
<ol>
<li>当a和b均为偶数，$gcb(a,b) = 2<em>gcb(a/2, b/2) = 2</em>gcb(a&gt;&gt;1, b&gt;&gt;1)$</li>
<li>当a为偶数，b为奇数，$gcb(a,b) = gcb(a/2, b) = gcb(a&gt;&gt;1, b)$</li>
<li>当a为奇数，b为偶数，$gcb(a,b) = gcb(a, b/2) = gcb(a, b&gt;&gt;1)$</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int gcd3(int m, int n)&#123;</span><br><span class="line">  if (m == n) &#123;</span><br><span class="line">    return m;</span><br><span class="line">  &#125;</span><br><span class="line">  if (m&lt;n) &#123;</span><br><span class="line">    return gcd3(n,m);</span><br><span class="line">  &#125;</span><br><span class="line">  if ((m&amp;1) != 1 &amp;&amp; (n&amp;1) != 1) &#123;</span><br><span class="line">    return 2*gcd3(m&gt;&gt;1,n&gt;&gt;1);</span><br><span class="line">  &#125;else if ((m&amp;1) != 1 &amp;&amp; (n&amp;1) == 1) &#123;</span><br><span class="line">    return gcd3(m&gt;&gt;1, n);</span><br><span class="line">  &#125;else if ((m&amp;1) == 1 &amp;&amp; (n&amp;1) != 1) &#123;</span><br><span class="line">    return gcd3(m,n&gt;&gt;1);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return gcd3(n,m-n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-最小公倍数"><a href="#15-最小公倍数" class="headerlink" title="15 最小公倍数"></a>15 最小公倍数</h4><p>a，b最大公约数c，则最小公倍数时ab/c</p>
<h4 id="16-求两个数互质"><a href="#16-求两个数互质" class="headerlink" title="16 求两个数互质"></a>16 求两个数互质</h4><p>就是求两个数的最大公约数是否为1，为1则互质。互质的两个数还有一些其他的性质。可以使用这些性质优化算法，避免每次都求最大公约数。</p>
<ol>
<li>两个不同的质数一定是互质数。<br>例如，2与7、13与19。</li>
<li>一个质数，另一个不为它的倍数，这两个数为互质数。<br>例如，3与10、5与 26。</li>
<li>1不是质数也不是合数，它和任何一个自然数（1本身除外）在一起都是互质数。如1和9908。</li>
<li>相邻的两个自然数是互质数。如 15与 16。</li>
<li>相邻的两个奇数是互质数。如 49与 51。</li>
<li>较大数是质数的两个数是互质数。如97与88。</li>
<li>两个数都是合数（二数差又较大），较小数所有的质因数，都不是较大数的约数，这两个数是互质数。<br>如357与715，357=3×7×17，而3、7和17都不是715的约数，这两个数为互质数。</li>
<li>两个数都是合数（二数差较小），这两个数的差的所有质因数都不是较小数的约数，这两个数是互质数。如85和78。85－78=7，7不是78的约数，这两个数是互质数。</li>
<li>两个数都是合数，较大数除以较小数的余数（不为“0”且大于“ 1”）的所有质因数，都不是较小数的约数，这两个数是互质数。如 462与 221<h4 id="17-左移，右移，无符号右移"><a href="#17-左移，右移，无符号右移" class="headerlink" title="17 左移，右移，无符号右移"></a>17 左移，右移，无符号右移</h4>左移永远补0，所以无所谓左右。<br>需要注意的是，以补码保存的负数，在进行有符号移位操作后，仍能正确表示移位操作之后的负数。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java小贴士]]></title>
      <url>/2018/01/08/java-tips/</url>
      <content type="html"><![CDATA[<h4 id="1-值传递与引用传递"><a href="#1-值传递与引用传递" class="headerlink" title="1 值传递与引用传递"></a>1 值传递与引用传递</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">String str = &quot;hello&quot;</span><br><span class="line">//第一个例子：基本类型</span><br><span class="line">void foo(int value) &#123;</span><br><span class="line">    value = 100;</span><br><span class="line">&#125;</span><br><span class="line">foo(num); // num 没有被改变</span><br><span class="line"></span><br><span class="line">//第二个例子：引用类型</span><br><span class="line">void foo(String text) &#123;</span><br><span class="line">    text = &quot;windows&quot;;</span><br><span class="line">&#125;</span><br><span class="line">foo(str);</span><br><span class="line">// str 也没有被改变，这个过程其实是先分配一块内存并创建一个新的引用text，再将text指向了str的值hello，text = &quot;windows&quot;这个操作又将text指向了值为windows的对象，因此str没有改变。第三个第四个例子也可以这样理解。</span><br><span class="line"></span><br><span class="line">//第三个例子：提供了改变自身方法的引用类型</span><br><span class="line">StringBuilder sb = new StringBuilder(&quot;iphone&quot;);</span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder.append(&quot;4&quot;);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。</span><br><span class="line"></span><br><span class="line">//第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</span><br><span class="line">StringBuilder sb = new StringBuilder(&quot;iphone&quot;);</span><br><span class="line">void foo(StringBuilder builder) &#123;</span><br><span class="line">    builder = new StringBuilder(&quot;ipad&quot;);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-变量的存储位置"><a href="#2-变量的存储位置" class="headerlink" title="2 变量的存储位置"></a>2 变量的存储位置</h4><h4 id="3-default"><a href="#3-default" class="headerlink" title="3 default"></a>3 default</h4><p>java8中，新增一个关键字default，它允许接口中的方法拥有方法体,实现该接口的类bu可以不实现该方法。这个关键字在集合框架中使用过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Default &#123;</span><br><span class="line">    default public void method()&#123;</span><br><span class="line">        System.out.println(&quot;method in interface&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line">    default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (T t : this) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    default Spliterator&lt;T&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliteratorUnknownSize(iterator(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-transient"><a href="#4-transient" class="headerlink" title="4 transient"></a>4 transient</h4><p>被transient修饰的变量不会被序列化</p>
<h4 id="5-volatile"><a href="#5-volatile" class="headerlink" title="5 volatile"></a>5 volatile</h4><p>cas技术的应用，在ConCurrentHashMap中的使用</p>
<h4 id="6-锁机制"><a href="#6-锁机制" class="headerlink" title="6 锁机制"></a>6 锁机制</h4><p>synchronized与lock</p>
<h4 id="7-线程间通信"><a href="#7-线程间通信" class="headerlink" title="7 线程间通信"></a>7 线程间通信</h4><p>轮询<br>join<br>countdownlatch<br>CyclicBarrier<br>返回结果 futuretask</p>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p>如果在一个线程计算过程中不允许有更大的本地方法栈，那么JVM就抛出StackOverflowError</p>
<p>如果本地方法栈可以动态地扩展，并且本地方法栈尝试过扩展了，但是没有足够的内容分配给它，再或者没有足够的内存为线程建立初始化本地方法栈，那么JVM抛出的就是OutOfMemoryError。</p>
<h4 id="9-handler机制"><a href="#9-handler机制" class="headerlink" title="9 handler机制"></a>9 handler机制</h4><p>A. Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分组成的。<br>B. Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。<br>C. Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。<br>D. 当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。         E. 当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。</p>
<h4 id="10-activity栈管理"><a href="#10-activity栈管理" class="headerlink" title="10 activity栈管理"></a>10 activity栈管理</h4><p>AMS activitymanagerservice 负责<br>activityrecord taskrecord activitystack都是ams抽象出来的概念<br><img src="/2018/01/08/java-tips/activity-stack.png" alt=""></p>
<h4 id="11-网络"><a href="#11-网络" class="headerlink" title="11 网络"></a>11 网络</h4><p>okhttp</p>
<h4 id="12-concurrenthashmap"><a href="#12-concurrenthashmap" class="headerlink" title="12 concurrenthashmap"></a>12 concurrenthashmap</h4><h4 id="13-IPC"><a href="#13-IPC" class="headerlink" title="13 IPC"></a>13 IPC</h4><h4 id="14-Future"><a href="#14-Future" class="headerlink" title="14 Future"></a>14 Future</h4><p>FutureTask 实现了Future和Runnable，FutureTask本质还是一个runnable，但是FutureTask中有Callable的引用，在线程执行run时，会调用call，所以对于FutureTask来说，真正的执行位置是callable</p>
<p>AsyncTask也是使用了Future，有两个线程池，一个用于真正执行，有核心线程数和最大线程数的限制，另一个维护一个队列用于给任务排序。AsyncTask是序列执行任务的。一个应用中所有的AsyncTask共享同一个线程池。</p>
<h4 id="15-访问修饰符"><a href="#15-访问修饰符" class="headerlink" title="15 访问修饰符"></a>15 访问修饰符</h4><p>类访问修饰符有default和public两种，public是任何其他类都可以访问，default是只有包内可以访问，包内指同一级目录<br>方法和成员变量访问修饰符有public、protected、default、private四种：其中public是任何类都能访问到，protected是子类可以访问，default是包内可以访问，private是是有类内部可以访问<br>需要特殊注意的是内部类<br>内部类不管是普通内部类还是静态内部类都可以访问外部类的所有变量</p>
<h4 id="16-类型转换"><a href="#16-类型转换" class="headerlink" title="16 类型转换"></a>16 类型转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short i = 1;</span><br><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure>
<p>上面代码有问题么？答案是有，需要强制类型转换</p>
<h4 id="17-amp-amp-amp"><a href="#17-amp-amp-amp" class="headerlink" title="17 &amp; &amp;&amp;"></a>17 &amp; &amp;&amp;</h4><p>Java中&amp;&amp;和&amp;都是表示与的逻辑运算符，都表示逻辑运输符and，当两边的表达式都为true的时候，整个运算结果才为true，否则为false。<br>&amp;&amp;的短路功能，当第一个表达式的值为false的时候，则不再计算第二个表达式；&amp;则两个表达式都执行。<br>&amp;可以用作位运算符，当&amp;两边的表达式不是Boolean类型的时候，&amp;表示按位操作。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java中boolean类型的大小]]></title>
      <url>/2018/01/08/boolean-size-in-java/</url>
      <content type="html"><![CDATA[<p>在Java中，int，float，double等基本类型所占字节大小都有明确说明，唯独boolean类型没有，那么boolean类型的大小究竟是多少呢？</p>
<h2 id="Java-SE-Specification-java-8"><a href="#Java-SE-Specification-java-8" class="headerlink" title="Java SE Specification(java 8)"></a>Java SE Specification(java 8)</h2><p>先看java官方规范中怎么说，<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.2" target="_blank" rel="noopener">规范网址</a>，下面是摘抄：   </p>
<h3 id="The-boolean-Type"><a href="#The-boolean-Type" class="headerlink" title="The boolean Type"></a>The boolean Type</h3><p>Although the Java Virtual Machine defines a boolean type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on boolean values. Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine int data type.</p>
<a id="more"></a>
<p>The Java Virtual Machine does directly support boolean arrays. Its newarray instruction (§newarray) enables creation of boolean arrays. Arrays of type boolean are accessed and modified using the byte array instructions baload and bastore (§baload, §bastore).</p>
<p>In Oracle’s Java Virtual Machine implementation, boolean arrays in the Java programming language are encoded as Java Virtual Machine byte arrays, using 8 bits per boolean element.</p>
<p>The Java Virtual Machine encodes boolean array components using 1 to represent true and 0 to represent false. Where Java programming language boolean values are mapped by compilers to values of Java Virtual Machine type int, the compilers must use the same encoding.<br>尽管java定义了boolean类型，但并没有提供更多的支持，也没有任何一种jvm有专用于boolean的虚拟机指令，事实上，java程序中的boolean都被编译成int类型，也就是说，单个的boolean类型在编译后占4个字节。<br>jvm并不直接支持boolean类型的数组，boolean类型的数组其实是byte类型的数组，也就是说，boolean类型的数组编译后每个boolean元素是一个byte，也就是1个字节。<br>boolen数组中使用1表示true，0表示false，需要注意的是，虽然在数组中使用byte表示boolena，但是一旦将其取出，那么走出数组的boolean必须转换成int类型，这在boolena数组的<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.baload" target="_blank" rel="noopener">baload</a>, <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.bastore" target="_blank" rel="noopener">bastore</a>中有所体现。  </p>
<p>####　操作码baload<br>The arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index must be of type int. Both arrayref and index are popped from the operand stack. The byte value in the component of the array at index is retrieved, sign-extended to an int value, and pushed onto the top of the operand stack.　　<br>将数组的某一byte元素取出转为int类型并push到栈上</p>
<h4 id="操作码bastore"><a href="#操作码bastore" class="headerlink" title="操作码bastore"></a>操作码bastore</h4><p>The arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index and the value must both be of type int. The arrayref, index, and value are popped from the operand stack. The int value is truncated to a byte and stored as the component of the array indexed by index.<br>将int类型数据截断为byte类型，并存储在在数组内</p>
<h4 id="为什么这么设计"><a href="#为什么这么设计" class="headerlink" title="为什么这么设计"></a>为什么这么设计</h4><p>the JVM uses a 32-bit stack cell, used to hold local variables, method arguments, and expression values. Primitives that are smaller than 1 cell are padded out, primitives larger than 32 bits (long and double) take 2 cells. This technique <strong>minimizes the number of opcodes</strong>, but does have some peculiar side-effects (such as the need to mask bytes).</p>
<p>Primitives stored in arrays may use less than 32 bits, and there are different opcodes to load and store primitive values from an array. Boolean and byte values both use the baload and bastore opcodes, which implies that boolean arrays take 1 byte per element.</p>
<p>opcodes就是操作码，也叫机内码，指令序列等，用来告诉CPU需要执行哪一条指令，上面的bastore就是操作码</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[unity中使用shader增强视频]]></title>
      <url>/2018/01/03/renderer-texture-with-shader/</url>
      <content type="html"><![CDATA[<h2 id="使用shader对视频texture做特效处理"><a href="#使用shader对视频texture做特效处理" class="headerlink" title="使用shader对视频texture做特效处理"></a>使用shader对视频texture做特效处理</h2><p>该功能主要在片元着色器中实现，考虑到是移动设备，因此要兼顾考虑效果和性能。<br>在shader中的实现，这里只展示像素增强算法，关于shader的结构请看其他</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="MainTex"><a href="#MainTex" class="headerlink" title="_MainTex"></a>_MainTex</h4><p>当前渲染的texture</p>
<h4 id="MainTex-TexelSize"><a href="#MainTex-TexelSize" class="headerlink" title="_MainTex_TexelSize"></a>_MainTex_TexelSize</h4><p>_MainTex_TexelSize这个变量的从字面意思是主贴图 _MainTex 的像素尺寸大小，是一个四元数，是 unity 内置的变量，它的值为 Vector4(1 / width, 1 / height, width, height)</p>
<a id="more"></a>
<h4 id="ColorBoost"><a href="#ColorBoost" class="headerlink" title="_ColorBoost"></a>_ColorBoost</h4><p>自定义关于亮度、对比度、饱和度、色弱调整的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;_ColorBoost&quot;,(_brightness, cont, _saturate, _daltonize * 10f));</span><br></pre></td></tr></table></figure></p>
<h4 id="Sharpen"><a href="#Sharpen" class="headerlink" title="_Sharpen"></a>_Sharpen</h4><p>自定义关于锐化的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;_Sharpen&quot;,(sharpen, _sharpenDepthThreshold, _sharpenClamp, _sharpenRelaxation)</span><br></pre></td></tr></table></figure></p>
<h2 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D _MainTex;</span><br><span class="line">uniform float4 _MainTex_TexelSize;</span><br><span class="line">uniform float4 _ColorBoost;</span><br><span class="line">uniform float4 _Sharpen;</span><br><span class="line"></span><br><span class="line">float getLuma(float3 rgb) &#123;</span><br><span class="line">	const float3 lum = float3(0.299, 0.587, 0.114);</span><br><span class="line">	return dot(rgb, lum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void beautifyPassFast(v2f i, inout half3 rgbM) &#123;</span><br><span class="line"></span><br><span class="line">   half2 xInc = half2(_MainTex_TexelSize.x, 0);</span><br><span class="line">   half2 yInc = half2(0, _MainTex_TexelSize.y);</span><br><span class="line"></span><br><span class="line">   half  lumaM = getLuma(rgbM);</span><br><span class="line"></span><br><span class="line">   half3 rgbN = tex2D(_MainTex, saturate(i.uv + yInc)).rgb;</span><br><span class="line">   half3 rgbS = tex2D(_MainTex, saturate(i.uv - yInc)).rgb;</span><br><span class="line">   half3 rgbW = tex2D(_MainTex, saturate(i.uv - xInc)).rgb;</span><br><span class="line">   half  lumaN = getLuma(rgbN);</span><br><span class="line">   half  lumaW = getLuma(rgbW);</span><br><span class="line">   half  lumaS = getLuma(rgbS);</span><br><span class="line">   half  maxLuma = max(lumaN,lumaS);</span><br><span class="line">         maxLuma = max(maxLuma, lumaW);</span><br><span class="line">   half  minLuma = min(lumaN,lumaS);</span><br><span class="line">        minLuma = min(minLuma, lumaW) - 0.000001;</span><br><span class="line">   half  lumaPower = 2 * lumaM - minLuma - maxLuma;</span><br><span class="line">   half  lumaAtten = saturate(_Sharpen.w / (maxLuma - minLuma));</span><br><span class="line">         rgbM *= 1.0 + clamp(lumaPower * lumaAtten * _Sharpen.x, -_Sharpen.z, _Sharpen.z);</span><br><span class="line"></span><br><span class="line">   // 3. Vibrance</span><br><span class="line">   half3 maxComponent = max(rgbM.r, max(rgbM.g, rgbM.b));</span><br><span class="line">   half3 minComponent = min(rgbM.r, min(rgbM.g, rgbM.b));</span><br><span class="line">   half  sat = saturate(maxComponent - minComponent);</span><br><span class="line">         rgbM *= 1.0 + _ColorBoost.z * (1.0 - sat) * (rgbM - getLuma(rgbM));</span><br><span class="line"></span><br><span class="line">   // 5. Final contrast + brightness</span><br><span class="line">         rgbM = (rgbM - halves) * _ColorBoost.y + halves;</span><br><span class="line">         rgbM *= _ColorBoost.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> unity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[adb_tips]]></title>
      <url>/2018/01/02/adb-tips/</url>
      <content type="html"><![CDATA[<h2 id="修改系统文件"><a href="#修改系统文件" class="headerlink" title="修改系统文件"></a>修改系统文件</h2><p>以修改hosts为例<br>首先手机需要root</p>
<ol>
<li>adb root</li>
<li>adb remount</li>
<li>adb push 将修改过的hosts文件push进去</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DFT 和 DTFT]]></title>
      <url>/2017/12/31/DFT-and-DTFT/</url>
      <content type="html"><![CDATA[<h2 id="几种傅立叶变换"><a href="#几种傅立叶变换" class="headerlink" title="几种傅立叶变换"></a>几种傅立叶变换</h2><ol>
<li>连续时间周期信号:处理时间连续并且具有周期性的信号，其频域上离散，非周期。</li>
<li>连续时间非周期信号:处理时间连续但是不具有周期性的信号，其频域上连续，非周期。</li>
<li>离散时间非周期信号:处理时间离散，不具有周期性的信号，其频域上连续，有周期性。</li>
<li>离散时间周期信号:处理时间离散，具有周期性的信号，对应离散时间傅里叶变换其频域上离散，有周期性。</li>
</ol>
<a id="more"></a>
<h3 id="关于时域是否离散与频域周期性的关系"><a href="#关于时域是否离散与频域周期性的关系" class="headerlink" title="关于时域是否离散与频域周期性的关系"></a>关于时域是否离散与频域周期性的关系</h3><p>为什么时域离散，频域周期，时域连续，频域非周期呢？<br>如果你的频域是离散的，那么就有一个最小的分辨频率，这个自然对应了时域的最大波长，即时域的周期性。<br>反之同理。如果你的时域是离散的，那就有一个最小的波长。这个波长就对应频域的最高频率。所有高于这个频率的信息，都要被alias、反褶到低频去。即频域的周期性。</p>
<h2 id="离散时间傅立叶变换"><a href="#离散时间傅立叶变换" class="headerlink" title="离散时间傅立叶变换"></a>离散时间傅立叶变换</h2><p>离散时间傅里叶变换（英语：Discrete-time Fourier Transform，简称：DTFT）是傅里叶变换的一种。它将以离散时间nT（其中，T为采样间隔）作为变量的函数（离散时间信号）变换到连续的频域，即产生这个离散时间信号的连续频谱，值得注意的是这一频谱是周期的，周期为$2\pi$。</p>
<h2 id="离散傅立叶变换"><a href="#离散傅立叶变换" class="headerlink" title="离散傅立叶变换"></a>离散傅立叶变换</h2><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>从理论上来说，上述四种变换基本囊括我们能遇到的信号种类。但是在数字信号处理里面，我们接触的都是离散时间的信号，所以前两种连续时间的傅里叶变换用不到。<br>剩下的两种变换中，DFT与离散时间周期信号的变换非常类似，有何原因？<br>在数字信号处理中，信号是要交给计算机进行处理的，这其中涉及到对数字信号的进行处理交给计算机以及计算机的算法设计，对于一般的离散时间信号而言，从数学上直接用DTFT会非常利于分析信号的频域特征，但问题是目前的机器不能表达一个无限长的序列，也不能表达连续的频域特征。因此我们才需要DFT，也就是说DTFT是给人用的，而DFT是给机器用的。DFT相较于DTFT，主要有两处不同，一点是变无限为有限，是因为机器无法表示无限长的序列，只能处理有限长序列。另一点是<strong>频域</strong>采样，关于采样，是理解DFT的重点。</p>
<h3 id="频域采样"><a href="#频域采样" class="headerlink" title="频域采样"></a>频域采样</h3><p>我们前面提到离散非周期序列的傅里叶变换(DTFT)在频域上是连续的，这连续的频域特征机器是无法表达的，因此我们需要对它进行采样。又由于频域上具有周期性，只需要对2pi长度的区间采样即可。那么应该采多少个点呢？类似于Nyquist采样定理的做法，我们得出采样的点数M≥N即可(N表示该序列的长度)，为了方便起见只需取M=N。由此，DFT的两个引入动机就清楚了:它是对无限长序列截断成有限长序列，进行DTFT以后再在频域采样。那么为何DFT的形式和离散时间周期信号的傅里叶变换形式类似呢？注意到，有限长序列经过周期延拓即可变为周期信号，因此他们之间的相似性也不言而喻了。不过需要注意的是DFT对有限长序列均可以用，但离散时间周期信号的傅里叶变换只能处理周期信号，这是本质的不同。</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[博客建立]]></title>
      <url>/2017/12/27/build-blog-on-github/</url>
      <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><h4 id="打开mathjax"><a href="#打开mathjax" class="headerlink" title="打开mathjax"></a>打开mathjax</h4><h5 id="如果使用了主题，在主题的-config-yml中打开mathjax"><a href="#如果使用了主题，在主题的-config-yml中打开mathjax" class="headerlink" title="如果使用了主题，在主题的_config.yml中打开mathjax"></a>如果使用了主题，在主题的_config.yml中打开mathjax</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="在文档Front-matter中启用mathjax"><a href="#在文档Front-matter中启用mathjax" class="headerlink" title="在文档Front-matter中启用mathjax"></a>在文档Front-matter中启用mathjax</h5><p>这是为了渲染快，因为没有公式的文档不需要渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 卷积与傅立叶</span><br><span class="line">date: 2017-12-26 21:46:15</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h4 id="latex与markdown冲突："><a href="#latex与markdown冲突：" class="headerlink" title="latex与markdown冲突："></a>latex与markdown冲突：</h4><p>参照<a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="noopener">latex与markdown语法冲突解决</a><br>比如latex中的下标符号_，markdown会先识别为斜体，这样公式就不能渲染了，以及<code>\</code>转义会影响latex换行的识别，对于这种情况，两种方法解决：</p>
<ol>
<li>将公式中的<em>替换为转义\</em>即可，但是这样做，虽然生成的网页正常，但是markdown preview的时候会出错；</li>
<li>修改renderer引擎的转义定义:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 取消`\`转义（注意：这里的修改与上面链接中修改有区别）:</span><br><span class="line">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">// 取消`_`转义：</span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Atom可以实时预览公式"><a href="#Atom可以实时预览公式" class="headerlink" title="Atom可以实时预览公式"></a>Atom可以实时预览公式</h4><p>安装 latex 预览package<br>ctlr + shift + x</p>
<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><p><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">GitHub Markdown 语法</a></p>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><ul>
<li>文章<ul>
<li>hexo new android开发</li>
</ul>
</li>
<li>草稿<ul>
<li>创建草稿：<code>hexo new draft 制作抖音视频</code></li>
<li>发布草稿：<code>hexo publish 制作抖音视频</code></li>
</ul>
</li>
<li>同步到github<ul>
<li><code>hexo d</code></li>
</ul>
</li>
<li>如果丢失github权限<ul>
<li><code>ssh-add github_rsa</code></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[卷积与傅立叶]]></title>
      <url>/2017/12/26/convolution-introduction/</url>
      <content type="html"><![CDATA[<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>函数定义：设:$f(x)$, $g(x)$ 是R1上的两个可积函数，作积分<br>$${\int_{-\infty}^{\infty}}f(\tau)\ast\,g(x-\tau)\,\mathrm{d}\tau$$</p>
<p>可以证明，关于几乎所有的实数$x$，上述积分是存在的。这样，随着$x$的不同取值，这个积分就定义了一个新函数$h(x)$，称为函数$f$与$g$的卷积，记为$h(x)=(f\ast\,g)(x)$。<br>容易验证，$(f\ast\,g)(x)=\,(g\ast\,f)(x)$，并且 $(f\ast\,g)(x)$ 仍为可积函数。这就是说，把卷积代替乘法，$L1(R1)$空间是一个代数，甚至是巴拿赫代数。<br>离散表达：<br>$$y(n) = \sum_{i=-\infty}^{\infty}x(i)h(n-i) = x(n)\ast\,h(t)$$</p>
<a id="more"></a>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>首先要明确，卷积只在线性时不变系统起作用，所以我们接下来的讨论均在此条件下进行。线性时不变系统：</p>
<ol>
<li>线性系统：系统的输入和输出具有线性关系</li>
<li>时不变系统：系统的参数不随时间而变化，即不管输入信号作用的时间先后，输出信号响应的形状均相同，仅是从出现的时间不同，与系统状态无关。</li>
</ol>
<p>物理意义：对于输入信号$f(τ)$,响应函数$g(τ)$，在t时刻的输出信号即为两者的卷积：<br>  $${\int_{-\infty}^{\infty}}f(\tau)g(t-\tau)\,\mathrm{d}\tau$$<br>该式与上面公式区别仅在于改变了变量符号为时间t，主要为了便于理解。</p>
<h4 id="离散情况"><a href="#离散情况" class="headerlink" title="离散情况"></a>离散情况</h4><p>那么，为什么将两个时间信号这样积分，或者说求卷积就是t时刻的输出信号呢？举例来说：<br>第一年，小明存入100元钱，年利率是5%，按复利计算（即将每一年所获利息加入本金，以计算下一年的利息），那么在五年之后他能拿到的钱数是$100(1+5\%)^5$，如此类推，第二年存入100，四年后能拿到$100(1+5\%)^4$，连续存五年，列表如下：</p>
<table>
<thead>
<tr>
<th>本金</th>
<th>第一年</th>
<th>第二年</th>
<th>第三年</th>
<th>第四年</th>
<th>第五年</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\small100$</td>
<td>$\small100(1+5\%)^1$</td>
<td>$\small100(1+5\%)^2$</td>
<td>$\small100(1+5\%)^3$</td>
<td>$\small100(1+5\%)^4$</td>
<td>$\small100(1+5\%)^5$</td>
</tr>
<tr>
<td></td>
<td>$\small100$</td>
<td>$\small100(1+5\%)^1$</td>
<td>$\small100(1+5\%)^2$</td>
<td>$\small100(1+5\%)^3$</td>
<td>$100(1+5\%)^4$</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\small100$</td>
<td>$\small100(1+5\%)^1$</td>
<td>$\small100(1+5\%)^2$</td>
<td>$\small100(1+5\%)^3$</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>$\small100$</td>
<td>$\small100(1+5\%)^1$</td>
<td>$\small100(1+5\%)^2$</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>$\small100$</td>
<td>$\small100(1+5\%)^1$</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>$\small100$</td>
</tr>
</tbody>
</table>
<p>最终，在第五年小明拿到钱：<br>$$\small100(1+5\%)^1 + 100(1+5\%)^2 + 100(1+5\%)^3 + 100(1+5\%)^4 + 100(1+5\%)^5$$<br>对应到上面的离散公式：<br>$$\sum_{i=0}^{5}x(i)h(5-i)$$<br>其中，$x(i) = 100$,$h(5-i) = {(1+5)}^{5-i}$</p>
<p>这里计算结果即为在第五年拿到的总钱数，也是小明存钱函数（输入信号）$x(i) = 100$与复利计算函数（响应函数）$h(i) = {(1+5)}^{i}$ 的卷积结果。</p>
<h4 id="连续情况"><a href="#连续情况" class="headerlink" title="连续情况"></a>连续情况</h4><p>初次看到卷积积分公式时，对于将两个关于$x$的函数在$τ$上积分不理解，这也直接导致对卷积数学意义和物理意义的理解偏差。<br>举例，假如有响应函数$h(t)$,那么对于输入信号$f(t)$，在时刻T，将两者反褶相乘积分，画图举例 （）</p>
<p>其实，$τ$也是时间，只是我们在积分公式中，给定了时刻$t$。而给定t意味着输入信号与响应函数的相对位置确定，这就然后让$τ$在 $(-\infty,t]$ 上积分，我们知道积分可以看作无数个值的累加，那么从左往右的累加过程，就是 $(-\infty,t]$ 中所有时刻输入信号在响应函数作用下对t时刻输出信号的累加，这就是卷积。那么为什么会出现$τ$、$t-τ$、$τ+(t-τ)$刚好是t的看似巧妙的情况呢？这是因为，如果当前时间为t，那么在0时刻的输出信号在t时刻的响应函数就是$h(t-0)$,同样的，在τ时刻的输出信号在t时刻的响应函数就是$h(t-τ)$,没有什么数学上的巧合与美丽，只有实际的应用与计算。其实写到这里，已经觉得是在说废话了。</p>
<p>假设在一个线性时不变系统中，输入信号$x(t)$, 冲击信号$h(t)$,那么输出信号即为$x(t)\ast\,h(t)$，其步骤为：</p>
<ol>
<li>变换变量$t$为$τ$</li>
<li>冲击信号反褶 $h(-τ)$</li>
<li>时移 $h(t-τ)$</li>
<li>相乘 $x(τ)h(t-τ)$</li>
<li>积分</li>
</ol>
<p>这是卷积计算的步骤，很好理解，很好计算，这里权作记录。</p>
<h2 id="矩阵卷积"><a href="#矩阵卷积" class="headerlink" title="矩阵卷积"></a>矩阵卷积</h2><p>矩阵的卷积与一维离散卷积类似，只是反转平移的过程变为将响应矩阵旋转180度，这样刚好形成$f(τ)h(t-τ)$。<br>比如，现有矩阵A，B：<br>$${A} = \left(\begin{matrix} 1 &amp; 2 \ 3 &amp; 4 \end{matrix} \right)\,\,\,\,\,\,{B} = \left(\begin{matrix} 5 &amp; 6 \ 7 &amp; 8 \end{matrix} \right)$$<br>变化矩阵B，三种方法：</p>
<ol>
<li>直接旋转180</li>
<li>沿对角线分别反转</li>
<li>同时反转行和列<br>三种方法只是利用了矩阵基本性质，不赘述。<br>假设B翻转后得矩阵C：<br>$${C} = \left(\begin{matrix} 8 &amp; 7 \ 6 &amp; 5 \end{matrix} \right)$$<br>那么，AB卷积的过程就是是将AC矩阵对应位置的元素相乘，并将结果累加，在图像处理中经常用到这种方法。AB卷积结果为：<br>$$5\cdot8+6\cdot7+7\cdot6+8\cdot5 = 164$$<br>在深度学习中，矩阵卷积应用广泛，具体可参考 – <a href="https://mlnotebook.github.io/post/CNN1/" target="_blank" rel="noopener">矩阵卷积</a></li>
</ol>
<h2 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h2><p>卷积定理是傅立叶变换满足的一个重要性质。卷积定理指出，函数卷积的傅立叶变换是函数傅立叶变换的乘积。具体分为时域卷积定理和频域卷积定理，时域卷积定理即时域内的卷积对应频域内的乘积；频域卷积定理即频域内的卷积对应时域内的乘积，两者具有对偶关系。<br>若<br>  $$f_1(t)\leftrightarrow\,F_1(\omega)$$<br>  $$f_2(t)\leftrightarrow\,F_2(\omega)$$<br>$F$ 表示傅里叶变换。<br>则时域卷积定理：<br>$$F(f_1(t)\ast\,f_2(t)) = F_1(\omega)F_2(\omega)$$<br>频域卷积定理：<br>$$F[f_1(t)f_2(t)] = \frac{1}{2\pi}F_1(\omega)F_2(\omega)$$<br>卷积定理揭示了时间域与频率域的对应关系。</p>
<h2 id="去卷积"><a href="#去卷积" class="headerlink" title="去卷积"></a>去卷积</h2><h2 id="傅里叶"><a href="#傅里叶" class="headerlink" title="傅里叶"></a>傅里叶</h2><h3 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h3><p>对于任意周期函数，都可以表示成一系列三角函数的和。<br>那么为什么可以做这种变换呢？这可以几何或者矩阵做类比，在三维空间几何中，我们可以用$(1,0,0),(0,1,0),(0,0,1)$三个空间向量的线性组合来表示这个空间中的所有向量，这三个向量两两正交，称为三维空间向量的基。同理从矩阵的角度看，单元矩阵的每行或者每列也是两两正交，那么每一行都可以看作这个矩阵空间的基，使用这些基向量的线性叠加可以表示任意一个矩阵,如下：<br>$$\left(\begin{matrix} 1 &amp; 0 \ 0 &amp; 1 \end{matrix} \right) = \left(\begin{matrix} 1 &amp; 0 \ 0 &amp; 0 \end{matrix} \right) + \left(\begin{matrix} 0 &amp; 0 \ 0 &amp; 1 \end{matrix} \right)$$<br>而对于函数，数学家也发现同样的现象，使用无数个相互正交的函数可以近似的表示任意一个周期函数，问题是这无数个两两正交的函数怎么找呢，三角函数刚好完美支持，而傅里叶级数选取的这个基函数就是三角函数,事实上，傅里叶级数可以有多种变化方式，三角函数只是其中一种。三角函数的正交性：<br><img src="/2017/12/26/convolution-introduction/trigonometric_orthogonal.png" alt=""></p>
<p>下面我们看傅里叶级数的表达，对于任意周期为T的函数，只要满足狄利赫里条件，则函数可以表达为：<br>$$f(x) = \sum_{k=1}^\infty(a_k\,sin(kx) + b_k\,cos(kx)) + \frac{a_0}{2}$$</p>
<p>其中：<br>$$a<em>0 = \frac{2}{T}\int</em>{-\frac{T}{2}}^{\frac{T}{2}}f(x)dx$$</p>
<p>$$a<em>k = \frac{2}{T}\int</em>{-\frac{T}{2}}^{\frac{T}{2}}f(x)sin(kx)dx$$</p>
<p>$$b<em>k = \frac{2}{T}\int</em>{-\frac{T}{2}}^{\frac{T}{2}}f(x)cos(kx)dx$$</p>
<p>关于$a_0$:将傅里叶级数两边在一个周期上同时积分，$sin$、$cos$的积分均为0，即可得$a_0$</p>
<p>关于$a_n$:等式两边同时乘以$sin(nx)$再进行积分，根据三角函数正交定理，只有同频率的元素在周期上的积分才不为零：</p>
<p>$$\int<em>{-\frac{T}{2}}^{\frac{T}{2}}f(x)sin(kx)=\int</em>{\frac{2}{T}}^2{a_n}\,sin(kx)^2dx$$</p>
<p>$$\int_{-\,\frac{T}{2}}^{\frac{T}{2}}f(x)sin(kx) = a_n\frac{T}{2}$$</p>
<p>即得$a_n$<br>同理得$b_n$<br>傅里叶展开后，原函数与展开式，以及展开式的频谱、相位关系图，现在有了各频率下的幅值和相位，原函数的频域信息就都体现出来了：</p>
<p><img src="/2017/12/26/convolution-introduction/Fourier_series.jpg" alt=""></p>
<p>可以看出，将展开级数沿z轴放置，从图右边看，就是频谱，从上面看就是相位，需要注意的是，由于傅里叶级数中只使用了正弦和余弦函数，因此相位永远是0或者$\pi$，另外，级数展开后得频率非连续，是一个个独立的幅值，对应的频率是原函数频率的整数倍，这样的频谱是离散的。<br>下面的动图也有助于理解：</p>
<p><img src="/2017/12/26/convolution-introduction/Fourier_series_and_transform.gif" alt=""></p>
<h4 id="傅里叶级数的复数形式"><a href="#傅里叶级数的复数形式" class="headerlink" title="傅里叶级数的复数形式"></a>傅里叶级数的复数形式</h4><p>复数形式可以由欧拉公式变化而来，只是简单的代入，不再赘述。<br>欧拉公式：<br>$$e^{it} = cos(t) + isin(t)$$<br>傅里叶复数：<br>$$f(x) = \sum_{-\infty}^{\infty}a_ke^{jk\omega\,t}$$<br>其中：<br>$$a<em>k = \frac{1}{T}\int</em>{-\frac{T}{2}}^{\frac{T}{2}}x(t)e^{-jk\omega\,t}dt$$</p>
<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>傅里叶级数有其局限性，只能用于周期函数，那么对于非周期函数怎么办呢？<br>对于非周期函数，我们可以这样思考，非周期看作周期无穷大，那么对应的$\omega$则无穷小，<br>傅里叶级数：<br>$$f(t) = \frac{1}{2\pi}\int<em>{-\infty}^{\infty}F(\omega)e^{i\omega\,t}d\omega$$<br>其中：<br>$$F(\omega) = \int</em>{-\infty}^{\infty}f(t)e^{-i\omega\,t}dt$$<br>注意,第二个公式才叫做 $f(x)$ 的傅里叶变换。更重要的是，这个式子里的角频率 $\omega$ 就不是某一个频点了，它可以取频谱轴上的任意值，它是连续的！非周期的信号的频谱遍布整个频率轴！<br>对某一点特定角频率 $\omega$ 取值，$F(\omega)$ 就是角频率 $\omega$ 在信号 $f(t)$ 中的”份量”！</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图像处理基础]]></title>
      <url>/2017/12/26/image_processing/</url>
      <content type="html"><![CDATA[<h2 id="锐化"><a href="#锐化" class="headerlink" title="锐化"></a>锐化</h2><p>锐化(image sharpening)是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰。从频域的角度理解是增强图像的高频分量。目前主流软件锐化方式主要有全局锐化和局部锐化，本文主要涉及全局锐化，局部今后另说。</p>
<h3 id="全局锐化"><a href="#全局锐化" class="headerlink" title="全局锐化"></a>全局锐化</h3><p>原理：理论上来说，全局锐化是滤波算法的逆应用<br>滤波结果 = 过滤掉图像细节的输入图像<br>图像细节 = 输入图像 - 滤波结果<br>锐化结果 = 输入图像 + 锐化系数 X 图像细节<br>所以说有多少种滤波算法，就有多少中锐化算法。</p>
<p>锐化的核心目的是强化图像轮廓，比如人体的眼眶，帽子的帽沿，将非轮廓的地方锐化，对于增强整体的形态并无太大帮助。而全局锐化是将整个图像进行无差别增强，这也是全局锐化的不足之处。</p>
<a id="more"></a>
<p><img src="/2017/12/26/image_processing/1.jpg" alt=""></p>
<p>实际应用中，简单的全局锐化可以使用Unsharp Mask(USM)算法。<br>   $$y(n,m) = x(n,m) + \lambda\,z(n,m)$$<br>其中，$x(n,m)$ 为输入图像，$y(n,m)$ 为输出图像，而$z(n,m)$ 为校正信号,在锐化中就是图像细节信号，一般是通过对$x$进行滤波获取。$λ$是用于控制增强效果的的一个缩放因子。<br>在传统的USM算法中，$z(n,m)$ 一般可以通过下式获取：<br>  $$z(n,m)=4x(n,m)-x(n-1,m) -x(n +1,m)-x(n, m-1) -x(n,m+1)$$<br>图像滤波的过程就是卷积核对图像上所有像素点及其临近像素进行对应相乘叠加的结果。如图：<br><img src="/2017/12/26/image_processing/matrix_convolution.gif" alt=""><br>注意：这个对应元素相乘累加的过程，就是两个矩阵离散卷积的过程。<br>根据卷积定理：函数卷积的傅立叶变换是函数傅立叶变换的乘积，那么我们只要使矩阵B的频谱中不包含频率 $\omega$，就能保证卷积结果中也不包含频率 $\omega$，这就是滤波的由来。</p>
<p>上式对应的卷积核为</p>
<h3 id="局部锐化"><a href="#局部锐化" class="headerlink" title="局部锐化"></a>局部锐化</h3><p>局部锐化可以弥补全局锐化的不足，将锐化的重心放在图像的边缘处（比如头发丝，脸颊），突出形体和轮廓。<br>这就需要做出边缘检测，目前流行算法<br><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/log.htm" target="_blank" rel="noopener">Laplician of Gaussian(LoG)</a>，据说PS中用于Edge Dectection的高反差保留以及照片边插画的核心算法都是这个。</p>
<h3 id="滤波算法"><a href="#滤波算法" class="headerlink" title="滤波算法"></a>滤波算法</h3><p>根据卷积定理：函数卷积的傅立叶变换等于两个函数傅立叶变换的乘积，那么如果用于卷积的卷积核损失了高频或者低频的部分，卷积后的图像频谱相应的也会损失对应的频率，这就是滤波器的工作原理。</p>
<h4 id="线性滤波器（均值滤波）"><a href="#线性滤波器（均值滤波）" class="headerlink" title="线性滤波器（均值滤波）"></a>线性滤波器（均值滤波）</h4><p>线性滤波器的原始数据与滤波结果是一种算术运算，即用加减乘除等运算实现，如均值滤波器（模板内像素灰度值的平均值）、高斯滤波器（高斯加权平均值）等。由于线性滤波器是算术运算，有固定的模板，因此滤波器的转移函数是可以确定并且是唯一的（转移函数即模板的傅里叶变换）。<br>卷积可以说是图像处理最基本的操作，但却非常有用。这个操作有两个非常关键的特点：它们是线性的，而且具有平移不变性shift-invariant。平移不变性指我们在图像的每个位置都执行相同的操作。线性指这个操作是线性的，也就是我们用每个像素的邻域的线性组合来代替这个像素。这两个属性使得这个操作非常简单，因为线性操作是最简单的，然后在所有地方都做同样的操作就更简单了。<br>2D卷积需要4个嵌套循环4-double loop，所以它并不快，除非我们使用很小的卷积核。这里一般使用3x3或者5x5。而且，对于滤波器，也有一定的规则要求：</p>
<ol>
<li>滤波器的大小应该是奇数，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。</li>
<li>滤波器矩阵所有的元素之和应该要等于1，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。</li>
<li>如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。</li>
<li>对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。<h5 id="平滑均值滤波器"><a href="#平滑均值滤波器" class="headerlink" title="平滑均值滤波器"></a>平滑均值滤波器</h5>$$\frac{1}{9}\left(\begin{matrix} 1 &amp; 1 &amp; 1\ 1 &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1\end{matrix} \right)$$<br>这是一个低通滤波器，其频谱的高频部分幅值很低甚至为零，也就是说会过滤掉高频部分，结果是将图像进行平滑处理。<h5 id="锐化均值滤波器"><a href="#锐化均值滤波器" class="headerlink" title="锐化均值滤波器"></a>锐化均值滤波器</h5>$$\left(\begin{matrix} -1 &amp; -1 &amp; -1\ -1 &amp; 8 &amp; -1 \ -1 &amp; -1 &amp; -1\end{matrix} \right)$$<br>这是一个高通滤波器，其频谱的低频部分幅值很低甚至为零，也就是说会过滤掉低频部分，结果是将图像进行锐化处理。<h5 id="高斯滤波器"><a href="#高斯滤波器" class="headerlink" title="高斯滤波器"></a>高斯滤波器</h5>高斯滤波器是低通滤波，滤波后图像被平滑的程度取决于标准差。它的输出是领域像素的加权平均，同时离中心越近的像素权重越高。因此，相对于均值滤波（mean filter）它的平滑效果更柔和，而且边缘保留的也更好。<br>高斯滤波简单说就是卷积核的概率分布服从高斯分布。自然界里高斯分布遍布各处，使用高斯分布有一定的理由。<br>3X3高斯卷积核：<br>$$\frac{1}{16}\left(\begin{matrix} 1 &amp; 2 &amp; 1\ 2 &amp; 4 &amp; 2 \ 1 &amp; 2 &amp; 1\end{matrix} \right)$$<br>5X5高斯卷积核:<br>$$\frac{1}{273}\left(\begin{matrix} 1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \ 4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \ 7 &amp; 26 &amp; 41 &amp; 26 &amp; 7 \ 4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \ 1 &amp; 4 &amp; 7 &amp; 4 &amp; 1\\end{matrix} \right)$$<h4 id="非线性滤波器"><a href="#非线性滤波器" class="headerlink" title="非线性滤波器"></a>非线性滤波器</h4>非线性滤波器的原始数据与滤波结果是一种逻辑关系，即用逻辑运算实现，如最大值滤波器、最小值滤波器、中值滤波器等，是通过比较一定邻域内的灰度值大小来实现的，没有固定的模板，因而也就没有特定的转移函数（因为没有模板作傅里叶变换），另外，膨胀和腐蚀也是通过最大值、最小值滤波器实现的。</li>
</ol>
<h2 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h2><h3 id="锐化与对比度的区别"><a href="#锐化与对比度的区别" class="headerlink" title="锐化与对比度的区别"></a>锐化与对比度的区别</h3><p>锐化可以理解为增加局部差异，增加对比度可以理解为拉开整体差异</p>
<h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><h2 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h2>]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> unity </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring-MVC-Hibernate-搭建后台服务]]></title>
      <url>/2017/12/26/Spring-MVC-Hibernate/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>Spring MVC基于传统Spring的MVC模式的开发框架。 MVC设计模式在Spring MVC中表现为 模型 - 视图 - 控制器，模型封装应用程序的数据和一般他们会组成的POJO(Plain Ordinary Java Object)简单的Java对象，视图(View)是负责呈现模型数据并且一般由它生成HTML输出，客户端浏览器来解析显示，控制器(Controller)负责处理用户的请求，并建立适当的模型，并把它传递给视图渲染。</p>
<a id="more"></a>
<p>在Spring MVC中，有一个很重要的类是DispatcherServlet，叫中央前端控制器，所有的请求都由该控制器接受并分发到到合适的处理器，处理器解析请求直接返回Response或者跳转jsp页面，这些过程都要通过中央前端处理器。如图1所示：</p>
<p><img src="/2017/12/26/Spring-MVC-Hibernate/1.png" alt="" title="Spring MVC"></p>
<p>接收HTTP请求后，DispatcherServlet 咨询 HandlerMapping 来调用相应的控制器。<br>该控制器接受请求并调用基于使用GET或POST方法相应的服务方法。服务方法将基于定义的业务逻辑设置模型数据，并返回视图名到DispatcherServlet.<br>DispatcherServlet将需要帮助的ViewResolver从拾取到该请求所定义的视图。<br>一旦视图被敲定，DispatcherServlet会传递模型数据是在浏览器上最终呈现的视图。</p>
<h3 id="Spring-MVC的基本使用"><a href="#Spring-MVC的基本使用" class="headerlink" title="Spring MVC的基本使用"></a>Spring MVC的基本使用</h3><p>在java web项目中，都有一个web.xml文件用于配置当前项目，在这里，我们可以通过简单的对比了解Spring MVC的作用在没有使用Spring MVC框架前， 单纯的使用servlet接受网络请求的过程是这样的 ：</p>
<p>配置web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">&lt;!-- 配置servlet--&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- servlet名称--&gt;</span><br><span class="line">    &lt;servlet-name&gt;Sorry&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 对应servlet要指向的HttpServlet类--&gt;</span><br><span class="line">    &lt;servlet-class&gt;moreservlets.SorryServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;!-- 映射servlet到url--&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;!--这里表示所有以/servlet/开头的请求都会由Sorry这个Servlet来处理--&gt;</span><br><span class="line">    &lt;servlet-name&gt; Sorry &lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="不使用SpringMVC时的网络请求"><a href="#不使用SpringMVC时的网络请求" class="headerlink" title="不使用SpringMVC时的网络请求"></a>不使用SpringMVC时的网络请求</h4><p>继承HttpServlet类，并复写doGet()，doPost()等方法来处理请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SorryServlet extends HttpServlet &#123;  </span><br><span class="line">  public void doGet(HttpServletRequest request,  HttpServletResponse response)  throws ServletException, IOException &#123;  </span><br><span class="line">    response.setContentType(&quot;text/html&quot;);  </span><br><span class="line">    PrintWriter out = response.getWriter();  </span><br><span class="line">    String title = &quot;Invoker Servlet Disabled.&quot;;  </span><br><span class="line">    out.println(ServletUtilities.headWithTitle(title) +   &quot;&lt;BODY BGCOLOR=/&quot;#FDF5E6/&quot;&gt;/n&quot; +   &quot;&lt;H2&gt;&quot; + title + &quot;&lt;/H2&gt;/n&quot; +   &quot;Sorry, access to servlets by means of/n&quot; +   &quot;URLs that begin with/n&quot; +   &quot;http://host/webAppPrefix/servlet//n&quot; +   &quot;has been disabled./n&quot; +   &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，如果需求中有很多的请求，那么web.xml文件将会变得臃肿不堪，同时也要写大量的HttpServlet类用于处理请求，不利于代码的维护。  </p>
<h4 id="使用Spring-mvc"><a href="#使用Spring-mvc" class="headerlink" title="使用Spring mvc"></a>使用Spring mvc</h4><p>接受网络请求是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">配置web.xml文件</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- spring 配置文件 默认是/WEB-INF/applicationContext.xml ，在这里可以配置数据库地址，数据库文件，java bean等等--&gt;</span><br><span class="line"></span><br><span class="line">&lt;context-param&gt;</span><br><span class="line"> &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line"> &lt;!-- 默认是/WEB-INF/applicationContext.xml --&gt;</span><br><span class="line"> &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line"> &lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line"> &lt;listener&gt;</span><br><span class="line"> &lt;listener-class&gt;</span><br><span class="line"> org.springframework.web.context.ContextLoaderListener</span><br><span class="line"> &lt;/listener-class&gt;</span><br><span class="line"> &lt;/listener&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- spring mvc的中央前端分发器配置，不同于纯Servlet，所有的网络请求都经过该类然后分发--&gt;</span><br><span class="line"> &lt;servlet&gt;</span><br><span class="line"> &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line"> &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line"> &lt;!-- 配置文件，配置了beans --&gt;</span><br><span class="line"> &lt;init-param&gt;</span><br><span class="line"> &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line"> &lt;!-- 默认是/WEB-INF/[servlet名字]-servlet.xml，在这个文件里配置控制器所在的包 --&gt;</span><br><span class="line"> &lt;param-value&gt;/WEB-INF/SpringMVC-servlet.xml&lt;/param-value&gt;</span><br><span class="line"> &lt;/init-param&gt;</span><br><span class="line"> &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line"> &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--同样需要映射url，参数&lt;url-pattern&gt;表示所有的请求都由SpringMVC这个中央前端控制器接受 --&gt;</span><br><span class="line"> &lt;servlet-mapping&gt;</span><br><span class="line"> &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;</span><br><span class="line"> &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line"> &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--转码控制 --&gt;</span><br><span class="line"> &lt;filter&gt;</span><br><span class="line"> &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line"> &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line"> &lt;init-param&gt;</span><br><span class="line"> &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line"> &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line"> &lt;/init-param&gt;</span><br><span class="line"> &lt;init-param&gt;</span><br><span class="line"> &lt;param-name&gt;forceEncoding&lt;/param-name&gt;</span><br><span class="line"> &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line"> &lt;/init-param&gt;</span><br><span class="line"> &lt;/filter&gt;</span><br><span class="line"> &lt;filter-mapping&gt;</span><br><span class="line"> &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line"> &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line"> &lt;/filter-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义控制器："><a href="#定义控制器：" class="headerlink" title="定义控制器："></a>定义控制器：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//注解Controller表示这个类是一个控制器</span><br><span class="line">@Controller</span><br><span class="line">public class AppInfoController &#123;</span><br><span class="line"> private Logger logger = Logger.getLogger(AppInfoController.class);</span><br><span class="line"></span><br><span class="line">//RequestMapping注解表示这个方法处理 /app的请求</span><br><span class="line"> @RequestMapping(value = &quot;/app&quot;,method = RequestMethod.GET)</span><br><span class="line"> public void getAppInfoById(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line"> response.getWriter().append(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此使用Spring MVC的话，只需要在web.xml文件中配置DispatcherServlet，然后通过Controller注解一个类为控制器，再通过RequestMapping注解指定某方法可以接受某一类请求即可。这是最简单的使用，Spring MVC还提供很多其他的注解方式，比如ResponseBody注解直接将函数返回值作为Response的body返回，或者直接返回jsp文件名称并跳转页面等，不在赘述。</p>
<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，并将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得我们可以使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用， 完成数据持久化的任务。</p>
<h3 id="hibernate使用"><a href="#hibernate使用" class="headerlink" title="hibernate使用"></a>hibernate使用</h3><p>在引入Hibernate类库之后，需要完成两个步骤，涉及到两种文件：</p>
<h4 id="1-配置Hibernate"><a href="#1-配置Hibernate" class="headerlink" title="1.配置Hibernate"></a>1.配置Hibernate</h4><p>hibernate.cfg.xml 文件：这是hibernate的配置文件，在这里要做的事包括但不限于：<br>  a. 操作的数据库的地址，账户，密码<br>  b. .配置数据库驱动</p>
<h4 id="2-实体类及映射文件"><a href="#2-实体类及映射文件" class="headerlink" title="2.实体类及映射文件"></a>2.实体类及映射文件</h4><p>POJO的映射文件。例如有一个AppInfo的模型类，为了使hibernate可以将读出来的数据直接转化为对象，需要创建相对应的AppInfo.hbm.xml文件，下面以AppInfo类为例进行说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//这个是AppInfo model类，要求属性私有，并提供相应的setter和getter</span><br><span class="line">public class AppInfo implements java.io.Serializable &#123;</span><br><span class="line">  private static final long serialVersionUID = 1111111111111111111L;</span><br><span class="line"></span><br><span class="line">  private long id = 0;</span><br><span class="line">  private String appId;</span><br><span class="line">  public void setId(long id)&#123;</span><br><span class="line">    this.id=id;</span><br><span class="line">  &#125;</span><br><span class="line">  public long getId()&#123;</span><br><span class="line">    return id;</span><br><span class="line">  &#125;</span><br><span class="line">  public void setAppId(String appId)&#123;</span><br><span class="line">    this.appId = appId;</span><br><span class="line">  &#125;</span><br><span class="line">  public String getAppId()&#123;</span><br><span class="line">    return appId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的AppInfo.hbm.xml文件，其中id标签表示将属性id作为数据库的主键，property标签对应AppInfo类中的appId属性，其他属性以此类推<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping package=&quot;qiyi.vr.app.model&quot;&gt;</span><br><span class="line"> &lt;class name=&quot;AppInfo&quot; table=&quot;app_info&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;id name=&quot;id&quot; type=&quot;java.lang.Long&quot;&gt;</span><br><span class="line">      &lt;column name=&quot;id&quot; /&gt;</span><br><span class="line">      &lt;generator class=&quot;native&quot; /&gt;</span><br><span class="line">    &lt;/id&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;appId&quot; type=&quot;java.lang.String&quot;&gt;</span><br><span class="line">      &lt;column name=&quot;app_id&quot; /&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"> &lt;/class&gt;</span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<p>注：关于hbm.xml文件的生成：在MyEclipse中，可以通过根据数据库的字段反向映射来生成hbm.xml文件，但是这样会生成两个hbm.xml文件，具体原因及使用方法未知</p>
<h4 id="3-注册映射文件"><a href="#3-注册映射文件" class="headerlink" title="3.注册映射文件"></a>3.注册映射文件</h4><p>在hibernate.cfg.xml文件中注册上面得到的映射文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapping resource=&quot;qiyi/vr/app/model/AppInfo.hbm.xml&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-hibernate与数据库的交互"><a href="#4-hibernate与数据库的交互" class="headerlink" title="4.hibernate与数据库的交互"></a>4.hibernate与数据库的交互</h4><p>hibernate与数据库的交互涉及到三个比较重要的类：  </p>
<p>SessionFactory：SessionFactory实例对应一个数据存储源，其特点是1.线程安全，同一个SessionFactory可被多个线程共享2.重量级，SessionFactory需要大缓存，缓存中会存储预设的SQL语句，因此，如果只需要访问一个数据库，那么创建一个SessionFactory对象即可</p>
<p>Session：Session是持久化管理器，由SessionFactory生成，其特点是：1线程不安全，session代表和当前数据库之间的一次操作，尽量避免多线程共享session2.轻量级，创建session耗费的资源相对较少3.session又被称为Hibernate的一级缓存，存放当前工作单元加载的对象，使用完毕要关闭session</p>
<p>Transaction：Transaction接口是Hibernate数据库事务接口，Hibernate进行持久化操作时必须进行事务控制，简单说就是具体的数据库操作要在开启事务后进行，然后由事务进行commit，很类似于Android FragmentManager的Transaction。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public long insert(AppInfo entity) throws SQLException &#123;</span><br><span class="line">   // TODO Auto-generated method stub</span><br><span class="line">   Session session = HibernateSessionFactory.getSession();</span><br><span class="line">   Transaction transaction = session.beginTransaction();</span><br><span class="line">   session.save(entity);</span><br><span class="line">   transaction.commit();</span><br><span class="line">   session.close();</span><br><span class="line">   return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后台 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jni开发知识点]]></title>
      <url>/2017/12/26/jni-tips/</url>
      <content type="html"><![CDATA[<h2 id="JavaVM和JNIEnv"><a href="#JavaVM和JNIEnv" class="headerlink" title="JavaVM和JNIEnv"></a>JavaVM和JNIEnv</h2><p>jni定义了两个关键的结构体，<code>JavaVM</code>和<code>JNIEnv</code>，两者都拥有指向方法表的指针，在c++中，两者是拥有指向方法表和一系列jni方法的类，Android developer中说是类，实际开发中在jni.h中发现是结构体）。<br><code>javavm</code>提供<code>invocation interface</code>方法，可以创建和销毁<code>javavm</code>，理论上每个进程可以有多个<code>javavm</code>，但是Android中只允许有一个。<br><code>jnienv</code>提供大部分的<code>jni</code>方法，native方法的第一个参数就是<code>jnienv</code>。<code>jnienv</code>使用个<code>threadlocal</code>存储，因此线程间无法共享。如果某一段代码中无法获得<code>jnienv</code>，可以共享<code>javavm</code>并调用<code>GetEnv</code>来获得当前线程的<code>jnienv</code>，如果当前线程没有，可以使用<code>AttachCurrentThread</code>创建。</p>
<a id="more"></a>
<p><em>注意：c和c++关于两者的声明不同，如果头文件中定义了<code>#indef _cplusplus</code>，那么要注意自己引用的时哪个版本。</em></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>所有的线程都是linux线程，有kernal管理，可以自己创建线程，并通过<code>JNI AttachCurrentThread</code> or <code>AttachCurrentThreadAsDaemon</code>方法与jni关联，没有关联的话线程无法进行jni call。如果线程已经关联，那么调用<code>AttachCurrentThread</code>是空操作。当把一个线程Attach到<code>javavm</code>时，java中会创建一个<code>thread</code>,并添加到main threadGroup。android不会暂停正在执行native code的线程，只会在下一次执行jni call时暂停线程。通过jni关联的线程在退出前必须调用<code>DetachCurrentThread</code>，也可以使用<code>pthread_key_create</code>并构造新的析构函数来实现相同效果，在析构函数中调用该方法。使用<code>pthread_setspecific</code>存储<code>jnienv</code>到<code>threadlocal</code>，这样析构函数中传入<code>jnienv</code>参数。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>类的引用、<code>field IDs</code>和<code>method IDs</code> 在类unload之前都是可用的。类的unload操作很少见，但并不是不可能。<br>注意：尽管jclass是类的引用，但jclass必须通过NewGlobalRef的操作来保护起来。</p>
<p>native code中，对class的操作较为耗时，比如获得成员变量，回调方法，这些操作都要先获得<code>fieldId</code>和<code>methodId</code>，从性能角度看，最好将这些id缓存下来。考虑到java的类有可能会有unload，reload的过程，可以使用以下方式在每次加载类的时候缓存id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * We use a class initializer to allow the native code to cache some</span><br><span class="line"> * field offsets. This native function looks up and caches interesting</span><br><span class="line"> * class/field/method IDs. Throws on failure.</span><br><span class="line"> */</span><br><span class="line">private static native void nativeInit();</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，在一个类每次加载时都会调用nativeInit，在native层相应实现方法即可。</p>
<p><em>疑问：不同类的加载时线程问题</em></p>
<h1 id="局部引用和全局引用"><a href="#局部引用和全局引用" class="headerlink" title="局部引用和全局引用"></a>局部引用和全局引用</h1><p>传递给<code>native</code>方法传递的参数和大部分jni返回的参数都是局部引用，这意味着这些引用在当前的<code>native</code>方法中可见。及时对象在本地方法返回后仍然存活，引用也是不可见的。获得全局引用的唯一方法是<code>NewGlobalRef</code>和<code>NewWeakGlobalRef</code>.常用的模式是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jclass localClass = env-&gt;FindClass(&quot;MyClass&quot;);</span><br><span class="line">//reinterpret_cast c++强制类型转换</span><br><span class="line">jclass globalClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(localClass));</span><br></pre></td></tr></table></figure>
<p>jni方法接受局部和全局引用作为参数。<br>指向同一对象的多个引用可能值并不相等。比如，连续多次调用NewGlobalRef的结果可能不同，因此在jni中，不能用==来判断引用是否相等，而要使用<code>IsSameObject</code>。因此，native中，不能假设对象的引用是不变的。</p>
<p>jni中，不能过多的分配局部引用，如果创建过多局部引用，要手动<code>DeleteLocalRef</code>(一般情况这个操作由jni自己完成)。实际中最多保留十六个局部引用，如果要更多，使用<code>EnsureLocalCapacity/PushLocalFrame</code></p>
<p>注意：<code>jfieldIDs</code> and <code>jmethodIDs</code>不是<code>object</code>引用，不能更改为GlobalRef。</p>
<p>如果调用<code>AttachCurrentThread</code>，运行中的代码不会自动释放局部引用知道线程结束，需要手动释放。</p>
<h2 id="基本类型数组"><a href="#基本类型数组" class="headerlink" title="基本类型数组"></a>基本类型数组</h2><p><em>此部分需要写代码进行验证</em></p>
<p>基本类型数组可以直接进行读写操作，因为他们是由c定义的。<br>有一组函数用于对基本类型数组操作<code>Get&lt;PrimitiveType&gt;ArrayElements</code>,这些函数有的返回指针，有的返回真实的元素，有的分配内存并进行拷贝。不管哪种方式，返回的原始的指针在释放前都是可见的。也就是说，如果数据没有被拷贝，数组对象就不会被释放。我们必须释放所有的数组。<br>是否进行拷贝是通过get系列函数的iscopy来确定的。<br>release调用时传入mode参数：<br>mode：<br>0:<br>源数据： 释放<br>copy数据：data is copied back. The buffer with the copy is freed.</p>
<p>JNI_COMMIT<br>源数据： 无操作<br>copy数据：data is copied back. The buffer with the copy is not freed.</p>
<p>JNI_ABORT<br>源数据：  the array object is un-pinned. Earlier writes are not aborted.<br>copy数据：the buffer with the copy is freed; any changes to it are lost.</p>
<p>JNI_COMMIT不会释放元数据，需要使用其他参数再次调用release</p>
<p>关于isCopy，检查是否进行了拷贝很有用，如果对数组进行了修改，这可以让我们确定自己是否需要调用带有JNI_COMMIT的release方法。</p>
<p>Region Calls<br>如果仅仅是为了将数据拷贝出来或者拷贝进去，有更方便的方法：<br>先看以前的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jbyte* data = env-&gt;GetByteArrayElements(array, NULL);</span><br><span class="line">if (data != NULL) &#123;</span><br><span class="line">    memcpy(buffer, data, len);</span><br><span class="line">    env-&gt;ReleaseByteArrayElements(array, data, JNI_ABORT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方便的方法,还能避免忘记release,还会避免多余的拷贝<br><code>env-&gt;GetByteArrayRegion(array, 0, len, buffer);</code></p>
<p>异常<br>很多jni方法会抛出异常。比如<code>CallObjectMethod</code>，这时需要check异常，因为该函数的返回值可能不可用。android还不支持c++的异常，jni的Throw和throwNew会在当前线程抛出一个java异常。native方法中，通过<code>ExceptionCheck</code>和<code>ExceptionOccurred</code>捕获异常。通过<code>ExceptionClear</code>清理异常。</p>
<h2 id="关于JNIEnv"><a href="#关于JNIEnv" class="headerlink" title="关于JNIEnv"></a>关于<code>JNIEnv</code></h2><p>c style:<br>JNIEnv是一个名为JNINativeInterface的结构体，里面包含了一系列方法的指针用于jni的交互，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct JNINativeInterface &#123;</span><br><span class="line">    void*       reserved0;</span><br><span class="line">    void*       reserved1;</span><br><span class="line">    void*       reserved2;</span><br><span class="line">    void*       reserved3;</span><br><span class="line"></span><br><span class="line">    jint        (*GetVersion)(JNIEnv *);</span><br><span class="line"></span><br><span class="line">    jclass      (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*,</span><br><span class="line">                        jsize);</span><br><span class="line">    jclass      (*FindClass)(JNIEnv*, const char*);</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<p>c++ style：将c的JNINativeInterface结构体进行封装，变为名为_JNIEnv的结构体，并对JNINativeInterface的方法进行封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * C++ object wrapper.</span><br><span class="line"> *</span><br><span class="line"> * This is usually overlaid on a C struct whose first element is a</span><br><span class="line"> * JNINativeInterface*.  We rely somewhat on compiler behavior.</span><br><span class="line"> */</span><br><span class="line">struct _JNIEnv &#123;</span><br><span class="line">    /* do not rename this; it does not seem to be entirely opaque */</span><br><span class="line">    const struct JNINativeInterface* functions;</span><br><span class="line"></span><br><span class="line">#if defined(__cplusplus)</span><br><span class="line"></span><br><span class="line">    jint GetVersion()</span><br><span class="line">    &#123; return functions-&gt;GetVersion(this); &#125;</span><br><span class="line"></span><br><span class="line">    jclass DefineClass(const char *name, jobject loader, const jbyte* buf,</span><br><span class="line">        jsize bufLen)</span><br><span class="line">    &#123; return functions-&gt;DefineClass(this, name, loader, buf, bufLen); &#125;</span><br><span class="line"></span><br><span class="line">    jclass FindClass(const char* name)</span><br><span class="line">    &#123; return functions-&gt;FindClass(this, name); &#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></p>
<h2 id="关于JavaVM"><a href="#关于JavaVM" class="headerlink" title="关于JavaVM"></a>关于JavaVM</h2><p>c style:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//JNI invocation interface.</span><br><span class="line">struct JNIInvokeInterface &#123;</span><br><span class="line">    void*       reserved0;</span><br><span class="line">    void*       reserved1;</span><br><span class="line">    void*       reserved2;</span><br><span class="line"></span><br><span class="line">    jint        (*DestroyJavaVM)(JavaVM*);</span><br><span class="line">    jint        (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*);</span><br><span class="line">    jint        (*DetachCurrentThread)(JavaVM*);</span><br><span class="line">    jint        (*GetEnv)(JavaVM*, void**, jint);</span><br><span class="line">    jint        (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>c++ style:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct _JavaVM &#123;</span><br><span class="line">    const struct JNIInvokeInterface* functions;</span><br><span class="line">	//if defined(__cplusplus)</span><br><span class="line">    jint DestroyJavaVM()</span><br><span class="line">    &#123; return functions-&gt;DestroyJavaVM(this); &#125;</span><br><span class="line">    jint AttachCurrentThread(JNIEnv** p_env, void* thr_args)</span><br><span class="line">    &#123; return functions-&gt;AttachCurrentThread(this, p_env, thr_args); &#125;</span><br><span class="line">    jint DetachCurrentThread()</span><br><span class="line">    &#123; return functions-&gt;DetachCurrentThread(this); &#125;</span><br><span class="line">    jint GetEnv(void** env, jint version)</span><br><span class="line">    &#123; return functions-&gt;GetEnv(this, env, version); &#125;</span><br><span class="line">    jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args)</span><br><span class="line">    &#123; return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="关于引用数据类型"><a href="#关于引用数据类型" class="headerlink" title="关于引用数据类型"></a>关于引用数据类型</h2><p>c style:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Reference types, in C.</span><br><span class="line"> */</span><br><span class="line">typedef void*           jobject;</span><br><span class="line">typedef jobject         jclass;</span><br><span class="line">typedef jobject         jstring;</span><br><span class="line">typedef jobject         jarray;</span><br><span class="line">typedef jarray          jobjectArray;</span><br><span class="line">typedef jarray          jbooleanArray;</span><br><span class="line">typedef jarray          jbyteArray;</span><br><span class="line">typedef jarray          jcharArray;</span><br><span class="line">typedef jarray          jshortArray;</span><br><span class="line">typedef jarray          jintArray;</span><br><span class="line">typedef jarray          jlongArray;</span><br><span class="line">typedef jarray          jfloatArray;</span><br><span class="line">typedef jarray          jdoubleArray;</span><br><span class="line">typedef jobject         jthrowable;</span><br><span class="line">typedef jobject         jweak;</span><br></pre></td></tr></table></figure></p>
<p>可见，在c中，由无类型指针void*引申出一系列的jobject</p>
<p>c++ style:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Reference types, in C++</span><br><span class="line"> */</span><br><span class="line">class _jobject &#123;&#125;;</span><br><span class="line">class _jclass : public _jobject &#123;&#125;;</span><br><span class="line">class _jstring : public _jobject &#123;&#125;;</span><br><span class="line">class _jarray : public _jobject &#123;&#125;;</span><br><span class="line">class _jobjectArray : public _jarray &#123;&#125;;</span><br><span class="line">class _jbooleanArray : public _jarray &#123;&#125;;</span><br><span class="line">class _jbyteArray : public _jarray &#123;&#125;;</span><br><span class="line">class _jcharArray : public _jarray &#123;&#125;;</span><br><span class="line">class _jshortArray : public _jarray &#123;&#125;;</span><br><span class="line">class _jintArray : public _jarray &#123;&#125;;</span><br><span class="line">class _jlongArray : public _jarray &#123;&#125;;</span><br><span class="line">class _jfloatArray : public _jarray &#123;&#125;;</span><br><span class="line">class _jdoubleArray : public _jarray &#123;&#125;;</span><br><span class="line">class _jthrowable : public _jobject &#123;&#125;;</span><br><span class="line"></span><br><span class="line">typedef _jobject*       jobject;</span><br><span class="line">typedef _jclass*        jclass;</span><br><span class="line">typedef _jstring*       jstring;</span><br><span class="line">typedef _jarray*        jarray;</span><br><span class="line">typedef _jobjectArray*  jobjectArray;</span><br><span class="line">typedef _jbooleanArray* jbooleanArray;</span><br><span class="line">typedef _jbyteArray*    jbyteArray;</span><br><span class="line">typedef _jcharArray*    jcharArray;</span><br><span class="line">typedef _jshortArray*   jshortArray;</span><br><span class="line">typedef _jintArray*     jintArray;</span><br><span class="line">typedef _jlongArray*    jlongArray;</span><br><span class="line">typedef _jfloatArray*   jfloatArray;</span><br><span class="line">typedef _jdoubleArray*  jdoubleArray;</span><br><span class="line">typedef _jthrowable*    jthrowable;</span><br><span class="line">typedef _jobject*       jweak;</span><br></pre></td></tr></table></figure></p>
<p>在c++中，jobject是一个类</p>
<h2 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Primitive types that match up with Java equivalents. */</span><br><span class="line">typedef uint8_t  jboolean; /* unsigned 8 bits */</span><br><span class="line">typedef int8_t   jbyte;    /* signed 8 bits */</span><br><span class="line">typedef uint16_t jchar;    /* unsigned 16 bits */</span><br><span class="line">typedef int16_t  jshort;   /* signed 16 bits */</span><br><span class="line">typedef int32_t  jint;     /* signed 32 bits */</span><br><span class="line">typedef int64_t  jlong;    /* signed 64 bits */</span><br><span class="line">typedef float    jfloat;   /* 32-bit IEEE 754 */</span><br><span class="line">typedef double   jdouble;  /* 64-bit IEEE 754 */</span><br><span class="line"></span><br><span class="line">/* &quot;cardinal indices and sizes&quot; */</span><br><span class="line">typedef jint     jsize;</span><br></pre></td></tr></table></figure>
<p>可见，jni的基本类型与c中基本类型一样，所以可以直接转换，且不用考虑释放问题。</p>
<h2 id="方法的类型签名："><a href="#方法的类型签名：" class="headerlink" title="方法的类型签名："></a>方法的类型签名：</h2><p>jni使用java虚拟机的类型签名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Type Signature  				Java Type</span><br><span class="line">Z              					boolean</span><br><span class="line">B						byte</span><br><span class="line">C						char</span><br><span class="line">S						short</span><br><span class="line">I						int</span><br><span class="line">J						long</span><br><span class="line">F						float</span><br><span class="line">D						double</span><br><span class="line">Lfully-qualified-class;				fully-qualified-class</span><br><span class="line">[type						type[]</span><br><span class="line">(arg-types)ret-type				method type</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line">long f (int n, String s, int[] arr);</span><br><span class="line">的签名是：</span><br><span class="line">(ILjava/lang/String;[I)J</span><br></pre></td></tr></table></figure></p>
<h2 id="关于native向java回调"><a href="#关于native向java回调" class="headerlink" title="关于native向java回调"></a>关于native向java回调</h2><p>在回调时经常会碰到多个不同的方法的类型签名，为避免重复代码和方便,可以使用以下方法。避免直接传递基本类型，全部使用jobject作为参数，基本类型使用其封装类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void callBackJavaUniversal(JavaVM *gJavaVM, jobject targetObj, string     nameStr, string sigStr,jobject param1, jobject param2) &#123;</span><br><span class="line">    char *name = (char *) nameStr.data();</span><br><span class="line">    char *sig = (char *) sigStr.data();</span><br><span class="line">    JNIEnv *env = 0;</span><br><span class="line">    if (gJavaVM != NULL) &#123;</span><br><span class="line">        gJavaVM-&gt;AttachCurrentThread(&amp;env, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (env == NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    jclass javaClass = env-&gt;GetObjectClass(targetObj);</span><br><span class="line">    jmethodID javaCallback = env-&gt;GetMethodID(javaClass, name, sig);</span><br><span class="line">    if (param1 == NULL) &#123;</span><br><span class="line">        env-&gt;CallVoidMethod(targetObj, javaCallback);</span><br><span class="line">    &#125; else if (param2 == NULL)&#123;</span><br><span class="line">        env-&gt;CallVoidMethod(targetObj, javaCallback, param1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        env-&gt;CallVoidMethod(targetObj, javaCallback, param1, param2);</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;DeleteLocalRef(javaClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[First Blog]]></title>
      <url>/2017/12/26/first/</url>
      <content type="html"><![CDATA[<h2 id="first-blog"><a href="#first-blog" class="headerlink" title="first blog"></a>first blog</h2>]]></content>
      
        <categories>
            
            <category> 日常 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
