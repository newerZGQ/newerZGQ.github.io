<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Weex系列(1)-环境与工具]]></title>
    <url>%2F2018%2F11%2F29%2FWeex%E7%B3%BB%E5%88%97-1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[什么是WeexWeex官网的一句话介绍：Weex 是一个使用 Web 开发体验来开发高性能原生应用的框架。Weex是由阿里巴巴开发的，基于先进Web技术，使用同一套代码来构建 Android、iOS 和 Web 应用。具体来讲，在集成了 WeexSDK 之后，你可以使用 JavaScript 和现代流行的前端框架来开发移动应用。 支持的前端框架 Vue.js Rax 环境搭建 关于环境，官网介绍已经非常详细了需要注意的是 在 package.json 中，已经配置好了几个常用的 npm script，分别是： build: 源码打包，生成 JS Bundle dev: webpack watch 模式，方便开发 serve: 开启HotReload服务器，代码改动的将会实时同步到网页中 Weex 官方提供了 weex-toolkit 的脚手架工具来辅助开发和调试，通过install -g weex-toolkit安装后就可以使用weex命令来创建weex工程了 Demo 创建一个Weex项目weex create awesome-project执行完命令后，在 awesome-project 目录中就创建了一个使用 Weex 和 Vue 的模板项目。 开启服务npm start执行完命令后，根据终端提示访问相应网站即可即时浏览效果，使用weex官方app playground也能在手机上进行预览 客户端安装包打包 添加或移除平台 12weex platform add iosweex platform add android 12weex platform add iosweex platform add android 查看平台列表weex platform list 运行 123weex run iosweex run androidweex run web 这样运行会直接打出客户端包并进行安装，因此需要提前配置好ios或android的开发环境 输出客户端工程 12npm run pack:iosnpm run pack:android 执行完命令后，在项目中会生成一个新的文件夹platforms，工程就放在这个文件夹中。 目录结构需要重点关注的几个文件或文件夹（待续） configs/config.js package.json Native端的集成输出客户端工程后，可以非常直观的看出Weex SDK的使用方式，但是，我们大部分情况并不是使用输出的工程继续开发，那么怎么接入weex到既有项目呢？ 集成sdk集成sdk的坑有点多，这里要着重说一下Android集成，主要参考Android集成Weex sdk 中文官网中参考代码12345compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;compile &apos;com.android.support:support-v4:23.1.1&apos;compile &apos;com.android.support:appcompat-v7:23.1.1&apos;compile &apos;com.alibaba:fastjson:1.1.46.android&apos;compile &apos;com.taobao.android:weex_sdk:0.5.1@aar&apos; 注意上面的weex_sdk版本是0.5.1，这本来是没有问题的，但是因为weex在0.10.0版本之后全面支持vue2.0，而前面文档中weex create命令创建出来的项目是基于vue2.0的，这会导致在加载编译出的jsbundle时会报错ReferenceError: Vue is not defined而英文文档就没有这个问题，英文文档给出的版本是0.18.0，改成0.18.0后虽然能解决上面的问题，但是在load本地jsbundle时又出现失败的错误，所以我使用的是0.16.0。目前weex的版本迭代还是比较频繁的，但是不建议使用最新的，问题会比较多。 示例代码 仓库地址]]></content>
      <tags>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnyTest-Introductin]]></title>
    <url>%2F2018%2F11%2F03%2FAnyTest-Introduction%2F</url>
    <content type="text"><![CDATA[AnyTest这是什么这是一个非常有意思的希望能够提高学生或者文字记忆者效率的一款应用。这款app基于MVP模式，使用Realm进行数据存储，使用RxJava完成异步调用，使用lombok减少代码量，使用butterknife进行view绑定，使用dagger2完成依赖注入，可以说这个项目是使用了相对来说比较新潮的技术来开发的，这也是我做这个项目的初衷，就是接触更多的技术。如果你也对这些项目有兴趣，不防在这里集中的了解一下。 为什么做在我还未成为一名coder之前，有一次因为工作原因，需要记忆大量的题目，题目类型都是比较常见的填空题选择题之类，但是因为题库的书不便于随身携带，就萌发写一个app的想法，希望这个app可以解析文档，并将题目内容完整的存储在app上，并且按照题目类别以不同方式进行展示和交互，帮助记忆，这就是AnyTest的由来。 有什么特点 解析文档把文档整理成类似这个文件之后放入sd卡中，打开app点击‘+’号选择该文件即可进行解析。文档解析是基于字符的，对文档格式要求较高。 支持题目类型目前支持填空题、判断题、单选题、多选题以及简答题，每种题目都支持交互学习，支持收藏功能 任务管理可以设置文档是否进入学习状态每个解析的文档都可以单独设置每日学习量查看最近一周的学习记录支持每个文档的答题正确率这个项目用了什么 MVP模式googlesamples/android-architecture这个仓库中对google推崇的MVP模式有非常相近的介绍。 RealmRealm是一个移动端的存储方案，区别于传统sqlite的表的概念，Realm中的增删改查都是针对对象的，也就是说，你查询的结果直接就是一个对象，非常的便捷。Realm中的对象会有多种状态，用于分辨是否可进行修改等操作。另外，Realm还提供了方便的数据库检索app，更加直观的查看当前的数据库内容。 Dagger2Dagger2依赖注入的神器，Dagger2相对于Dagger也有很大提升。 lomboklombok自动生成代码的神器，远离get和set RxJavaRxJava butterknifebutterknife这个app能做什么]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>AnyTest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-collection]]></title>
    <url>%2F2018%2F02%2F27%2Fjava-collection%2F</url>
    <content type="text"><![CDATA[Java集合 重要的接口 List（有序、可重复）List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 Set（无序、不能重复）Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 Map（键值对、键唯一、值不唯一）Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 对比如下 List，允许重复元素 ArrayList:基于数组实现 Vector:基于数组实现，方法都是同步的(Synchronized),是线程安全的 LinkedList:基于链表实现，两者都有序 Set，不允许有重复值 HashSet基于HashMap实现，只不过Key-Value里面的value都是同一个object，因为是基于hashmap（散列表）实现，所以自然是无序的 TreeSet基于TreeMap实现，只不过Key-Value里面的value都是同一个object，因为是基于TreeMap（红黑树）实现，所以自然是有序的 Map，键值对，key唯一，value可重复 HashMap：最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的 Hashtable:与HashMap类似，也是散列表实现，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 TreeMap：基于红黑树实现，实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，因为无法比较，非同步的 LinkedHashMap：保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。这是因为LinkedHashMap中的Node有before和after两个引用，分别指向前一个和后一个节点 ConcurrentHashMap：线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。java1.7和1.8的实现有很大区别，见https://www.cnblogs.com/study-everyday/p/6430462.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[floor-ceiling]]></title>
    <url>%2F2018%2F02%2F09%2Ffloor-ceiling%2F</url>
    <content type="text"><![CDATA[趣味floor和ceiling为什么向下取整用floor（小于等于给定值n的最大整数），向上取整用ceiling（大于等于给定值n的最小值）。想想在一个房间里，有地板floor（代表整数m），天花板ceiling(代表m+1)，n位于地板和天花板之间，floor不就是小于等于n的最大整数么，ceiling也类似，真是形象~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[search-algorithm]]></title>
    <url>%2F2018%2F02%2F08%2Fsearch-algorithm%2F</url>
    <content type="text"><![CDATA[符号表符号表的主要目的是将一个键和一个值联系起来，可以根据键获得值。我们会用多种方式实现这种数据结构，不仅能高效的插入和查找，还可以进行其他方便的操作。这里我们还会讨论java中符号表的实现。为了熟悉kotlin这里所有的算法都将使用kotlin来实现。 规则 每个键对应一个值 键值均不允许null（java中hashmap是可以为空的） 删除操作，有延时删除（先置空再删除）和即时删除（直接删除） 迭代，便利所有键 键的等价性，equals判断是否相等，如果使用了comparable接口来进行比较，那么保证equals与compareTo返回值一致。总有人问hashmap是否有序，hashmap在使用时对键没有要求，不需要实现接口Iterable，也就是说键无法比较，那么怎么可能是有序的呢 基于无序链表的顺序查找基于链表的实现，在查找时只能是顺序查找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//kt中泛型的使用class Search&lt;Key : Comparable&lt;Key&gt;,Value&gt;&#123; //如果可能为null，则需要加？修饰 private var first: Node? = null private var N: Int = 0 fun put(key: Key,value: Value)&#123; var x:Node? = first while (x != null)&#123; if (x.key!!.compareTo(key) == 0)&#123; x.value = value return &#125;else x = x.next &#125; this.first = Node(key,value, first) N++ &#125; //返回值有可能为null也需要加？修饰 fun get(key: Key): Value?&#123; var tmp = first while (tmp != null)&#123; if (tmp.key!!.compareTo(key) == 0) return tmp.value tmp = tmp.next &#125; return null &#125; fun delete(key:Key)&#123; if (first == null)&#123; return &#125; if (first?.key?.compareTo(key) == 0) &#123; first = first?.next N-- return &#125; var tmp = first var pre : Node? = null while (tmp != null)&#123; if (tmp.key.compareTo(key) == 0)&#123; pre?.next = tmp.next N-- return &#125;else&#123; pre = tmp tmp = tmp.next &#125; &#125; &#125; fun size(): Int &#123; return N &#125; //内部类，还有嵌套类，有区别，构造函数在类声明后面 inner class Node(val key: Key, var value: Value, var next: Node?)&#125; 基于无序链表的查找，未命中的查找和插入操作都需要N次比较。向一个空表中连续插入N个键需要$~\frac{N^2}{2}$次比较。所以基于无需链表的实现效率很低。 基于有序数组的二分查找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class BinarySearch(var N: Int)&#123; var keys = arrayOfNulls&lt;String&gt;(N) var values = arrayOfNulls&lt;String&gt;(N) //指示当前最后一个元素的位置 var index: Int = -1 fun put(key:String,value:String)&#123; //i指向大于key的第一个位置 val i = rank(key) //如果存在直接更新并返回 if (i&lt;=index &amp;&amp; key.compareTo(keys[i]!!) == 0)&#123; values[i] = value return &#125; //不存在key的话，将所有大于key的元素全部向后移动一位，再插入 relocation(i,index,keys,values) keys[i] = key values[i] = value index++ &#125; //这是最直接的二分查找 fun get(key:String):String?&#123; var i = rank(key,0,index) if (i&lt;=index &amp;&amp; key.compareTo(keys[i]!!) == 0)&#123; return values[i] &#125;else&#123; return null &#125; &#125; fun delete(key:String)&#123; var i = rank(key) if (key.compareTo(keys[i]!!) == 0)&#123; relocationReserv(i+1,index,keys,values) index-- return &#125; &#125; //如果表中存在key，rank方法返回key的位置，也就是小于key的键的数量 //如果表中不存在key，rank方法还是返回小于key的键的数量 //下面是递归实现 private fun rank(key:String, lo:Int, hi:Int):Int&#123; if (hi&lt;lo) return lo var mid = lo + (hi-lo)/2 val com = key.compareTo(keys[mid]!!) if (com &gt; 0) return rank(key,mid+1,hi) else if (com &lt; 0) return rank(key,lo,mid-1) return mid &#125; //迭代实现 private fun rank(key: String):Int&#123; var lo = 0 var hi = index while (lo &lt;= hi)&#123; var mid = lo+(hi-lo)/2 var com = key.compareTo(keys[mid]!!) if (com == 0) return mid else if (com&gt;0) lo = mid+1 else if (com&lt;0) hi = mid-1 &#125; return lo &#125; //返回一定范围内的key fun rangeKeys(loKey:String, hiKey: String): Iterable&lt;String&gt; &#123; var result = ArrayList&lt;String&gt;(N) var lo = rank(loKey) var hi = rank(hiKey) for (i in lo..hi)&#123; result.add(keys[i]!!) &#125; return result &#125; private fun relocation(start:Int, end: Int, array1: Array&lt;String?&gt;, array2: Array&lt;String?&gt;)&#123; val max = array1.size-1 for (i in end downTo start)&#123; if (i &lt; max)&#123; array1[i+1] = array1[i] array2[i+1] = array2[i] &#125; &#125; &#125; private fun relocationReserv(start:Int,end: Int, array1: Array&lt;String?&gt;, array2: Array&lt;String?&gt;)&#123; val max = array1.size-1 for (i in start..end)&#123; if (i&lt;=max)&#123; array1[i-1] = array1[i] array2[i-1] = array2[i] &#125; &#125; array1[end] = null array2[end] = null &#125;&#125; 二分查找很快，在N个键的有序数组中进行二分查找最多需要(lgN+1)次比较（无论是否成功）。插入一个新元素在最坏的情况下要访问数组~2N次，因此向一个空符号表中插入N个元素在最坏情况下需要访问$~N^2$次数组。也就是说，基于有序数组实现的符号表插入效率低下，这是一个缺陷。 基于链表和有序数组的符号表实现比较 二叉查找树要支持高效的插入操作，需要支持二分查找的链式结构，但单链表显然无法满足，因为二分查找的高效来自于可以通过索引快速的入得任何数组的中间元素，但得到链表中间元素的唯一方法就是遍历。将二分查找和链表的灵活性结合起来，我们需要更复杂的数据结构，就是二叉查找树。 二叉树在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。二叉树的根结点所在的层数为1，根结点的孩子结点所在的层数为2，以此下去。深度是指所有结点中最深的结点所在的层数。二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其叶子结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2n+1。深度为k的完全二叉树，至少有2^（k-1)个节点，至多有2^k-1个节点。二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态：(1)空二叉树(2)只有一个根结点的二叉树(3)只有左子树(4)只有右子树(5)完全二叉树注意：尽管二叉树与树有许多相似之处，但二叉树不是树的特殊情形。 二叉树类型 完全二叉树 满二叉树 平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。相关术语树的结点：包含一个数据元素及若干指向子树的分支；孩子结点：结点的子树的根称为该结点的孩子；双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点；祖先结点: 从根到该结点的所经分支上的所有结点；子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙；结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；树的深度：树中最大的结点层结点的度：结点子树的个数树的度： 树中最大的结点度。叶子结点：也叫终端结点，是度为 0 的结点；分枝结点：度不为0的结点；有序树：子树有序的树，如：家族树；无序树：不考虑子树的顺序；遍历顺序遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。如何记忆三种遍历：注意，DLR是先根次序遍历，即判断先中后的方式是看何时访问双亲节点，而LR永远都是先左后右的顺序。二叉树实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230package com.zgq;public class BST &lt;Key extends Comparable&lt;Key&gt;,Value&gt;&#123; private Node root; private class Node&#123; private Key key; private Value value; private int N; private Node left,right; private Node(Key key,Value value,int N)&#123; this.key = key; this.value = value; this.N = N; &#125; &#125; public void put(Key key, Value value)&#123; root = put(root,key,value); &#125; private Node put(Node root,Key key,Value value)&#123; if (root == null)&#123; return new Node(key,value,1); &#125; int cmp = key.compareTo(root.key); if (cmp &gt; 0)&#123; root.right = put(root.right,key,value); &#125;else if (cmp &lt; 0)&#123; root.left = put(root.left,key,value); &#125;else &#123; root.value = value; &#125; root.N = sizeOf(root.left) + sizeOf(root.right) + 1; return root; &#125; public Value get(Key key)&#123; return get(root,key); &#125; private Value get(Node root, Key key)&#123; if (root == null) return null; int cmp = key.compareTo(root.key); if (cmp &gt; 0) return get(root.right,key); else if (cmp &lt; 0) return get(root.left,key); else return root.value; &#125; public int size()&#123; return sizeOf(root); &#125; private int sizeOf(Node root)&#123; if (root == null) return 0; return root.N; &#125; public Value max()&#123; return max(root).value; &#125; private Node max(Node root)&#123; if (root == null) return null; if (root.right == null) return root; return max(root.right); &#125; public Value min()&#123; return min(root).value; &#125; private Node min(Node root)&#123; if (root == null) return null; if (root.left == null) return root; return min(root.left); &#125; public void delete(Key key)&#123; delete(root,key); &#125; //删除节点并返回根节点 private Node delete(Node root,Key key)&#123; if (root == null) return null; int cmp = key.compareTo(root.key); //在右子树中进行删除，同时保证root的右节点指向删除后得根节点 if (cmp &gt; 0) root.right = delete(root.right,key); else if (cmp &lt; 0) root.left = delete(root.left,key); else &#123; //如果找到节点，则分步删除 //左子树为空，则返回右子树根节点 if (root.left == null) return root.right; //右子树为空，则返回左子树根节点 if (root.right == null) return root.left; //左右都不为空，则将右子树中最小的节点copy到要删除节点root的位置，同时新root的左子树链接原root的左子树，新root的右子树链接删除最小节点后得右子树 Node t = root; root = min(root.right); root.left = t.left; root.right = deleteMin(root.right); &#125; root.N = sizeOf(root.left) + sizeOf(root.right) + 1; return root; &#125; public void deleteMin()&#123; root = deleteMin(root); &#125; private Node deleteMin(Node root)&#123; if (root.left == null) return root.right; root.left = deleteMin(root.left); root.N = sizeOf(root.left) + sizeOf(root.right) + 1; return root; &#125; public void deleteMax()&#123; root = deleteMax(root); &#125; //删除最大节点并返回根节点 private Node deleteMax(Node root)&#123; if (root.right == null) return root.left; //递归实现 root.right = deleteMax(root.right); root.N = sizeOf(root.left) + sizeOf(root.right) + 1; return root; &#125; public Key floor(Key key)&#123; return floor(root,key).key; &#125; private Node floor(Node root, Key key)&#123; if (root == null) return null; int cmp = key.compareTo(root.key); if (cmp == 0) return root; else if (cmp &lt; 0) &#123; return floor(root.left, key); &#125; Node t = floor(root.right,key); if (t != null) return t; else return root; &#125; public Key ceiling(Key key)&#123; return ceiling(root,key).key; &#125; private Node ceiling(Node root, Key key)&#123; if (root == null) return null; int cmp = key.compareTo(root.key); if (cmp == 0) return root; else if (cmp &gt; 0) &#123; return ceiling(root.right, key); &#125; Node t = ceiling(root.left,key); if (t != null) return t; else return root; &#125; //返回比key小的节点数量 public int rank(Key key)&#123; return rank(root,key); &#125; private int rank(Node root, Key key)&#123; if (root == null) return 0; int cmp = key.compareTo(root.key); if (cmp &lt; 0) return rank(root.left,key); //注意这里，当key比root节点大时，返回root的子节点数量+对root右子树做rank操作的结果+1 else if (cmp &gt; 0) return 1 + sizeOf(root.left) + rank(root.right,key); else return sizeOf(root.left); &#125; //返回排名为k的元素，从0开始排 public Key select(int k)&#123; return select(root,k).key; &#125; private Node select(Node root, int k)&#123; if (root == null) return null; int t = sizeOf(root.left); if (t &lt; k) return select(root.right,k-t-1); else if (t &gt; k) return select(root.left,k); else return root; &#125; //范围查找操作 //返回所有键，无序 public Iterable&lt;Key&gt; keys()&#123; return keys(min(),max()); &#125; //返回lo到hi之间的所有键 public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); keys(root,queue,lo,hi); return queue; &#125; private void keys(Node root, Queue&lt;Key&gt; queue,Key lo,Key hi)&#123; if (root == null) return; int cmpLo = lo.compareTo(root.key); int cmpHi = hi.compareTo(root.key); if (cmpLo &lt;= 0 &amp;&amp; cmpHi &gt;= 0)&#123; queue.add(root.key); &#125; if (cmpLo &lt; 0)&#123; keys(root.left,queue,lo,hi); &#125; if (cmpHi &gt; 0)&#123; keys(root.right,queue,lo,hi); &#125; &#125; public void printAllLDR()&#123; printAllLDR(root); System.out.print(&quot;\n&quot;); &#125; private void printAllLDR(Node root)&#123; if (root.left != null) &#123; printAllLDR(root.left); &#125; System.out.print(&quot;*&quot; + root.key + &quot;*&quot;); if (root.right != null) &#123; printAllLDR(root.right); &#125; &#125;&#125; 使用二叉查找树的算法运算时间取决于树的形状，而树的形状右取决于键被插入的先后顺序。在最好的情况下，N个节点的数是完全平衡的，每条空链到根节点的距离都是lgN。但是在最坏的情况下，搜索路径上可能有N个节点。二叉查找树和快排有极高的相似度，根节点就是快排的切分元素。 性质 在由N个随机键构造的二叉查找树中，查找命中平均所需比较次数~2lgN（约1.39lgN）。 在由N个随机键构造的二叉查找树中，插入操作和查找未命中平均所需比较次数~2lgN（约1.39lgN）。性能分析 在一棵二叉查找树中，所有操作在最坏情况下所需时间都和树的高度成正比。 二叉树的优势还在于其支持高效的rank(),select(),delete()以及范围查找操作。 某些最坏的情况下仍有恶劣的性能。平衡查找树在一个含有N个节点的树中，我们希望树高为lgN，这样就能保证每次查找都能在树高次比较中结束，就像二分查找一样。但是在动态插入中保证树的完美平衡代价很大，这节将要解决这个问题。23查找树一颗完美平衡的23查找树中的所有空节点到根节点的距离都是相同的 查找，与二叉树类似 插入：插入操作较为麻烦，在二叉树中插入时，我们是先做一个查找，如果未命中，则把新节点挂在树的底部，这样的影响是树无法保证完美平衡性。使用23树可以避免这种情况。插入过程详解 未命中查找结束与一个2节点，把2节点转换成3节点，再将新节点保存在其中即可。 树中只含有3节点，]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颜色空间]]></title>
    <url>%2F2018%2F02%2F08%2Fcolor-space%2F</url>
    <content type="text"><![CDATA[RGB、YUV和HSV颜色空间模型https://www.cnblogs.com/justkong/p/6570914.html kiwiplayer的视频增强算法中，luma方法是将rgb颜色转换为yuv颜色空间来计算的。 采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algorithm-question]]></title>
    <url>%2F2018%2F01%2F27%2Falgorithm-question%2F</url>
    <content type="text"><![CDATA[主键都相同，选择排序和插入排序谁快选择排序：比较N*(N-1)/2,交换0；插入排序：比较N-1，交换0；插入排序更快 逆序数组，插入排序与选择排序选择排序：比较N(N-1)/2,交换N-1；插入排序：比较N\(N-1)/2,交换N*(N-1)/2；插入排序更快]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort-algorithm]]></title>
    <url>%2F2018%2F01%2F23%2Fsort-algorithm%2F</url>
    <content type="text"><![CDATA[选择排序一般用于小型数组1234567891011public static void selection(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++)&#123; int min = i; for (int j = i + 1 ; j &lt; a.length; j++)&#123; if (a[min].compareTo(a[j]) &gt; 0)&#123; min = j; &#125; &#125; exch(a,min,i); &#125;&#125; 插入排序一般用于小型数组1234567public static void insertion(Comparable[] a)&#123; for (int i = 0; i &lt; a.length - 1; i++)&#123; for (int j = i ; j &gt; 0 &amp;&amp; a[j-1].compareTo(a[j]) &gt; 0 ; j--)&#123; exch(a,j-1,j); &#125; &#125;&#125; 希尔排序内循环是插入排序，第一个for循环相当于完成了所有h有序数组的插入排序。比较顺序是： 第一个h有序数组的前一位插入排序 第二个h有序数组的前一位插入排序直到第h个有序数组的前一位插入排序 第一个h有序数组的前两位插入排序直到第h个有序数组的前两位插入排序 同理，直到第h个有序数组的所有位数插入排序 下面程序中的h不断减小直到为1，这个时候数组就是有序的了。这个程序中，h = 3*h +1,即1，4，13·····，这个序列叫递增序列，递增序列的选择有很多，可以在运行时计算得到，也可以保存在数组中。递增序列的选择会直接影响希尔排序的性能，在普通情况下，h = 3*h +1足够满足我们。希尔排序的优势在于可以处理中型数组，且不会占用额外的空间。希尔排序与选择排序和插入排序相比，希尔排序也可以用于大型数组。123456789101112public static void shell(Comparable[] a)&#123; int h = 1; int N = a.length; while(h &lt; N/3) h = h*3 + 1; while (h&gt;=1) &#123; for (int i = h; i &lt; N; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; a[j].compareTo(a[j-h]) &lt; 0; j -= h) exch(a,j,j-h); &#125; h = h/3; &#125;&#125; 归并排序归并排序，时间复杂度为NlogN，它的主要缺点是需要额外空间，切额外空间的大小与N成正比。123456789101112131415161718192021222324252627282930public class Merge &#123; private static Comparable[] aux; public static void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; sort(a, 0, a.length - 1); &#125; //自顶向下递归进行归并排序 private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; sort(a,lo,lo + (hi - lo)/2); sort(a,lo + (hi - lo)/2 + 1,hi); merge(a,lo,hi,lo + (hi - lo)/2); &#125; //归并方法 private static void merge(Comparable[] a, int lo, int hi, int mid)&#123; for (int i = lo; i &lt;= hi; i++)&#123; aux[i] = a[i]; &#125; int i = lo; int j = mid + 1; for (int k = lo; k &lt;= hi; k++)&#123; if (j &gt; hi) a[k] = aux[i++]; else if (i &gt; mid) a[k] = aux[j++]; else if (aux[i].compareTo(aux[j])&gt;=0) a[k] = aux[j++]; else if (aux[i].compareTo(aux[j])&lt;0) a[k] = aux[i++]; &#125; &#125;&#125; 归并排序的优化 对于小规模的数组不再递归，而使用简单的选择排序或者插入排序，因为这两种排序在小规模数组上速度很可能比归并快，一般情况下可以将归并排序缩短10%到15%。在子数组长度小于一定值时（这里是4），使用插入排序。 1234567891011121314151617private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; if ((hi - lo) &lt; 4)&#123; insertion(a, lo, hi); return; &#125; sort(a,lo,lo + (hi - lo)/2); sort(a,lo + (hi - lo)/2 + 1,hi); merge(a,lo,hi,lo + (hi - lo)/2);&#125;public static void insertion(Comparable[] a, int lo, int hi)&#123; for (int i = lo + 1; i &lt;= hi; i++)&#123; for (int j = i ; j &gt; lo &amp;&amp; a[j-1].compareTo(a[j]) &gt; 0 ; j--)&#123; exch(a,j-1,j); &#125; &#125;&#125; 归并时两个子数组，如果左半边的最大值小于右半边的最小值，那么不用归并 1234567891011private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; if ((hi - lo) &lt; 4)&#123; insertion(a, lo, hi); return; &#125; sort(a,lo,lo + (hi - lo)/2); sort(a,lo + (hi - lo)/2 + 1,hi); if (a[lo + (hi - lo)/2].compareTo(a[lo + (hi - lo)/2 + 1]) &lt; 0) return; merge(a,lo,hi,lo + (hi - lo)/2);&#125; 为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。 下面代码是实现。实现的核心在于： 1) 每一层递归中，不论是使用插入排序，还是因为左半边右半边已经有序不需要归并，还是需要归并，都要保证dest的正确有序。2) 进入下一层递归时，源数组和辅助数组角色交换。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Merge &#123; public static void sort(Comparable[] a)&#123; Comparable[] aux = a.clone(); //注意，要把a放在dest位置上，否则源数组会少一次归并操作 sort(aux,a,0, a.length - 1); &#125; private static void sort(Comparable[] src, Comparable[] dest, int lo, int hi)&#123; if (hi &lt;= lo) return; if ((hi - lo) &lt; 4)&#123; //注意，小数组的插入排序要在dest上进行 insertion(dest, lo, hi); return; &#125; //在进行下一层归并时，交换源数组和辅助数组，避免复制操作 sort(dest,src,lo,lo + (hi - lo)/2); sort(dest,src,lo + (hi - lo)/2 + 1,hi); if (src[lo + (hi - lo)/2].compareTo(src[lo + (hi - lo)/2 + 1]) &lt; 0) &#123; //如果从源数组判断此次不需要归并，那么也将相应位置元素copy到dest，即保证dest的元素正确有序 System.arraycopy(src,lo,dest,lo,hi - lo + 1); return; &#125; //归并排序时保证dest的正确有序，这样在返回上一层归并时，这里的dest可以作为上一层的辅助数组 merge(src,dest,lo,hi,lo + (hi - lo)/2); &#125; private static void merge(Comparable[] src, Comparable[] dest, int lo, int hi, int mid)&#123; int i = lo; int j = mid + 1; for (int k = lo; k &lt;= hi; k++)&#123; if (j &gt; hi) dest[k] = src[i++]; else if (i &gt; mid) dest[k] = src[j++]; else if (src[i].compareTo(src[j])&gt;=0) dest[k] = src[j++]; else if (src[i].compareTo(src[j])&lt;0) dest[k] = src[i++]; &#125; &#125; public static void insertion(Comparable[] a, int lo, int hi)&#123; for (int i = lo + 1; i &lt;= hi; i++)&#123; for (int j = i ; j &gt; lo &amp;&amp; a[j-1].compareTo(a[j]) &gt; 0 ; j--)&#123; exch(a,j-1,j); &#125; &#125; &#125;&#125; 上面的是自顶而下的归并，还有自底向上的归并。递归实现的归并排序是算法设计中分治思想的典型应用，即将一个大问题分解成小问题分别解决，再用小问题的答案来解决大问题。在自顶而下的递归中就是这样，在每一次递归中，都降低了数组长度，最后用最深处的微型数组归并结果，反过来求上层递归的答案。其实，由于我们知道上层递归是如何使用下层递归的结果的，所以这里的归并排序可以不使用递归，利用循环，自底向上，先将卫星数组归并，比如先归并长度为1的数组，再归并长度为2的长度为4的，这样下去，将整个数组归并。这样的代码量更少。12345678910public static void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; int N = a.length; for (int sz = 1; sz &lt; N; sz *= 2)&#123; for (int lo = 0; lo &lt; N - sz; lo = lo+sz*2)&#123; int hi = min(lo+sz*2-1,N-1); merge(a,lo,hi,lo + (hi-lo)/2); &#125; &#125;&#125; 基于比较的排序算法我们讨论的都是基于比较的排序算法，这些算法的复杂度有上限。命题：没有任何基于比较的算法能够保证使用少于lg(N!)~NlgN次比较将长度为N的数组排序。证明：首先假设没有重复的主键，因为任何排序算法都应该能够处理这种情况。使用二叉树表示所有的比较。上图是N=3的比较树，叶子节点表示排序完成，内部节点表示a[i]和a[j]的一次比较操作，左子树表示a[i]小于a[j]时进行的其他比较，右子树表示a[i]大于a[j]时的其他比较。从根节点到叶子节点的所有路径表示在实际排序中，可能遇到的所有比较。比较树中至少应该有N!个叶子节点，因为长度为N的数组，共有N!中排列方式，如果某个比较树的叶子节点小于N!,那么肯定有一些排列顺序被遗漏，基于这个比较树的算法在使用时，对于某些输入就无法正确的排序。在排序算法中，我们通常关心比较的次数，而最多比较次数就是比较树的高度。高为h的二叉树最多叶子节点$2^h$，比较树中的叶子节点（就是所有的比较路径）数量N!,那么就有$N!\log{N!}$上面的式子告诉我们在设计排序算法时所能达到的最佳效果。即比较次数最低是NlgN。 快速排序归并排序虽然将算法时间复杂度降低到NlogN，但是需要一个与N成正比的辅助栈，而快排则避免了这个缺点，快排是原地排序，只需要一个很小的辅助栈。快排的优点： 时间复杂度为NlogN 原地排序，只需要一个很小的辅助栈 内循环比大多数排序都要小 归并和希尔排序比快排慢，原因就是他们在内循环中还有移动复制操作。缺点： 脆弱，在实现时要非常小心才能避免低劣的性能，许多错误都能导致快排的性能只有平方级别。比如在切分不平衡时可能导致快排极为低效，例如第一次从最小元素切分，第二次从第二小元素切分，这样每次只能移动一个元素，导致一个大数组需要切分很多次，事实上，这种极端情况下会比较$$\frac{1}{2}N^2$$次，我们可以在快排前将数组打乱以避免这种情况。 快排效率依赖切分数组的效果，最好的情况是每次都能将数组对半分。12345678910111213141516171819202122232425262728public class Quick &#123; public static void sort(Comparable[] a)&#123; sort(a,0,a.length-1); &#125; private static void sort(Comparable[] a, int lo, int hi)&#123; if (lo&gt;=hi) return; int j = partition(a,lo,hi); sort(a,lo,j-1); sort(a,j+1,hi); &#125; private static int partition(Comparable[] a, int lo, int hi)&#123; Comparable tmp = a[lo]; //因为lo位置的元素作为切分元素，所以这里本可以设置为lo+1，之所以设置为lo，是为了后面的先++lo做准备 int lf = lo; //同理这里设置为hi+1，是为后面先--ri做准备 int ri = hi + 1; while(true)&#123; //先判断界限，避免溢出，不停循环至第一个大于切分元素的位置 while (++lf &lt;= hi &amp;&amp; tmp.compareTo(a[lf]) &gt; 0); while (--ri &gt;= lf &amp;&amp; tmp.compareTo(a[ri]) &lt; 0); if (lf&gt;=ri) break; exch(a,lf,ri); &#125; exch(a,lo,ri); return ri; &#125; 算法改进 切换到插入排序，在微型数组长度较短的情况下，使用插入排序比继续递归要快，一般长度在5-15之间(大多数基于递归的排序都可以这样做)。 1234567891011121314private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &gt; lo + 10) insertion(a,lo,hi); if (lo&gt;=hi) return; int j = partition(a,lo,hi); sort(a,lo,j-1); sort(a,j+1,hi);&#125;private static void insertion(Comparable[] a, int lo, int hi)&#123; for (int i = lo; i &lt;= hi; i++)&#123; for (int j = i; j &gt; lo &amp;&amp; a[j].compareTo(a[i]) &gt; 0; j--)&#123; exch(a,i,j); &#125; &#125;&#125; 三取样切分，使用子数组中一小部分元素的中位数来切分，人们发现将取样大小设为3并用大小居中的元素切分效果最好。还可以将切分元素放在数组末尾作为哨兵来去掉数组边界检查。 123456789101112131415161718192021private static int partition(Comparable[] a, int lo, int hi)&#123; int x = median(a,lo,lo+1&gt;a.length-1?a.length-1:lo+1,lo+2&gt;a.length-1?a.length-1:lo+2); Comparable tmp = a[x]; exch(a,x,lo); int lf = lo; int ri = hi + 1; while(true)&#123; while (++lf &lt;= hi &amp;&amp; tmp.compareTo(a[lf])&gt;0); while (--ri &gt;= lf &amp;&amp; tmp.compareTo(a[ri]) &lt; 0); if (lf&gt;=ri) break; exch(a,lf,ri); &#125; exch(a,lo,ri); return ri;&#125;private static int median(Comparable[] x, int a, int b, int c)&#123; return x[a].compareTo(x[b])&gt;0 ? (x[a].compareTo(x[c])&gt;0 ? (x[b].compareTo(x[c]) &gt; 0 ? b : c):a) : (x[a].compareTo(x[c])&gt;0 ? a : (x[b].compareTo(x[c]) &gt; 0 ? c : b));&#125; 三项切分快速排序 对于包含大量重复元素的数组，使用三项切分将排序时间从线性对数降低到线性级别。性能优于普通快排123456789101112131415161718public static void sort3Ways(Comparable[] a, int lo, int hi)&#123; if (lo&gt;=hi) return; Comparable tmp = a[lo]; int i = lo+1; //始终等于tmp的最左位置 int lt = lo; //一次循环结束后，gt刚好在等于tmp的最右位置 int gt = hi; while(i&lt;=gt)&#123; int m = tmp.compareTo(a[i]); if (m&gt;0) exch(a,i++,lt++); //这里的i没有+1，是因为从右边换过来的item大小未知，需要在进行一次比较 else if (m&lt;0) exch(a,i,gt--); else i++; &#125; sort3Ways(a,lo,lt-1); sort3Ways(a,gt+1,hi);&#125; 12345private static void exch(Comparable[] source,int i, int j)&#123; Comparable tmp = source[j]; source[j] = source[i]; source[i] = tmp;&#125; 优先队列队列中的元素有优先级，最大有限队列，最小优先队列。以最大优先队列为例，这样的数据结构要求支持两种操作，删除最大元素和插入元素，这里我们学习基于二叉堆数据结构的一种优先队列的经典实现方式，用数组保存元素并按照一定条件排序，以高效的实现删除最大元素和插入元素操作。插入一列元素后一个一个的删除最小元素，就可以完成排序，堆排序算法就是源于优先队列的实现 实现数组实现（无序）参考下压栈的实现，插入时直接将元素插入到数组内，删除最大值时使用一个内循环获得最大元素，然后将最大元素与边界元素互换并删除最大元素。 数组实现（有序）插入时将所有较大元素向右移动一格保持数组有序，这样最大元素始终在边界 链表表示与数组实现类似，要么插入耗时删除高效，要么插入高效删除耗时 使用无序实现是惰性方法，我们仅在需要的时候才找出最大元素，使用有序实现是积极方法，在插入时保证有序。对于简单的队列和栈，所有操作都可以在常数时间内完成，而优先队列的最坏情况会达到线性时间。而基于数据结构堆的实现能保证插入和删除操作都能更快的执行。 二叉堆数据结构二叉堆的定义：当一个二叉树的每个节点都大于等于他的两个子节点，它被称为堆有序，就是二叉堆。根节点最大 数组实现二叉堆位置k的节点的父节点的位置是$\biggl\lfloor\frac{k}2\biggr\rfloor$，而他的两个子节点分别是2k和2k+1。这样在数组中使用索引在树中移动，很方便。根节点在数组索引为1的位置（不使用第一个位置）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MaxPQ &#123; private Comparable[] pq; private int N = 0; public MaxPQ(int maxN)&#123; pq = new Comparable[maxN + 1]; &#125; //插入操作，先插入到二叉堆最后位置，再上浮，保证堆有序 public void insert(Comparable a)&#123; pq[++N] = a; swim(N); &#125; //当元素比父节点大时，上浮保证堆有序 private void swim(int k)&#123; while(k&gt;1 &amp;&amp; pq[k].compareTo(pq[k/2]) &gt; 0)&#123; exch(k,k/2); k = k/2; &#125; &#125; //当元素比子节点小时，下潜保证堆有序 private void sink(int k)&#123; while (2*k&lt;=N)&#123; int j = 2*k; if (j&lt;N &amp;&amp; pq[j].compareTo(pq[j+1]) &lt; 0) j++; //如果父节点不比子节点小，结束循环 if (pq[k].compareTo(pq[j])&gt;0) break; exch(k,j); k = j; &#125; &#125; //删除最大节点分两步，现将最后的节点与首节点交换，再下潜首节点 public Comparable delMax()&#123; Comparable max = pq[1]; exch(1,N--); pq[N+1] = null; sink(1); return max; &#125; private void exch(int a, int b)&#123; Comparable tmp = pq[a]; pq[a] = pq[b]; pq[b] = tmp; &#125;&#125; 对于一个含有N个元素的基于堆的优先队列，插入操作只需不超过lgN+1次比较，删除最大元素需要不超过2lgN次比较。 优化二叉堆 调整数组大小 索引优先队列，暂不研究 堆排序我们可以把任意优先队列变成一种排序方法：将所有元素插入一个最小优先队列，再重复删除最小元素即可。我们基于堆实现一种排序方法。 基于堆的排序 用数组实现堆，首先将所有元素直接插入数组中 将前半部分元素倒序做下潜操作 从最后一个元素开始逐个做下潜操作12345678910111213141516171819202122232425262728public void sort(Comparable[] a)&#123; //N是有效元素大小（除去首位） int N = a.length-1; for (int i = N/2; i &gt;= 1; i--)&#123; sink(a,i,N); &#125; //将首位与最后一个交换，交换后，N减1（这是因为交换后最大元素已经在最后了，之后的操作与最后的最大元素无关），再做sink操作， while(N&gt;1)&#123; exch(a,N--,1); sink(a,1,N); &#125;&#125;private void exch(Comparable[] pq,int a, int b)&#123; Comparable tmp = pq[a]; pq[a] = pq[b]; pq[b] = tmp;&#125;private void sink(Comparable[] pq,int k,int N)&#123; while (2*k&lt;=N)&#123; int j = 2*k; if (j&lt;N &amp;&amp; pq[j].compareTo(pq[j+1]) &lt; 0) j++; if (pq[k].compareTo(pq[j])&gt;0) break; exch(pq,k,j); k = j; &#125;&#125; 堆排序优化先下沉再上浮：在下沉过程中可以将较大的元素直接放入堆底，再将其上浮，这样可以减少比较次数。堆排序是目前已知的唯一能够同时最优利用空间和时间的方法。在最坏的情况下也能保证2NlgN次比较和恒定的额外空间。 各算法对比]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析]]></title>
    <url>%2F2018%2F01%2F21%2Falgorithm-analysis%2F</url>
    <content type="text"><![CDATA[算法分析一个程序开始运行到结束需要多少时间，需要使用多少内存，都需要进行算法分析，以求算法达到相对优的性能。算法的时间复杂度和空间复杂度合称为算法的复杂度。 时间复杂度时间频度一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 时间复杂度在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 一般情况下，$f(n)=N^b(\log{N})^c$ 时间频度不同，但时间复杂度可能相同。如：T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。 指数阶0(2n)，显然，时间复杂度为指数阶0(2n)的算法效率极低，当n值稍大时就无法应用。 求时间复杂度 如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。1234567x=91; y=100;while(y&gt;0)&#123; if(x&gt;100) &#123; x=x-10; y--; &#125; else x++;&#125; 解答： T(n)=O(1)，这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到n没有?没。这段程序的运行是和n无关的，就算它再循环一万年，我们也不管他，只是一个常数阶的函数 当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)(其实就是时间频度的最高阶,低阶忽略)决定的。12345x=1;for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x++; 该程序段中频度最大的语句是第五行x++，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析第五行的执行次数：则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3) 算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。在数值A[0..n-1]中查找给定值K的算法大致如下：1234i=n-1;while(i&gt;=0&amp;&amp;(A[i]!=k)) i--;return i; 此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。 其实在进行算法时间复杂度分析时，我们是假设与输入状态无关的，如果无法保证这一点，那就应该对算法做一下处理： (1)对最坏情况下的性能保证(2)使用随机化算法、操作序列、均摊分析等方法，详见算法p125 时间复杂度评价性能有两个算法A1和A2求解同一问题，时间复杂度分别是T1(n)=100n2，T2(n)=5n3。 （1）当输入量n＜20时，有T1(n)＞T2(n)，后者花费的时间较少。 （2）随着问题规模n的增大，两个算法的时间开销之比5n3/100n2=n/20亦随着增大。即当问题规模较大时，算法A1比算法A2要有效地多。 它们的渐近时间复杂度O(n2)和O(n3)从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。 空间复杂度一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。 固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。一个算法所需的存储空间用f(n)表示。S(n)=O(f(n)) 其中n为问题的规模，S(n)表示空间复杂度。 两者关系在实际算法实现中，时间和空间复杂度通常处于相对立的形势，经常会出现牺牲空间提高时间情况。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atom_tips]]></title>
    <url>%2F2018%2F01%2F10%2Fatom-tips%2F</url>
    <content type="text"><![CDATA[1 快捷键 ctrl+tab切换标签页 ctrl+w 关闭当前标签页，ctrl+k ctrl+w关闭所有标签页 ctrl+shift+\ 切换到目录树，并定位到当前文件,在目录树中切换文件，按右箭头即可打开并回到工作区 ctrl+k ctrl+left arrow 或者 ctrl+k ctrl+right arrow可以在目录树和工作区切换]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2018%2F01%2F08%2Falgorithm%2F</url>
    <content type="text"><![CDATA[1 开平方求常数a的开平方，其实就是对于函数$f(x) = x^2 -a$求解$f(x) = 0$的$x$。这个函数在$x&gt;0$时单调递增，可以使用牛顿法逐步逼近。如图所示，先取一个值$x_0$,假设$x_0$是解，判断$x_0$不是解之后，使用$x_0$点的倒数求$x_1$，以此方式逐渐逼近正解。示例代码如下：123456789static double sqrt(double s)&#123; //当所求解与小于该值时，认为已求得正解 double err = 1E-15; double t = s; while(Math.abs(t - s/t) &gt; err)&#123; t = (t + s/t)/2; &#125; return t;&#125; 2 float的表示方法java中flaot采用IEEE 754标准，四字节32位0-31，分为三部分，符号位，指数位，尾数位。|符号位 | 指数位 | 尾数位 ||——-|——-|——-|| 1bit | 8 bit | 23 bit|(1).符号位(S)：最高位（31位）为符号位，表示整个浮点数的正负，0为正，1为负；(2).指数位(E)：23-30位共8位为指数位。根据IEEE754说明，指数的底数可能为2或者10(java中使用2)，规定指数位减去127为指数，取值范围：-127~128，表达式为：$2^{E−127}$。另外，标准中，还规定了，当指数位8位全0或全1的时候，浮点数为非正规形式（这个时候尾数不一样了），所以指数位真正范围为：-126~127。(3).尾数位(M)：0-22位共23位为尾数位，表示小数部分的尾数，即形式为1.M或0.M，至于什么时候是1，什么时候是0，则由指数和尾数共同决定。 小数部分最高有效位是1的数被称为正规（规格化）形式。小数部分最高有效位是0的数被称为非正规（非规格化）形式，其他情况是特殊值。 最终float的值 = $(-1)^{S} \cdot 2^{E-127} \cdot (1.M)$。所以java中的float这样表示，以8.25为例：首先将8.25转换为二进制1000.01，注意转换过程中整数部分与小数部分的区别，表示称二进制的科学计数法为$1.0001\cdot2^3$，也就是说,任何一个数都的科学计数法表示都为$1.xxxx\cdot2^3$，因为任何情况下，首位必为1，所以就省略首位1，将xxxx作为尾数位，所以虽然尾数位是23位，其实表示的是24位。然后指数3+127=130，把130转换成二进制保存在指数位。符号位为1。所以8.25在内存中的表达就是：这样就能解释float的精度问题了，float的有效位数由尾数位决定，23位尾数加上省略的尾数位最高位1，共24位，$2^24 = 16777216$，也就是说最高有效位数8位，但是16777216并不能覆盖所有8位数，所有最高有效位数是7位。另外，由于在计算过程中会出现四舍五入的情况，所以，在float中，前六位是绝对精确地，第七位可能不精确。总结，float有效位数7位，精确度6位。 3 判断素数原理：合数的最小质因子一定小于等于它的平方根。1234567static boolean isPrime(int n)&#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt;= n; i++)&#123; if (n%i == 0) return false; &#125; return true;&#125; 4 调和数列与调和级数调和数列是自然数的倒数构成的数列，其前n项和就是调和级数。求调和级数直接便利求和 5 补码计算原理在计算机中，所有的数都是按照补码来存储并计算的，那么什么是补码呢？要完美的理解补码，就要完全抛开课本上以及博客上的关于原码高位不变低位取反加一的论调，并不是说他们是错的，只是取反加一以及最高位作为符号位的说法更适合计算方便，事实上计算机的计算方式确实是高位不变低位取反加一，但这种理解并不准确，相反完全增加了理解补码计算的难度。那么如何理解补码呢？首先，要理解模。以钟表为例，假如现在是三点，如果要求将时间回退五个小时，你会怎么办？两种方法： 顺时针拨动时针7格 逆时针拨动时针5格 第二个方法理解起来非常简单，回退嘛，那就逆时针，这里要着重说的是第一种，为什么顺时针也能达到逆时针的效果呢？其实，顺时针拨动7格，就是拨动(12-5)格，这里的12就是模，模的存在，将处于模之内的数构成一个环，环内的数都可以通过正向增长或逆向增长的方式变为环内的另一个数(其实就是取膜运算%)。若数超过模，那么就做取模处理，所以值永远小于模。如果时钟的例子不明朗，那么以十进制为例，以10为模，那么，6加7是3，6减3也是3，这就是模10的“环”。那么计算机中为什么要利用模来进行计算呢？因为计算机中只有加法计算，没有减法，任何减法运算都必须转换为加上一个负数来进行。这就带来一个问题，怎么表示这个负数，并且保证计算结果正确呢？这个时候就要使用补码了。现在知道，模有两个性质： 存在一个环，当数持续增长到溢出时，会回到最小值 模内的数无论做多少次加减，其值始终小于模，模类似一个极值 利用上述两个性质，我们可以将计算机的减法运算简化。在模的范围内，两个相加等于的模得数互为补数，以模10为例，1和9，2和8都互为补数，那么，模范围内的减法$a-b$就可以变换为$a+b\text{的补数}$，还是以模10为例$$5-1 = 5 + (10 -1) = 14 (1)$$14溢出要取模，最终结果是4，计算正确。其实这个过程里的+10就相当于绕环一圈回到正确位置，并不影响计算结果，但也因为这一圈，消除了减法，转换成了加法计算。那么，在计算机内是如何实现的呢？计算机中实现时，牵扯到一个问题，那就是式1的(10-1)在内存中该如何表示，因为既然我们要使用$a+b\text{的补数}$的方式计算，那么$b\text{的补数}$必定要满足两个要求： 避开减法运算，不能像式1那样还存在减法 在二进制中能直接通过位运算得到补数 于是，大牛们想到了一个完美的办法，映射。我们知道，长度为n的二进制数范围是$\left[0,2^n-1\right]$(后面成为集合Z)，共$2^n$个数,模为$2^n$。现在我们要表示$\left[-2^{n-1},2^{n-1}-1\right]$这个范围的数，也就是要把$\left[-2^{n-1},2^{n-1}-1\right]$内所有的数刚好映射到$\left[0,2^n-1\right]$上。主要分两部分： 对于在$\left[0,2^{n-1}-1\right]$范围内的数，可以保持原样(这个对应求补码的正数不变) 对于在$\left[-2^{n-1},0\right)$的数，使用补数映射到Z上，即对于x，在Z上有$2^n-\left|x\right|$与之对应，也就是说负数用她的绝对值的补数来表达。这也解释了为什么$-2^{n-1}$可以使用$1000 0000 …$这样的二进制来表达，因为刚好映射上了啊！这个映射过程其实刚好对应求负数补码的过程：符号位不变并取反加一，但是事实上，在补码的计算中，并不存在符号位。 那么，实际计算中，补码如何起作用呢？在上面的十进制例子中，式1，5-1的计算变换为5 + (10 -1)，加10相当于绕环一圈，计算结果14溢出取模后结果是4。也就是说，使用补数进行计算，只要真实结果没有溢出，那么可以直接拿补数相加的结果作为真实结果。回到二进制，在任意的二进制加减法中，因为使用了上述原理(就是补码)计算，所以补码的计算结果可以直接作为正确结果。需要注意的是，不同于上述十进制的例子，在计算机中，如果补码计算结果在$\left[0,2^{n-1}-1\right]$内，那么，所得结果即为正确答案，如果补码计算结果在$\left[-2^{n-1},0\right)$内，那么，所得结果需要做一个反向映射才是正确答案，但是内存中存储的始终是未做反向映射的那个值。举例来说：在8位计算机中，要把$\left[-128,127\right]$映射到$\left[0,255\right]$上，那么30-100其实就是30+(256-100) = 186,注意内存中始终存储的是186，但是当我们要读出来这个数时，cpu做了反映射 256-186 = 70，70就是所求的正确答案。 tip：其实映射的过程就是一个函数，函数图像为： 函数值为补码，x为真实值，内存中按照补码存储，需要真实值时做反映射。 所谓的符号位与取反加一我们知道，书本中说到补码的时候，都会从遵从原码反码补码的顺序，好像这三者是有着递进关系的，实际上并不是这样。但是我们所说的映射过程和由原码求补码是有一定关联的，下面以8位二进制为例作出解释。首先8位二进制在内存中共有0000 0000到1111 1111共256中情况，可以表示[-128,127]的范围，根据上述的映射原理，这个范围要分两个部分对待[-128,0)和[0,127]：对于数字2，2位于上图右半部分，补码映射函数是$f(x) = x$，其实这个函数映射关系就对应了书本上的正数的补码不变，所以补码是0000 0010,注意这个过程中并没有通过原码=&gt;补码来转换，而是直接用了映射，刚好对应。对于数字-2，-2位于上图左半部分，补码映射函数$f(x) = 256 - \left|x\right|$，具体计算是什么样呢？ 1234561 0000 0000 - 0000 0010= 1111 1111 + 0000 0001 - 0000 0010= (1111 1111 - 0000 0010) + 0000 0001= (1000 0000 + 0111 1111 - 0000 0000 - 0000 0010) + 0000 0001//第一个括号表示高位不变，第二个括号表示低位取反，最后加一= (1000 0000 - 0000 0000) + (0111 1111 - 0000 0010) + 0000 0001 这说明所谓的取反加一并没有什么神秘，只是二进制中求补数的一种便捷的分配算法而已。 关于反码我们知道，书本中说到补码的时候会从反码讲解过来，好像补码由反码加一而来，其实这么理解并不合适。上面已经说过补码的映射原理，其实求反码也是一个映射过程。还是以8位二进制为例，求反码的过程其实就是求原数字关于255的补数(对应到补码的模来理解，只不过这里的模是255)。 对于-2，反码计算 123451111 1111 - 0000 0010= 1111 1111 - 0000 0010= (1000 0000 + 0111 1111 - 0000 0000 - 0000 0010)//第一个括号表示高位不变，第二个括号表示低位取反，同样取反的言论只是一个计算而已，真正起作用的是求补数= (1000 0000 - 0000 0000) + (0111 1111 - 0000 0010) 那么求反码的过程还是把[-127,127]映射到[0,255]上。但是8位是可以表示256个数的，而模为255的时候只能表示255个数。多出一个怎么办？我们观察到，[-127,-1]会映射到[128，254]上，那反码255，也就是1111 1111表示什么呢？实际上，1111 1111在加一就是0000 0000，在反码计算中，这两个都可能代表0，一个是所谓的+0，一个是所谓的-0。也就是说，相比于补码，由于反码的模范围比它要表达的数范围大1，模的环出现了”裂缝”，被两个0打断，这也是计算机中补码优于反码计算的原因。 以2-2为例，解释两个0的现象 12342-2= 0000 0010 + 1111 1111 - 0000 0010= 0000 0010 + 1111 1101= 1111 1111 5 int溢出根据补码的映射与模环的理解，对于int的溢出后的值，可以这样求，int最大值2147483647： 比如2147483648，位于图像左半边，根据映射关系2147483648表示(2147483648 - 4294967296) = -2147483648 比如2147483649，位于图像左半边，根据映射关系2147483649表示(2147483649 - 4294967296) = -2147483647 比如4294967297，先取模4294967297%4294967296为1，位于图像右半边，根据映射关系4294967297表示1 关于int溢出例子Math.abs(-2147483648) = 2147483648，2147483648溢出，根据环，最后结果为-2147483648 6 String的intern()7 1/0与1.0/0.0前者是devide by zero异常，后者是无限大。1/0出现异常的原因是，1除以0在计算机中无法计算，除法过程会无限持续，另外，即使默认1/0结果是无限大或者NAN也不行，因为在int中没有定义正无穷负无穷和nan，整数是有限的。1.0/0.0结果是无穷大，这是因为float中的0并不完全是0，根据float在内存中的表达方式，0.0是极其接近0的一个小值，所以首先这个除法过程是可以进行的。另外在float中也定义了正负无穷，所以有结果。 8 float的三个值正无穷，负无穷，NaN。1.0/0.0 = POSITIVE_INFINITY(正无穷),It is equal to the value returned by Float.intBitsToFloat(0x7f800000).-1.0/0.0 = NEGATIVE_INFINITY(负无穷),It is equal to the value returned by Float.intBitsToFloat(0xff800000).0.0/0.0 = NaNPOSITIVE_INFINITY - POSITIVE_INFINITY = NaN另外需要注意的是，Float的MAX_VALUE和MIN_VALUE表示的是float所能表示的最大正数和最小正数(不是最小的负数) double也有相似的三个值。 9 负整数除法和模-14/3 = -4 余 -214/-3 = -4 余 2-14/-3 = 4 余 -2遵循向零取整：什么意思呢？比如两个正数10和4相除，商2.5，向零取整为2，那么余10-42 = 2；同理，在负数加入进来后，也遵循向零取整，如 -14/3，商-4.67，向零取整-4，那么余-14-(-43) = -2;再如14/-3商-4.67，向零取整-4，余14-(-3 * -4) = 2; 负数的模与上面同理。 10 位运算符1&amp; | ^ 11 求整数的二进制字符串1234567public static String getBanaryString(int n)&#123; String result = &quot;&quot;; for(int i = n; i &gt;= 1 ; i /= 2)&#123; result = i%2 + result; &#125; return result;&#125; 12 递归计算ln(N!)这个比较简单123456public static double calLn(int n)&#123; if(n == 1)&#123; return 0; &#125; return calLn(n-1) + Math.log(n);&#125; 13 递归计算二项分布算法4中的程序123456789public static double bino(int n, int k, double p)&#123; if(n == 0 &amp;&amp; k == 0)&#123; return 1; &#125; if(n &lt; 0 || k &lt; 0)&#123; return 0; &#125; return p*bino(n-1,k-1,p) + (1-p)*bino(n-1,k,p);&#125; 在出口出增加$n]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java小贴士]]></title>
    <url>%2F2018%2F01%2F08%2Fjava-tips%2F</url>
    <content type="text"><![CDATA[1 值传递与引用传递12345678910111213141516171819202122232425262728int num = 10;String str = &quot;hello&quot;//第一个例子：基本类型void foo(int value) &#123; value = 100;&#125;foo(num); // num 没有被改变//第二个例子：引用类型void foo(String text) &#123; text = &quot;windows&quot;;&#125;foo(str);// str 也没有被改变，这个过程其实是先分配一块内存并创建一个新的引用text，再将text指向了str的值hello，text = &quot;windows&quot;这个操作又将text指向了值为windows的对象，因此str没有改变。第三个第四个例子也可以这样理解。//第三个例子：提供了改变自身方法的引用类型StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder.append(&quot;4&quot;);&#125;foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。//第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder = new StringBuilder(&quot;ipad&quot;);&#125;foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。 2 变量的存储位置3 defaultjava8中，新增一个关键字default，它允许接口中的方法拥有方法体,实现该接口的类bu可以不实现该方法。这个关键字在集合框架中使用过。12345public interface Default &#123; default public void method()&#123; System.out.println(&quot;method in interface&quot;); &#125;&#125; 123456789101112public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 4 transient被transient修饰的变量不会被序列化 5 volatilecas技术的应用，在ConCurrentHashMap中的使用 6 锁机制synchronized与lock 7 线程间通信轮询joincountdownlatchCyclicBarrier返回结果 futuretask 8如果在一个线程计算过程中不允许有更大的本地方法栈，那么JVM就抛出StackOverflowError 如果本地方法栈可以动态地扩展，并且本地方法栈尝试过扩展了，但是没有足够的内容分配给它，再或者没有足够的内存为线程建立初始化本地方法栈，那么JVM抛出的就是OutOfMemoryError。 9 handler机制A. Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分组成的。B. Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。C. Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。D. 当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。 E. 当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。 10 activity栈管理AMS activitymanagerservice 负责activityrecord taskrecord activitystack都是ams抽象出来的概念 11 网络okhttp 12 concurrenthashmap13 IPC14 FutureFutureTask 实现了Future和Runnable，FutureTask本质还是一个runnable，但是FutureTask中有Callable的引用，在线程执行run时，会调用call，所以对于FutureTask来说，真正的执行位置是callable AsyncTask也是使用了Future，有两个线程池，一个用于真正执行，有核心线程数和最大线程数的限制，另一个维护一个队列用于给任务排序。AsyncTask是序列执行任务的。一个应用中所有的AsyncTask共享同一个线程池。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中boolean类型的大小]]></title>
    <url>%2F2018%2F01%2F08%2Fboolean-size-in-java%2F</url>
    <content type="text"><![CDATA[在Java中，int，float，double等基本类型所占字节大小都有明确说明，唯独boolean类型没有，那么boolean类型的大小究竟是多少呢？ Java SE Specification(java 8)先看java官方规范中怎么说，规范网址，下面是摘抄： The boolean TypeAlthough the Java Virtual Machine defines a boolean type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on boolean values. Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine int data type. The Java Virtual Machine does directly support boolean arrays. Its newarray instruction (§newarray) enables creation of boolean arrays. Arrays of type boolean are accessed and modified using the byte array instructions baload and bastore (§baload, §bastore). In Oracle’s Java Virtual Machine implementation, boolean arrays in the Java programming language are encoded as Java Virtual Machine byte arrays, using 8 bits per boolean element. The Java Virtual Machine encodes boolean array components using 1 to represent true and 0 to represent false. Where Java programming language boolean values are mapped by compilers to values of Java Virtual Machine type int, the compilers must use the same encoding.尽管java定义了boolean类型，但并没有提供更多的支持，也没有任何一种jvm有专用于boolean的虚拟机指令，事实上，java程序中的boolean都被编译成int类型，也就是说，单个的boolean类型在编译后占4个字节。jvm并不直接支持boolean类型的数组，boolean类型的数组其实是byte类型的数组，也就是说，boolean类型的数组编译后每个boolean元素是一个byte，也就是1个字节。boolen数组中使用1表示true，0表示false，需要注意的是，虽然在数组中使用byte表示boolena，但是一旦将其取出，那么走出数组的boolean必须转换成int类型，这在boolena数组的baload, bastore中有所体现。 #### 操作码baloadThe arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index must be of type int. Both arrayref and index are popped from the operand stack. The byte value in the component of the array at index is retrieved, sign-extended to an int value, and pushed onto the top of the operand stack. 将数组的某一byte元素取出转为int类型并push到栈上 操作码bastoreThe arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index and the value must both be of type int. The arrayref, index, and value are popped from the operand stack. The int value is truncated to a byte and stored as the component of the array indexed by index.将int类型数据截断为byte类型，并存储在在数组内 为什么这么设计the JVM uses a 32-bit stack cell, used to hold local variables, method arguments, and expression values. Primitives that are smaller than 1 cell are padded out, primitives larger than 32 bits (long and double) take 2 cells. This technique minimizes the number of opcodes, but does have some peculiar side-effects (such as the need to mask bytes). Primitives stored in arrays may use less than 32 bits, and there are different opcodes to load and store primitive values from an array. Boolean and byte values both use the baload and bastore opcodes, which implies that boolean arrays take 1 byte per element. opcodes就是操作码，也叫机内码，指令序列等，用来告诉CPU需要执行哪一条指令，上面的bastore就是操作码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity中使用shader增强视频]]></title>
    <url>%2F2018%2F01%2F03%2Frenderer-texture-with-shader%2F</url>
    <content type="text"><![CDATA[使用shader对视频texture做特效处理该功能主要在片元着色器中实现，考虑到是移动设备，因此要兼顾考虑效果和性能。在shader中的实现，这里只展示像素增强算法，关于shader的结构请看其他 变量_MainTex当前渲染的texture _MainTex_TexelSize_MainTex_TexelSize这个变量的从字面意思是主贴图 _MainTex 的像素尺寸大小，是一个四元数，是 unity 内置的变量，它的值为 Vector4(1 / width, 1 / height, width, height) _ColorBoost自定义关于亮度、对比度、饱和度、色弱调整的参数1&quot;_ColorBoost&quot;,(_brightness, cont, _saturate, _daltonize * 10f)); _Sharpen自定义关于锐化的参数1&quot;_Sharpen&quot;,(sharpen, _sharpenDepthThreshold, _sharpenClamp, _sharpenRelaxation) shader1234567891011121314151617181920212223242526272829303132333435363738394041uniform sampler2D _MainTex;uniform float4 _MainTex_TexelSize;uniform float4 _ColorBoost;uniform float4 _Sharpen;float getLuma(float3 rgb) &#123; const float3 lum = float3(0.299, 0.587, 0.114); return dot(rgb, lum);&#125;void beautifyPassFast(v2f i, inout half3 rgbM) &#123; half2 xInc = half2(_MainTex_TexelSize.x, 0); half2 yInc = half2(0, _MainTex_TexelSize.y); half lumaM = getLuma(rgbM); half3 rgbN = tex2D(_MainTex, saturate(i.uv + yInc)).rgb; half3 rgbS = tex2D(_MainTex, saturate(i.uv - yInc)).rgb; half3 rgbW = tex2D(_MainTex, saturate(i.uv - xInc)).rgb; half lumaN = getLuma(rgbN); half lumaW = getLuma(rgbW); half lumaS = getLuma(rgbS); half maxLuma = max(lumaN,lumaS); maxLuma = max(maxLuma, lumaW); half minLuma = min(lumaN,lumaS); minLuma = min(minLuma, lumaW) - 0.000001; half lumaPower = 2 * lumaM - minLuma - maxLuma; half lumaAtten = saturate(_Sharpen.w / (maxLuma - minLuma)); rgbM *= 1.0 + clamp(lumaPower * lumaAtten * _Sharpen.x, -_Sharpen.z, _Sharpen.z); // 3. Vibrance half3 maxComponent = max(rgbM.r, max(rgbM.g, rgbM.b)); half3 minComponent = min(rgbM.r, min(rgbM.g, rgbM.b)); half sat = saturate(maxComponent - minComponent); rgbM *= 1.0 + _ColorBoost.z * (1.0 - sat) * (rgbM - getLuma(rgbM)); // 5. Final contrast + brightness rgbM = (rgbM - halves) * _ColorBoost.y + halves; rgbM *= _ColorBoost.x;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb_tips]]></title>
    <url>%2F2018%2F01%2F02%2Fadb-tips%2F</url>
    <content type="text"><![CDATA[修改系统文件以修改hosts为例首先手机需要root adb root adb remount adb push 将修改过的hosts文件push进去]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFT 和 DTFT]]></title>
    <url>%2F2017%2F12%2F31%2FDFT-and-DTFT%2F</url>
    <content type="text"><![CDATA[几种傅立叶变换 连续时间周期信号:处理时间连续并且具有周期性的信号，其频域上离散，非周期。 连续时间非周期信号:处理时间连续但是不具有周期性的信号，其频域上连续，非周期。 离散时间非周期信号:处理时间离散，不具有周期性的信号，其频域上连续，有周期性。 离散时间周期信号:处理时间离散，具有周期性的信号，对应离散时间傅里叶变换其频域上离散，有周期性。 关于时域是否离散与频域周期性的关系为什么时域离散，频域周期，时域连续，频域非周期呢？如果你的频域是离散的，那么就有一个最小的分辨频率，这个自然对应了时域的最大波长，即时域的周期性。反之同理。如果你的时域是离散的，那就有一个最小的波长。这个波长就对应频域的最高频率。所有高于这个频率的信息，都要被alias、反褶到低频去。即频域的周期性。 离散时间傅立叶变换离散时间傅里叶变换（英语：Discrete-time Fourier Transform，简称：DTFT）是傅里叶变换的一种。它将以离散时间nT（其中，T为采样间隔）作为变量的函数（离散时间信号）变换到连续的频域，即产生这个离散时间信号的连续频谱，值得注意的是这一频谱是周期的，周期为$2\pi$。 离散傅立叶变换理解从理论上来说，上述四种变换基本囊括我们能遇到的信号种类。但是在数字信号处理里面，我们接触的都是离散时间的信号，所以前两种连续时间的傅里叶变换用不到。剩下的两种变换中，DFT与离散时间周期信号的变换非常类似，有何原因？在数字信号处理中，信号是要交给计算机进行处理的，这其中涉及到对数字信号的进行处理交给计算机以及计算机的算法设计，对于一般的离散时间信号而言，从数学上直接用DTFT会非常利于分析信号的频域特征，但问题是目前的机器不能表达一个无限长的序列，也不能表达连续的频域特征。因此我们才需要DFT，也就是说DTFT是给人用的，而DFT是给机器用的。DFT相较于DTFT，主要有两处不同，一点是变无限为有限，是因为机器无法表示无限长的序列，只能处理有限长序列。另一点是频域采样，关于采样，是理解DFT的重点。 频域采样我们前面提到离散非周期序列的傅里叶变换(DTFT)在频域上是连续的，这连续的频域特征机器是无法表达的，因此我们需要对它进行采样。又由于频域上具有周期性，只需要对2pi长度的区间采样即可。那么应该采多少个点呢？类似于Nyquist采样定理的做法，我们得出采样的点数M≥N即可(N表示该序列的长度)，为了方便起见只需取M=N。由此，DFT的两个引入动机就清楚了:它是对无限长序列截断成有限长序列，进行DTFT以后再在频域采样。那么为何DFT的形式和离散时间周期信号的傅里叶变换形式类似呢？注意到，有限长序列经过周期延拓即可变为周期信号，因此他们之间的相似性也不言而喻了。不过需要注意的是DFT对有限长序列均可以用，但离散时间周期信号的傅里叶变换只能处理周期信号，这是本质的不同。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客建立]]></title>
    <url>%2F2017%2F12%2F27%2Fbuild-blog-on-github%2F</url>
    <content type="text"><![CDATA[遇到的问题公式打开mathjax如果使用了主题，在主题的_config.yml中打开mathjax12345# MathJax Supportmathjax: enable: true per_page: true cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 在文档Front-matter中启用mathjax这是为了渲染快，因为没有公式的文档不需要渲染123456---title: 卷积与傅立叶date: 2017-12-26 21:46:15tags:mathjax: true--- latex与markdown冲突：参照latex与markdown语法冲突解决比如latex中的下标符号_，markdown会先识别为斜体，这样公式就不能渲染了，以及\转义会影响latex换行的识别，对于这种情况，两种方法解决： 将公式中的_替换为转义_即可，但是这样做，虽然生成的网页正常，但是markdown preview的时候会出错； 修改renderer引擎的转义定义:1234// 取消`\`转义（注意：这里的修改与上面链接中修改有区别）:escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,// 取消`_`转义：em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, Atom可以实时预览公式安装 latex 预览packagectlr + shift + x Markdown语法GitHub Markdown 语法]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积与傅立叶]]></title>
    <url>%2F2017%2F12%2F26%2Fconvolution-introduction%2F</url>
    <content type="text"><![CDATA[卷积函数定义：设:$f(x)$, $g(x)$ 是R1上的两个可积函数，作积分$${\int_{-\infty}^{\infty}}f(\tau)\ast\,g(x-\tau)\,\mathrm{d}\tau$$ 可以证明，关于几乎所有的实数$x$，上述积分是存在的。这样，随着$x$的不同取值，这个积分就定义了一个新函数$h(x)$，称为函数$f$与$g$的卷积，记为$h(x)=(f\ast\,g)(x)$。容易验证，$(f\ast\,g)(x)=\,(g\ast\,f)(x)$，并且 $(f\ast\,g)(x)$ 仍为可积函数。这就是说，把卷积代替乘法，$L1(R1)$空间是一个代数，甚至是巴拿赫代数。离散表达：$$y(n) = \sum_{i=-\infty}^{\infty}x(i)h(n-i) = x(n)\ast\,h(t)$$ 理解首先要明确，卷积只在线性时不变系统起作用，所以我们接下来的讨论均在此条件下进行。线性时不变系统： 线性系统：系统的输入和输出具有线性关系 时不变系统：系统的参数不随时间而变化，即不管输入信号作用的时间先后，输出信号响应的形状均相同，仅是从出现的时间不同，与系统状态无关。 物理意义：对于输入信号$f(τ)$,响应函数$g(τ)$，在t时刻的输出信号即为两者的卷积： $${\int_{-\infty}^{\infty}}f(\tau)g(t-\tau)\,\mathrm{d}\tau$$该式与上面公式区别仅在于改变了变量符号为时间t，主要为了便于理解。 离散情况那么，为什么将两个时间信号这样积分，或者说求卷积就是t时刻的输出信号呢？举例来说：第一年，小明存入100元钱，年利率是5%，按复利计算（即将每一年所获利息加入本金，以计算下一年的利息），那么在五年之后他能拿到的钱数是$100(1+5\%)^5$，如此类推，第二年存入100，四年后能拿到$100(1+5\%)^4$，连续存五年，列表如下： 本金 第一年 第二年 第三年 第四年 第五年 $\small100$ $\small100(1+5\%)^1$ $\small100(1+5\%)^2$ $\small100(1+5\%)^3$ $\small100(1+5\%)^4$ $\small100(1+5\%)^5$ $\small100$ $\small100(1+5\%)^1$ $\small100(1+5\%)^2$ $\small100(1+5\%)^3$ $100(1+5\%)^4$ $\small100$ $\small100(1+5\%)^1$ $\small100(1+5\%)^2$ $\small100(1+5\%)^3$ $\small100$ $\small100(1+5\%)^1$ $\small100(1+5\%)^2$ $\small100$ $\small100(1+5\%)^1$ $\small100$ 最终，在第五年小明拿到钱：$$\small100(1+5\%)^1 + 100(1+5\%)^2 + 100(1+5\%)^3 + 100(1+5\%)^4 + 100(1+5\%)^5$$对应到上面的离散公式：$$\sum_{i=0}^{5}x(i)h(5-i)$$其中，$x(i) = 100$,$h(5-i) = {(1+5)}^{5-i}$ 这里计算结果即为在第五年拿到的总钱数，也是小明存钱函数（输入信号）$x(i) = 100$与复利计算函数（响应函数）$h(i) = {(1+5)}^{i}$ 的卷积结果。 连续情况初次看到卷积积分公式时，对于将两个关于$x$的函数在$τ$上积分不理解，这也直接导致对卷积数学意义和物理意义的理解偏差。举例，假如有响应函数$h(t)$,那么对于输入信号$f(t)$，在时刻T，将两者反褶相乘积分，画图举例 （） 其实，$τ$也是时间，只是我们在积分公式中，给定了时刻$t$。而给定t意味着输入信号与响应函数的相对位置确定，这就然后让$τ$在 $(-\infty,t]$ 上积分，我们知道积分可以看作无数个值的累加，那么从左往右的累加过程，就是 $(-\infty,t]$ 中所有时刻输入信号在响应函数作用下对t时刻输出信号的累加，这就是卷积。那么为什么会出现$τ$、$t-τ$、$τ+(t-τ)$刚好是t的看似巧妙的情况呢？这是因为，如果当前时间为t，那么在0时刻的输出信号在t时刻的响应函数就是$h(t-0)$,同样的，在τ时刻的输出信号在t时刻的响应函数就是$h(t-τ)$,没有什么数学上的巧合与美丽，只有实际的应用与计算。其实写到这里，已经觉得是在说废话了。 假设在一个线性时不变系统中，输入信号$x(t)$, 冲击信号$h(t)$,那么输出信号即为$x(t)\ast\,h(t)$，其步骤为： 变换变量$t$为$τ$ 冲击信号反褶 $h(-τ)$ 时移 $h(t-τ)$ 相乘 $x(τ)h(t-τ)$ 积分 这是卷积计算的步骤，很好理解，很好计算，这里权作记录。 矩阵卷积矩阵的卷积与一维离散卷积类似，只是反转平移的过程变为将响应矩阵旋转180度，这样刚好形成$f(τ)h(t-τ)$。比如，现有矩阵A，B：$${A} = \left(\begin{matrix} 1 &amp; 2 \\ 3 &amp; 4 \end{matrix} \right)\,\,\,\,\,\,{B} = \left(\begin{matrix} 5 &amp; 6 \\ 7 &amp; 8 \end{matrix} \right)$$变化矩阵B，三种方法： 直接旋转180 沿对角线分别反转 同时反转行和列三种方法只是利用了矩阵基本性质，不赘述。假设B翻转后得矩阵C：$${C} = \left(\begin{matrix} 8 &amp; 7 \\ 6 &amp; 5 \end{matrix} \right)$$那么，AB卷积的过程就是是将AC矩阵对应位置的元素相乘，并将结果累加，在图像处理中经常用到这种方法。AB卷积结果为：$$5\cdot8+6\cdot7+7\cdot6+8\cdot5 = 164$$在深度学习中，矩阵卷积应用广泛，具体可参考 – 矩阵卷积 卷积定理卷积定理是傅立叶变换满足的一个重要性质。卷积定理指出，函数卷积的傅立叶变换是函数傅立叶变换的乘积。具体分为时域卷积定理和频域卷积定理，时域卷积定理即时域内的卷积对应频域内的乘积；频域卷积定理即频域内的卷积对应时域内的乘积，两者具有对偶关系。若 $$f_1(t)\leftrightarrow\,F_1(\omega)$$ $$f_2(t)\leftrightarrow\,F_2(\omega)$$$F$ 表示傅里叶变换。则时域卷积定理：$$F(f_1(t)\ast\,f_2(t)) = F_1(\omega)F_2(\omega)$$频域卷积定理：$$F[f_1(t)f_2(t)] = \frac{1}{2\pi}F_1(\omega)F_2(\omega)$$卷积定理揭示了时间域与频率域的对应关系。 去卷积傅里叶傅里叶级数对于任意周期函数，都可以表示成一系列三角函数的和。那么为什么可以做这种变换呢？这可以几何或者矩阵做类比，在三维空间几何中，我们可以用$(1,0,0),(0,1,0),(0,0,1)$三个空间向量的线性组合来表示这个空间中的所有向量，这三个向量两两正交，称为三维空间向量的基。同理从矩阵的角度看，单元矩阵的每行或者每列也是两两正交，那么每一行都可以看作这个矩阵空间的基，使用这些基向量的线性叠加可以表示任意一个矩阵,如下：$$\left(\begin{matrix} 1 &amp; 0 \\ 0 &amp; 1 \end{matrix} \right) = \left(\begin{matrix} 1 &amp; 0 \\ 0 &amp; 0 \end{matrix} \right) + \left(\begin{matrix} 0 &amp; 0 \\ 0 &amp; 1 \end{matrix} \right)$$而对于函数，数学家也发现同样的现象，使用无数个相互正交的函数可以近似的表示任意一个周期函数，问题是这无数个两两正交的函数怎么找呢，三角函数刚好完美支持，而傅里叶级数选取的这个基函数就是三角函数,事实上，傅里叶级数可以有多种变化方式，三角函数只是其中一种。三角函数的正交性： 下面我们看傅里叶级数的表达，对于任意周期为T的函数，只要满足狄利赫里条件，则函数可以表达为：$$f(x) = \sum_{k=1}^\infty(a_k\,sin(kx) + b_k\,cos(kx)) + \frac{a_0}{2}$$ 其中：$$a_0 = \frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)dx$$ $$a_k = \frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)sin(kx)dx$$ $$b_k = \frac{2}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)cos(kx)dx$$ 关于$a_0$:将傅里叶级数两边在一个周期上同时积分，$sin$、$cos$的积分均为0，即可得$a_0$ 关于$a_n$:等式两边同时乘以$sin(nx)$再进行积分，根据三角函数正交定理，只有同频率的元素在周期上的积分才不为零： $$\int_{-\frac{T}{2}}^{\frac{T}{2}}f(x)sin(kx)=\int_{\frac{2}{T}}^2{a_n}\,sin(kx)^2dx$$ $$\int_{-\,\frac{T}{2}}^{\frac{T}{2}}f(x)sin(kx) = a_n\frac{T}{2}$$ 即得$a_n$同理得$b_n$傅里叶展开后，原函数与展开式，以及展开式的频谱、相位关系图，现在有了各频率下的幅值和相位，原函数的频域信息就都体现出来了： 可以看出，将展开级数沿z轴放置，从图右边看，就是频谱，从上面看就是相位，需要注意的是，由于傅里叶级数中只使用了正弦和余弦函数，因此相位永远是0或者$\pi$，另外，级数展开后得频率非连续，是一个个独立的幅值，对应的频率是原函数频率的整数倍，这样的频谱是离散的。下面的动图也有助于理解： 傅里叶级数的复数形式复数形式可以由欧拉公式变化而来，只是简单的代入，不再赘述。欧拉公式：$$e^{it} = cos(t) + isin(t)$$傅里叶复数：$$f(x) = \sum_{-\infty}^{\infty}a_ke^{jk\omega\,t}$$其中：$$a_k = \frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}x(t)e^{-jk\omega\,t}dt$$ 傅里叶变换傅里叶级数有其局限性，只能用于周期函数，那么对于非周期函数怎么办呢？对于非周期函数，我们可以这样思考，非周期看作周期无穷大，那么对应的$\omega$则无穷小，傅里叶级数：$$f(t) = \frac{1}{2\pi}\int_{-\infty}^{\infty}F(\omega)e^{i\omega\,t}d\omega$$其中：$$F(\omega) = \int_{-\infty}^{\infty}f(t)e^{-i\omega\,t}dt$$注意,第二个公式才叫做 $f(x)$ 的傅里叶变换。更重要的是，这个式子里的角频率 $\omega$ 就不是某一个频点了，它可以取频谱轴上的任意值，它是连续的！非周期的信号的频谱遍布整个频率轴！对某一点特定角频率 $\omega$ 取值，$F(\omega)$ 就是角频率 $\omega$ 在信号 $f(t)$ 中的”份量”！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理基础]]></title>
    <url>%2F2017%2F12%2F26%2Fimage_processing%2F</url>
    <content type="text"><![CDATA[锐化锐化(image sharpening)是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰。从频域的角度理解是增强图像的高频分量。目前主流软件锐化方式主要有全局锐化和局部锐化，本文主要涉及全局锐化，局部今后另说。 全局锐化原理：理论上来说，全局锐化是滤波算法的逆应用滤波结果 = 过滤掉图像细节的输入图像图像细节 = 输入图像 - 滤波结果锐化结果 = 输入图像 + 锐化系数 X 图像细节所以说有多少种滤波算法，就有多少中锐化算法。 锐化的核心目的是强化图像轮廓，比如人体的眼眶，帽子的帽沿，将非轮廓的地方锐化，对于增强整体的形态并无太大帮助。而全局锐化是将整个图像进行无差别增强，这也是全局锐化的不足之处。 实际应用中，简单的全局锐化可以使用Unsharp Mask(USM)算法。 $$y(n,m) = x(n,m) + \lambda\,z(n,m)$$其中，$x(n,m)$ 为输入图像，$y(n,m)$ 为输出图像，而$z(n,m)$ 为校正信号,在锐化中就是图像细节信号，一般是通过对$x$进行滤波获取。$λ$是用于控制增强效果的的一个缩放因子。在传统的USM算法中，$z(n,m)$ 一般可以通过下式获取： $$z(n,m)=4x(n,m)-x(n-1,m) -x(n +1,m)-x(n, m-1) -x(n,m+1)$$图像滤波的过程就是卷积核对图像上所有像素点及其临近像素进行对应相乘叠加的结果。如图：注意：这个对应元素相乘累加的过程，就是两个矩阵离散卷积的过程。根据卷积定理：函数卷积的傅立叶变换是函数傅立叶变换的乘积，那么我们只要使矩阵B的频谱中不包含频率 $\omega$，就能保证卷积结果中也不包含频率 $\omega$，这就是滤波的由来。 上式对应的卷积核为 局部锐化局部锐化可以弥补全局锐化的不足，将锐化的重心放在图像的边缘处（比如头发丝，脸颊），突出形体和轮廓。这就需要做出边缘检测，目前流行算法Laplician of Gaussian(LoG)，据说PS中用于Edge Dectection的高反差保留以及照片边插画的核心算法都是这个。 滤波算法根据卷积定理：函数卷积的傅立叶变换等于两个函数傅立叶变换的乘积，那么如果用于卷积的卷积核损失了高频或者低频的部分，卷积后的图像频谱相应的也会损失对应的频率，这就是滤波器的工作原理。 线性滤波器（均值滤波）线性滤波器的原始数据与滤波结果是一种算术运算，即用加减乘除等运算实现，如均值滤波器（模板内像素灰度值的平均值）、高斯滤波器（高斯加权平均值）等。由于线性滤波器是算术运算，有固定的模板，因此滤波器的转移函数是可以确定并且是唯一的（转移函数即模板的傅里叶变换）。卷积可以说是图像处理最基本的操作，但却非常有用。这个操作有两个非常关键的特点：它们是线性的，而且具有平移不变性shift-invariant。平移不变性指我们在图像的每个位置都执行相同的操作。线性指这个操作是线性的，也就是我们用每个像素的邻域的线性组合来代替这个像素。这两个属性使得这个操作非常简单，因为线性操作是最简单的，然后在所有地方都做同样的操作就更简单了。2D卷积需要4个嵌套循环4-double loop，所以它并不快，除非我们使用很小的卷积核。这里一般使用3x3或者5x5。而且，对于滤波器，也有一定的规则要求： 滤波器的大小应该是奇数，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。 滤波器矩阵所有的元素之和应该要等于1，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。 如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。 对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。平滑均值滤波器$$\frac{1}{9}\left(\begin{matrix} 1 &amp; 1 &amp; 1\\ 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1\end{matrix} \right)$$这是一个低通滤波器，其频谱的高频部分幅值很低甚至为零，也就是说会过滤掉高频部分，结果是将图像进行平滑处理。锐化均值滤波器$$\left(\begin{matrix} -1 &amp; -1 &amp; -1\\ -1 &amp; 8 &amp; -1 \\ -1 &amp; -1 &amp; -1\end{matrix} \right)$$这是一个高通滤波器，其频谱的低频部分幅值很低甚至为零，也就是说会过滤掉低频部分，结果是将图像进行锐化处理。高斯滤波器高斯滤波器是低通滤波，滤波后图像被平滑的程度取决于标准差。它的输出是领域像素的加权平均，同时离中心越近的像素权重越高。因此，相对于均值滤波（mean filter）它的平滑效果更柔和，而且边缘保留的也更好。高斯滤波简单说就是卷积核的概率分布服从高斯分布。自然界里高斯分布遍布各处，使用高斯分布有一定的理由。3X3高斯卷积核：$$\frac{1}{16}\left(\begin{matrix} 1 &amp; 2 &amp; 1\\ 2 &amp; 4 &amp; 2 \\ 1 &amp; 2 &amp; 1\end{matrix} \right)$$5X5高斯卷积核:$$\frac{1}{273}\left(\begin{matrix} 1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \\ 4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \\ 7 &amp; 26 &amp; 41 &amp; 26 &amp; 7 \\ 4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \\ 1 &amp; 4 &amp; 7 &amp; 4 &amp; 1\\\end{matrix} \right)$$非线性滤波器非线性滤波器的原始数据与滤波结果是一种逻辑关系，即用逻辑运算实现，如最大值滤波器、最小值滤波器、中值滤波器等，是通过比较一定邻域内的灰度值大小来实现的，没有固定的模板，因而也就没有特定的转移函数（因为没有模板作傅里叶变换），另外，膨胀和腐蚀也是通过最大值、最小值滤波器实现的。 对比度锐化与对比度的区别锐化可以理解为增加局部差异，增加对比度可以理解为拉开整体差异 亮度饱和度]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-MVC-Hibernate-搭建后台服务]]></title>
    <url>%2F2017%2F12%2F26%2FSpring-MVC-Hibernate%2F</url>
    <content type="text"><![CDATA[框架介绍Spring MVCSpring MVC基于传统Spring的MVC模式的开发框架。 MVC设计模式在Spring MVC中表现为 模型 - 视图 - 控制器，模型封装应用程序的数据和一般他们会组成的POJO(Plain Ordinary Java Object)简单的Java对象，视图(View)是负责呈现模型数据并且一般由它生成HTML输出，客户端浏览器来解析显示，控制器(Controller)负责处理用户的请求，并建立适当的模型，并把它传递给视图渲染。 在Spring MVC中，有一个很重要的类是DispatcherServlet，叫中央前端控制器，所有的请求都由该控制器接受并分发到到合适的处理器，处理器解析请求直接返回Response或者跳转jsp页面，这些过程都要通过中央前端处理器。如图1所示： 接收HTTP请求后，DispatcherServlet 咨询 HandlerMapping 来调用相应的控制器。该控制器接受请求并调用基于使用GET或POST方法相应的服务方法。服务方法将基于定义的业务逻辑设置模型数据，并返回视图名到DispatcherServlet.DispatcherServlet将需要帮助的ViewResolver从拾取到该请求所定义的视图。一旦视图被敲定，DispatcherServlet会传递模型数据是在浏览器上最终呈现的视图。 Spring MVC的基本使用在java web项目中，都有一个web.xml文件用于配置当前项目，在这里，我们可以通过简单的对比了解Spring MVC的作用在没有使用Spring MVC框架前， 单纯的使用servlet接受网络请求的过程是这样的 ： 配置web.xml12345678910111213141516&lt;web-app&gt;&lt;!-- 配置servlet--&gt; &lt;servlet&gt; &lt;!-- servlet名称--&gt; &lt;servlet-name&gt;Sorry&lt;/servlet-name&gt; &lt;!-- 对应servlet要指向的HttpServlet类--&gt; &lt;servlet-class&gt;moreservlets.SorryServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 映射servlet到url--&gt; &lt;servlet-mapping&gt; &lt;!--这里表示所有以/servlet/开头的请求都会由Sorry这个Servlet来处理--&gt; &lt;servlet-name&gt; Sorry &lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 不使用SpringMVC时的网络请求继承HttpServlet类，并复写doGet()，doPost()等方法来处理请求1234567public class SorryServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); String title = &quot;Invoker Servlet Disabled.&quot;; out.println(ServletUtilities.headWithTitle(title) + &quot;&lt;BODY BGCOLOR=/&quot;#FDF5E6/&quot;&gt;/n&quot; + &quot;&lt;H2&gt;&quot; + title + &quot;&lt;/H2&gt;/n&quot; + &quot;Sorry, access to servlets by means of/n&quot; + &quot;URLs that begin with/n&quot; + &quot;http://host/webAppPrefix/servlet//n&quot; + &quot;has been disabled./n&quot; + &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;); &#125; 很明显，如果需求中有很多的请求，那么web.xml文件将会变得臃肿不堪，同时也要写大量的HttpServlet类用于处理请求，不利于代码的维护。 使用Spring mvc接受网络请求是这样的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455配置web.xml文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;&lt;!-- spring 配置文件 默认是/WEB-INF/applicationContext.xml ，在这里可以配置数据库地址，数据库文件，java bean等等--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 默认是/WEB-INF/applicationContext.xml --&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- spring mvc的中央前端分发器配置，不同于纯Servlet，所有的网络请求都经过该类然后分发--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置文件，配置了beans --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 默认是/WEB-INF/[servlet名字]-servlet.xml，在这个文件里配置控制器所在的包 --&gt; &lt;param-value&gt;/WEB-INF/SpringMVC-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--同样需要映射url，参数&lt;url-pattern&gt;表示所有的请求都由SpringMVC这个中央前端控制器接受 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!--转码控制 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 定义控制器：12345678910//注解Controller表示这个类是一个控制器@Controllerpublic class AppInfoController &#123; private Logger logger = Logger.getLogger(AppInfoController.class);//RequestMapping注解表示这个方法处理 /app的请求 @RequestMapping(value = &quot;/app&quot;,method = RequestMethod.GET) public void getAppInfoById(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; response.getWriter().append(&quot;Hello World&quot;);&#125; 因此使用Spring MVC的话，只需要在web.xml文件中配置DispatcherServlet，然后通过Controller注解一个类为控制器，再通过RequestMapping注解指定某方法可以接受某一类请求即可。这是最简单的使用，Spring MVC还提供很多其他的注解方式，比如ResponseBody注解直接将函数返回值作为Response的body返回，或者直接返回jsp文件名称并跳转页面等，不在赘述。 Hibernate简介Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，并将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得我们可以使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用， 完成数据持久化的任务。 hibernate使用在引入Hibernate类库之后，需要完成两个步骤，涉及到两种文件： 1.配置Hibernatehibernate.cfg.xml 文件：这是hibernate的配置文件，在这里要做的事包括但不限于： a. 操作的数据库的地址，账户，密码 b. .配置数据库驱动 2.实体类及映射文件POJO的映射文件。例如有一个AppInfo的模型类，为了使hibernate可以将读出来的数据直接转化为对象，需要创建相对应的AppInfo.hbm.xml文件，下面以AppInfo类为例进行说明：12345678910111213141516171819//这个是AppInfo model类，要求属性私有，并提供相应的setter和getterpublic class AppInfo implements java.io.Serializable &#123; private static final long serialVersionUID = 1111111111111111111L; private long id = 0; private String appId; public void setId(long id)&#123; this.id=id; &#125; public long getId()&#123; return id; &#125; public void setAppId(String appId)&#123; this.appId = appId; &#125; public String getAppId()&#123; return appId; &#125;&#125; 对应的AppInfo.hbm.xml文件，其中id标签表示将属性id作为数据库的主键，property标签对应AppInfo类中的appId属性，其他属性以此类推123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;qiyi.vr.app.model&quot;&gt; &lt;class name=&quot;AppInfo&quot; table=&quot;app_info&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;java.lang.Long&quot;&gt; &lt;column name=&quot;id&quot; /&gt; &lt;generator class=&quot;native&quot; /&gt; &lt;/id&gt; &lt;property name=&quot;appId&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;app_id&quot; /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 注：关于hbm.xml文件的生成：在MyEclipse中，可以通过根据数据库的字段反向映射来生成hbm.xml文件，但是这样会生成两个hbm.xml文件，具体原因及使用方法未知 3.注册映射文件在hibernate.cfg.xml文件中注册上面得到的映射文件1&lt;mapping resource=&quot;qiyi/vr/app/model/AppInfo.hbm.xml&quot; /&gt; 4.hibernate与数据库的交互hibernate与数据库的交互涉及到三个比较重要的类： SessionFactory：SessionFactory实例对应一个数据存储源，其特点是1.线程安全，同一个SessionFactory可被多个线程共享2.重量级，SessionFactory需要大缓存，缓存中会存储预设的SQL语句，因此，如果只需要访问一个数据库，那么创建一个SessionFactory对象即可 Session：Session是持久化管理器，由SessionFactory生成，其特点是：1线程不安全，session代表和当前数据库之间的一次操作，尽量避免多线程共享session2.轻量级，创建session耗费的资源相对较少3.session又被称为Hibernate的一级缓存，存放当前工作单元加载的对象，使用完毕要关闭session Transaction：Transaction接口是Hibernate数据库事务接口，Hibernate进行持久化操作时必须进行事务控制，简单说就是具体的数据库操作要在开启事务后进行，然后由事务进行commit，很类似于Android FragmentManager的Transaction。12345678910@Override public long insert(AppInfo entity) throws SQLException &#123; // TODO Auto-generated method stub Session session = HibernateSessionFactory.getSession(); Transaction transaction = session.beginTransaction(); session.save(entity); transaction.commit(); session.close(); return 0; &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jni开发知识点]]></title>
    <url>%2F2017%2F12%2F26%2Fjni-tips%2F</url>
    <content type="text"><![CDATA[JavaVM和JNIEnvjni定义了两个关键的结构体，JavaVM和JNIEnv，两者都拥有指向方法表的指针，在c++中，两者是拥有指向方法表和一系列jni方法的类，Android developer中说是类，实际开发中在jni.h中发现是结构体）。javavm提供invocation interface方法，可以创建和销毁javavm，理论上每个进程可以有多个javavm，但是Android中只允许有一个。jnienv提供大部分的jni方法，native方法的第一个参数就是jnienv。jnienv使用个threadlocal存储，因此线程间无法共享。如果某一段代码中无法获得jnienv，可以共享javavm并调用GetEnv来获得当前线程的jnienv，如果当前线程没有，可以使用AttachCurrentThread创建。 注意：c和c++关于两者的声明不同，如果头文件中定义了#indef _cplusplus，那么要注意自己引用的时哪个版本。 线程所有的线程都是linux线程，有kernal管理，可以自己创建线程，并通过JNI AttachCurrentThread or AttachCurrentThreadAsDaemon方法与jni关联，没有关联的话线程无法进行jni call。如果线程已经关联，那么调用AttachCurrentThread是空操作。当把一个线程Attach到javavm时，java中会创建一个thread,并添加到main threadGroup。android不会暂停正在执行native code的线程，只会在下一次执行jni call时暂停线程。通过jni关联的线程在退出前必须调用DetachCurrentThread，也可以使用pthread_key_create并构造新的析构函数来实现相同效果，在析构函数中调用该方法。使用pthread_setspecific存储jnienv到threadlocal，这样析构函数中传入jnienv参数。 引用类的引用、field IDs和method IDs 在类unload之前都是可用的。类的unload操作很少见，但并不是不可能。注意：尽管jclass是类的引用，但jclass必须通过NewGlobalRef的操作来保护起来。 native code中，对class的操作较为耗时，比如获得成员变量，回调方法，这些操作都要先获得fieldId和methodId，从性能角度看，最好将这些id缓存下来。考虑到java的类有可能会有unload，reload的过程，可以使用以下方式在每次加载类的时候缓存id12345678910/* * We use a class initializer to allow the native code to cache some * field offsets. This native function looks up and caches interesting * class/field/method IDs. Throws on failure. */private static native void nativeInit();static &#123; nativeInit();&#125; 这样，在一个类每次加载时都会调用nativeInit，在native层相应实现方法即可。 疑问：不同类的加载时线程问题 局部引用和全局引用传递给native方法传递的参数和大部分jni返回的参数都是局部引用，这意味着这些引用在当前的native方法中可见。及时对象在本地方法返回后仍然存活，引用也是不可见的。获得全局引用的唯一方法是NewGlobalRef和NewWeakGlobalRef.常用的模式是 123jclass localClass = env-&gt;FindClass(&quot;MyClass&quot;);//reinterpret_cast c++强制类型转换jclass globalClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(localClass)); jni方法接受局部和全局引用作为参数。指向同一对象的多个引用可能值并不相等。比如，连续多次调用NewGlobalRef的结果可能不同，因此在jni中，不能用==来判断引用是否相等，而要使用IsSameObject。因此，native中，不能假设对象的引用是不变的。 jni中，不能过多的分配局部引用，如果创建过多局部引用，要手动DeleteLocalRef(一般情况这个操作由jni自己完成)。实际中最多保留十六个局部引用，如果要更多，使用EnsureLocalCapacity/PushLocalFrame 注意：jfieldIDs and jmethodIDs不是object引用，不能更改为GlobalRef。 如果调用AttachCurrentThread，运行中的代码不会自动释放局部引用知道线程结束，需要手动释放。 基本类型数组此部分需要写代码进行验证 基本类型数组可以直接进行读写操作，因为他们是由c定义的。有一组函数用于对基本类型数组操作Get&lt;PrimitiveType&gt;ArrayElements,这些函数有的返回指针，有的返回真实的元素，有的分配内存并进行拷贝。不管哪种方式，返回的原始的指针在释放前都是可见的。也就是说，如果数据没有被拷贝，数组对象就不会被释放。我们必须释放所有的数组。是否进行拷贝是通过get系列函数的iscopy来确定的。release调用时传入mode参数：mode：0:源数据： 释放copy数据：data is copied back. The buffer with the copy is freed. JNI_COMMIT源数据： 无操作copy数据：data is copied back. The buffer with the copy is not freed. JNI_ABORT源数据： the array object is un-pinned. Earlier writes are not aborted.copy数据：the buffer with the copy is freed; any changes to it are lost. JNI_COMMIT不会释放元数据，需要使用其他参数再次调用release 关于isCopy，检查是否进行了拷贝很有用，如果对数组进行了修改，这可以让我们确定自己是否需要调用带有JNI_COMMIT的release方法。 Region Calls如果仅仅是为了将数据拷贝出来或者拷贝进去，有更方便的方法：先看以前的方法：12345jbyte* data = env-&gt;GetByteArrayElements(array, NULL);if (data != NULL) &#123; memcpy(buffer, data, len); env-&gt;ReleaseByteArrayElements(array, data, JNI_ABORT);&#125; 方便的方法,还能避免忘记release,还会避免多余的拷贝env-&gt;GetByteArrayRegion(array, 0, len, buffer); 异常很多jni方法会抛出异常。比如CallObjectMethod，这时需要check异常，因为该函数的返回值可能不可用。android还不支持c++的异常，jni的Throw和throwNew会在当前线程抛出一个java异常。native方法中，通过ExceptionCheck和ExceptionOccurred捕获异常。通过ExceptionClear清理异常。 关于JNIEnvc style:JNIEnv是一个名为JNINativeInterface的结构体，里面包含了一系列方法的指针用于jni的交互，如123456789101112struct JNINativeInterface &#123; void* reserved0; void* reserved1; void* reserved2; void* reserved3; jint (*GetVersion)(JNIEnv *); jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*, jsize); jclass (*FindClass)(JNIEnv*, const char*);..... c++ style：将c的JNINativeInterface结构体进行封装，变为名为_JNIEnv的结构体，并对JNINativeInterface的方法进行封装。12345678910111213141516171819202122/* * C++ object wrapper. * * This is usually overlaid on a C struct whose first element is a * JNINativeInterface*. We rely somewhat on compiler behavior. */struct _JNIEnv &#123; /* do not rename this; it does not seem to be entirely opaque */ const struct JNINativeInterface* functions;#if defined(__cplusplus) jint GetVersion() &#123; return functions-&gt;GetVersion(this); &#125; jclass DefineClass(const char *name, jobject loader, const jbyte* buf, jsize bufLen) &#123; return functions-&gt;DefineClass(this, name, loader, buf, bufLen); &#125; jclass FindClass(const char* name) &#123; return functions-&gt;FindClass(this, name); &#125;..... 关于JavaVMc style:123456789101112//JNI invocation interface.struct JNIInvokeInterface &#123; void* reserved0; void* reserved1; void* reserved2; jint (*DestroyJavaVM)(JavaVM*); jint (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*); jint (*DetachCurrentThread)(JavaVM*); jint (*GetEnv)(JavaVM*, void**, jint); jint (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);&#125;; c++ style:1234567891011121314struct _JavaVM &#123; const struct JNIInvokeInterface* functions; //if defined(__cplusplus) jint DestroyJavaVM() &#123; return functions-&gt;DestroyJavaVM(this); &#125; jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThread(this, p_env, thr_args); &#125; jint DetachCurrentThread() &#123; return functions-&gt;DetachCurrentThread(this); &#125; jint GetEnv(void** env, jint version) &#123; return functions-&gt;GetEnv(this, env, version); &#125; jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); &#125;&#125;; 关于引用数据类型c style:123456789101112131415161718/* * Reference types, in C. */typedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak; 可见，在c中，由无类型指针void*引申出一系列的jobject c++ style:123456789101112131415161718192021222324252627282930313233/* * Reference types, in C++ */class _jobject &#123;&#125;;class _jclass : public _jobject &#123;&#125;;class _jstring : public _jobject &#123;&#125;;class _jarray : public _jobject &#123;&#125;;class _jobjectArray : public _jarray &#123;&#125;;class _jbooleanArray : public _jarray &#123;&#125;;class _jbyteArray : public _jarray &#123;&#125;;class _jcharArray : public _jarray &#123;&#125;;class _jshortArray : public _jarray &#123;&#125;;class _jintArray : public _jarray &#123;&#125;;class _jlongArray : public _jarray &#123;&#125;;class _jfloatArray : public _jarray &#123;&#125;;class _jdoubleArray : public _jarray &#123;&#125;;class _jthrowable : public _jobject &#123;&#125;;typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak; 在c++中，jobject是一个类 基本数据类型：123456789101112/* Primitive types that match up with Java equivalents. */typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 *//* &quot;cardinal indices and sizes&quot; */typedef jint jsize; 可见，jni的基本类型与c中基本类型一样，所以可以直接转换，且不用考虑释放问题。 方法的类型签名：jni使用java虚拟机的类型签名1234567891011121314151617Type Signature Java TypeZ booleanB byteC charS shortI intJ longF floatD doubleLfully-qualified-class; fully-qualified-class[type type[](arg-types)ret-type method type如long f (int n, String s, int[] arr);的签名是：(ILjava/lang/String;[I)J 关于native向java回调在回调时经常会碰到多个不同的方法的类型签名，为避免重复代码和方便,可以使用以下方法。避免直接传递基本类型，全部使用jobject作为参数，基本类型使用其封装类123456789101112131415161718192021void callBackJavaUniversal(JavaVM *gJavaVM, jobject targetObj, string nameStr, string sigStr,jobject param1, jobject param2) &#123; char *name = (char *) nameStr.data(); char *sig = (char *) sigStr.data(); JNIEnv *env = 0; if (gJavaVM != NULL) &#123; gJavaVM-&gt;AttachCurrentThread(&amp;env, 0); &#125; if (env == NULL)&#123; return; &#125; jclass javaClass = env-&gt;GetObjectClass(targetObj); jmethodID javaCallback = env-&gt;GetMethodID(javaClass, name, sig); if (param1 == NULL) &#123; env-&gt;CallVoidMethod(targetObj, javaCallback); &#125; else if (param2 == NULL)&#123; env-&gt;CallVoidMethod(targetObj, javaCallback, param1); &#125; else &#123; env-&gt;CallVoidMethod(targetObj, javaCallback, param1, param2); &#125; env-&gt;DeleteLocalRef(javaClass);&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Blog]]></title>
    <url>%2F2017%2F12%2F26%2Ffirst%2F</url>
    <content type="text"><![CDATA[first blog]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
