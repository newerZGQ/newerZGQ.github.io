<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode_整型反转]]></title>
    <url>%2F2019%2F08%2F27%2Fleetcode-%E6%95%B4%E5%9E%8B%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[题目Given a 32-bit signed integer, reverse digits of an integer. Example 1:Input: 123Output: 321 Example 2:Input: -123Output: -321 Example 3:Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 这道题相对来说比较简单，主要有两点需要注意 数字反转数字或者字符串的反转通常都可以使用push和pop操作进行，不同的是，对于字符串，在使用push/pop操作时，不可避免的需要使用额外的存储空间，大小等于字符串的大小；而对于数字，则可以使用数学方法进行，比如对于数字Xpop操作pop = x % 10;x = x / 10;push操作ret = ret * 10 + pop;这个操作也是很好理解的，就是不停的对10进行模运算，得到的就是最后一位，然后将上次循环得到的结果乘10（相当于十进制中左移一位），在加上本次循环得到的模结果。 溢出判断本题的溢出判断是比较容易忽略或者考虑情况不全的，这里先介绍一种普遍的做法。根据上面的push操作公式，我们知道，每次循环的结果都是ret = ret 10 + pop;如果ret=ret10+pop导致溢出，那么一定有，ret&gt;=INTMAX/10，这是因为程序里整数除法运算只保留整数部分，int32范围[-2147483648 2147483647], INTMAX/10 = 214748364，如果ret=214748364，那么ret10不一定溢出（需要pop&gt;7），如果ret&gt;214748364，那么ret10一定溢出，如果ret&lt;214748364,那么ret*10一定不溢出同理，对于复数也是一样，需要注意的是，负数的最小值是-2147483648，个位是8额外多说一句，虽然不是重点，关于正负号的处理，因为代码中用负数除整数或取模，结果都是负数，比如-26/10=-2，-26%10=-6； 综合以上要点，代码就很容易写出来了 12345678910111213class Solution &#123; public int reverse(int x) &#123; int ret = 0; while(x != 0) &#123; int pop = x % 10; x = x/10; if(ret &gt; Integer.MAX_VALUE/10 || (ret == Integer.MAX_VALUE/10 &amp;&amp; pop &gt; 7)) return 0; if(ret &lt; Integer.MIN_VALUE/10 || (ret == Integer.MIN_VALUE/10 &amp;&amp; pop &lt; -8)) return 0; ret = ret * 10 + pop; &#125; return ret; &#125;&#125; More还有人通过别的方式进行溢出判断或者躲开溢出，比如看到有人将ret设置成long型，保证不会溢出，循环完之后通过ret是否大于Integer.MAX判断是否溢出，该方法虽然更简洁且可以通过测试，代码也更简单，但是原理写明了只能存储32位有符号整形，所以这种方法不符合题意。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Service详解]]></title>
    <url>%2F2019%2F05%2F14%2FService%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[生命周期 onStart弃用，但是还是会回调，在onStartCommand之后 所有bind的client都unBind之后，回调onUnbind 如果只有bind，那么所有bind的client都unBind之后，回调onUnbind和onDestroy 如果有startService，那么所有bind的client都unBind之后也不会销毁Service，必须stopService才能销毁 对于一个新创建的Service，onBind只会调用一次，因为下个client绑定的时候会默认发同一个binder，如果onUnbind返回false，那么onUnbind也只会回调一次 对于一个新创建的Service，因为onBind只会调用一次，如果下次绑定时想在绑定阶段做一些事情，就覆写onUnbind并返回true，那么之后每次绑定都会回调onRebind，onRebind在返回ServiceConnection后回调，同时绑定的client都unBind后，还是回调onUnbind]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android-Intent-Filter]]></title>
    <url>%2F2019%2F05%2F13%2FAndroid-Intent-Filter%2F</url>
    <content type="text"><![CDATA[概述只有一个intent内的action、category和date都能匹配上一个intent filter时才会启动对应的Activity。当然，这三者都有对应的匹配规则 actionmanifest中，一个intent filter可以有多个action。我们跳转时，intent中只能设置一个action，这个action必须与intent filter中的一个action匹配 categorymanifest中，一个intent filter可以有多个category。我们跳转时，intent可以add多个category，每个category都必须与intent filter中的某个category匹配，才算匹配上。category不能为空，intent中如果不设置category，系统会自动添加默认的categoryandroid.intent.category.DEFAULT。在manifest中设置intent filter时，也要记得，如果想让Activity接受隐式启动，必须加上android.intent.category.DEFAULT这个默认的category. datedate的匹配规则和action类似，如果过滤规则中定义了data，那么intent中也必须定义可匹配的data，data主要有两部分 mimetype: 媒体类型 uri scheme：uri模式，比如http，file，content host：主机 port：端口 path：路径信息]]></content>
  </entry>
  <entry>
    <title><![CDATA[android生命周期]]></title>
    <url>%2F2019%2F05%2F13%2Fandroid%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Activity生命周期Android生命周期还是比较简单明了的： onCreate: 做初始化，设置UI onStart：1. 在onCreate后调用，2. Activity被Stopped，但是又被放到前台展示，会先回调onRestart，再回调onStart onResume:1. 动画在这里做，2. 如果想标识Activity可见，onResume不是最好的选择，最好使用onWindowFocusChanged onPause：A启动B，A先回调onPause，B再回调onCreate，这里经常用于保存持久的数据，停止动画等一些消耗资源的操作，这样可以快速启动下一个Activity onStop：做一些重量级的回收 onDestroy：做一些最终的回收工作和资源释放，不适合做数据保存，因为某些情况下，系统会直接杀死进程，而不会回调这个方法 onRestart：Activity A被置于后台，生命周期走到onStop，然后又返回前台时，先回调onRestart，在回调onStart-&gt;onResume 其中生命周期两两相对应 注意点onSaveInstanceState和onRestoreInstanceState、onCreate在系统即将杀死Activity之前保存当前activity的一些数据，然后在onCreate或者onRestoreInstanceState中取回这些数据。这里要注意两个关键词 系统即将杀死，两层意思，一是必须是系统想要杀死这个Activity，而不是用户操作导致，比如说，正常的通过intent跳转Activity时，用户的想法是把Activity放在后台，但是系统会认为，放在后台有可能被系统销毁，那么保险起见回调onSaveInstanceState来保存数据。二是如果系统想要杀死，那么肯定会回调onSaveInstanceState。 onSaveInstanceState会委托window保存当前activity的View的结构和数据，每个View都有onSaveInstanceState和onRestoreInstanceState，可以看看各个View都能保存什么数据 在onCreate或者onRestoreInstanceState中取回，这里说的是或有两层意思，一是这两个方法可能不会被回调，这是因为，虽然系统判断需要杀死Activity，但是却还没杀死（比如按home键然后立即返回），那么当再次返回这个Activity时，仅仅会回调Activity的生命周期。但是如果确实杀死了Activity（比如手机屏幕旋转，这种情况是系统想要杀死Activity，然后重新创建新的Activity实例），那么肯定会走onCreate-&gt;onStart-&gt;onRestoreInstanceState-&gt;onResume，而且onCreate和onRestoreInstanceState中都有保存的数据123456789101105-13 20:18:29.889 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onCreate05-13 20:18:30.044 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onStart05-13 20:18:30.045 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume05-13 20:26:25.560 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onPause05-13 20:26:25.577 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onStop05-13 20:26:25.635 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onSaveInstanceState05-13 20:26:25.636 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onDestroy05-13 20:26:25.670 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onCreatethis is a save05-13 20:26:25.765 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onStart05-13 20:26:25.766 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onRestoreInstanceState: this is a save05-13 20:26:25.768 31673-31673/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume 上面的是手机屏幕旋转时的函数调用情况。需要注意的是onSaveInstanceState的调用时机，从android p开始，onSaveInstanceState在onStop之后调用，在android P之前，在onStop之前调用，至于是不是再onPause之前还是之后并没有任何保证。onRestoreInstanceState调用时机是onStart之后。 如果不想在屏幕旋转的额时候重新创建Activit，manifest中加 android:configChanges=&quot;orientation|screenSize Fragment生命周期]]></content>
  </entry>
  <entry>
    <title><![CDATA[java垃圾回收全了解]]></title>
    <url>%2F2019%2F05%2F08%2Fjava%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%85%A8%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[简介说起垃圾回收，很多人会自动和java联系上，认为是java的伴生产物，事实上，GC的历史远比java久远。很久以前，人们就开始思考GC需要完成的3件事情 哪些内存需要回收 什么时候回收 如何回收当然这也是java一直思考和完善的三个问题。我们知道，java内存运行时区域主要有这几个部分：pc寄存器、虚拟机栈、本地方法栈、堆、方法区。其中，pc寄存器、虚拟机栈、本地方法栈随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出有条不紊的执行入阵和出栈操作，每个栈帧分配多少内存基本是类结构确定下来时就已知的，因此这些区域的内存分配和回收都具备确定性，这些区域不需要考虑回收的问题。而堆和方法区则不一样，每个类占用的内存空间不一样，我们只有在程序运行时才会知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器关注的就是这部分内存。 对象真的死了么判断对象是否死去的依据是这个对象不可能再被任何途径使用 引用计数法很多教科书都会这么讲：给对象添加一个引用计数器，每当一个地方引用他时，计数器值加一，当引用失效时，计数器减一，任何时刻当计数器为0时的对象就是不可用的。表现上看，引用计数法实现简单，判定效率也高，但是目前来看，主流java虚拟机没有使用引用计数法来管理内存，最主要原因就是其难以处理对象之间相互循环引用的问题。对象之间互相循环引用指：比如两个对象A和B，A中有B的引用，B中有A的引用，除此之外，两个对象再无别的引用，那么，实际上A和B都不能再被使用，但因为两者互相引用，计数值始终为1，GC收集器也就永远无法回收他们。实际上，我们可以在写程序验证，详见深入理解java虚拟机P63，可以发现，主流的jvm没有使用该方法。 可达性分析算法目前主流商用程序语言（java，C#）都是用的可达性分析来判断对象是否存活的。可达性分析是指通过一系列成为GC Roots的对象作为起点，从这些起点向下搜索，搜索走过的路径叫引用链，当一个对象到GC Roots没有任何引用链时，则该对象是不可用的。GC Roots有这几种： 虚拟机栈中引用的对象 本地方法栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量池引用的对象引用的类型上面的分析中，我们一直在说引用，不管是引用计数还是可达性分析，引用都是判断对象存活最重要的判断依据，如果单纯的使用一种引用类型，那么，一个对象只有被引用和没有被引用两种状态，这对于某些情况可能不太适合，比如我们想要这样的引用类型：虽然没有很强的引用，但是我们还是希望，在还没有达到内存不足的情况时，尽可能的保留它。因此，java对引用的概念进行了扩充，将引用氛围强引用、软引用、弱引用、虚引用。 强引用，就是我们最经常使用的，只要有强引用存在，对象就不会被回收 软引用，当对象没有强引用但是有软引用时，还是会尽可能的保留它，直到内存不足，将要发生内存溢出时才会回收。 弱引用，当对象没有强引用但是有弱引用时，对象只能生存到下次垃圾收集之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收 虚引用，虚引用不会对对象的生存时间构成影响，为一个对象设置虚引用的唯一目的就是能在这个对象被回收时收到一个系统通知finalize可达性分析中不可达的对象也并不是非死不可的，至少还要经历两次标记过程： 第一次是对象到GC-Roots没有引用链时，会第一次打标并进行筛选，筛选出来所有实现了finalize方法的对象 所有实现了finalize方法的对象分两种，一种是已经执行过了finalize方法，这种会被视为没有必要再执行finalize，会被打标，另一种是需要执行finalize 需要执行finalize方法的对象会放置在F-Queue队列中，并由一个优先级较低的线程执行这个方法，这里的执行指虚拟机会触发这个方法，但不保证会等待他运行结束，因为如果某个对象的finalize导致了死循环，可能会导致其他对象永久等待，这样内存回收系统会崩溃根据上面的介绍，finalize是对象拯救自己的最后机会，在这里把对象跟某引用链接即可保证不被回收，但是记住，只能拯救一次，因为第二次系统发现finalize已经执行过，就不会再执行了。垃圾收集算法几种常见垃圾收集算法标记-清除算法 标记，标记出所有要回收的对象 清除对象所占内存空间缺陷，效率低，内存碎片，内存碎片多，导致为大内存对象分配内存时得多次触发垃圾回收复制算法为了解决效率问题，出现了一种复制算法，将可用内存划分为大小相等的两块，每次只使用其中的一块，当这一块用完了，就将还存活着的对象复制到另一块内存上，然后把这边的内存全部清理掉。这样避免的内存碎片问题，代价是可用内存减少一半。现在的商业虚拟机都是这种算法来回收新生代，IBM研究表明，98%的对象朝生夕死，所以不用1：1分配，将内存分为一块Eden区和两块survivor区，Eden区与survivor区大小比为8：1，，每次回收时，将Eden区和survivor区中还存活的对象全都复制到另一个survivor区，最后清理掉Eden区和用过的survivor区。标记-整理算法与标记清除算法类似，但是清理过程有区别 标记，标记出所有要回收的对象 把所有活着的对象向一端移动，然后清理掉剩下的内存，适合老年代的收集分代收集分为新生代和老年代，针对对象存活周期的特点，采用不同的垃圾收集方式，提供效率HotSpot算法实现枚举根节点：可达性分析必须在一个能保证一致性的快照中进行，即在一个所有执行线程都停顿的时间点进行，这就是Stop the world。实际中，并不需要检查完所有执行上下文和全局的引用位置，使用OopMap达到这个目的。安全点：OopMap可以快速的完成GC Roots枚举，但是有个问题随之而来，OopMap内容变化的指令很多，为每一个指令生成oopmap需要大量空间。gc成本也变高。实际上hotspot也没有为每个指令生成oopmap，而是设定了安全点，只有到达安全点才能开始GC，只有达到安全点才能暂停。那么怎么保证所有线程都能做到跑到最近的安全点并停顿呢？两种方案：1. 抢先式中断，GC发生时，中断所有线程，如果发现有线程不在安全点，就恢复线程，跑到安全点再停顿；2. 主动式中断，设置一个标志，线程跑到安全点时，轮询这个标志，发现为真就中断，轮询标志的点和安全点重合 安全区域：线程处于sleep或者block状态时无法响应中断，但是这样的状态并不影响枚举根节点，这种就是安全区域，可以认为安全区域是安全点的扩展，当线程进入安全区域，标识自己进入安全区域，当GC发生时就不会有影响，当要离开安全区域时，先检查系统根节点枚举是否完成，如果没有完成，要等到收到可以离开安全区域的信号为止。 垃圾收集器如果说手机算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 Serial与Sserial old收集器单线程收集器，仅使用一个cpu或一个收集线程，进行收集工作时，必须暂停其他所有线程，直到收集结束。 新生代使用复制算法（Serial） 老年代使用标记整理算法（Serial old）ParNew收集器 Serial收集器的多线程版本，适用于新生代，使用复制算法 与Serial old配合 与CMS收集器配合Parallel Scavenge与Parallel old收集器 Parallel Scavenge是并行多线程新生代收集器，使用复制算法 Parallel old是并行多线程老年代收集器，使用标记整理算法 主要用于控制吞吐量:吞吐量= 运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)CMS收集器 以获取最短回收停顿时间为目标 并发 基于标记清除算法G1收集器 内存分配与回收新生代GC叫Minor GC，老年代GC叫Major GC 对象优先在Eden区分配 大对象直接进入老年代 长期存活的对象将进入老年代：新生代每次GC年龄加一，年龄大于阈值（默认15）就进入老年代 动态对象年龄判断：如果Survivor空间相同年龄对象占用空间大于survivor空间一半，大于等于该年龄的对象直接进入老年代 空间分配担保：发生minor GC之前，虚拟机先检查老年代最大连续空间是否大于新生代所有对象总空间，如果大于，则认为这次minor GC是安全的，如果不是，则检查设置HandlePromotionFailure是否允许担保失败，如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则进行一次minor GC，虽然是有风险的，如果小于，或者设置HandlePromotionFailure不允许冒险，则进行一次Major GC。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lock原理]]></title>
    <url>%2F2019%2F05%2F06%2FLock%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android Activity的四种启动方式]]></title>
    <url>%2F2019%2F05%2F06%2FAndroid-Activity%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android四种启动方式Activity有四种启动方式：以下是Android developer介绍的，但是实际情况会有所出入| 使用场景 | Launch Mode | 是否多实例 | 介绍 || —————- | ————– | ———- | ——————————————————————————————————————————————————————————————————————— || 绝大多数使用场景 | standard | 是 | 默认模式，系统总会在目标任务栈中创建一个新实例，并把intent传给它 || 绝大多数使用场景 | singleTop | 根据情况 | 如果一个实例存在且位于目标任务栈的顶端，那么系统会将intent通过onNewIntent传给该activity，而不会创建一个新实例 || 特殊场景使用 | singleTask | 否 | 系统创建一个新的任务栈和一个新的activity实例，将activity实例放在栈底。但是，如果已经有一个这个Activity的实例，系统会回调这个实例的onNewIntent方法，而不会创建新实例（注意：此处介绍与实际情况有出入，后面会详细介绍） || 特殊场景使用 | singleInstance | 否 | 和singleTask几乎一样，不同的是，singleInstance存在的任务栈，不会有其他任何activity，该Activity是其所在任务栈内唯一的一个Activity | standard和singleTop这两个模式看似简单，其实仔细思考还是有一些需要注意的点的。我们从最简单的开始测试，现有如下两个Activity123456789101112131415&lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=&quot;.Main2Activity&quot; android:label=&quot;@string/title_activity_main2&quot; android:launchMode=&quot;singleTop&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot; /&gt; 测试流程MainActivity-&gt;Main2Activity-&gt;Main2Activity，打印当前任务栈，发现只有两个Activity：栈底MainActivity，栈顶Main2Activity，并且，在第二次启动Main2Activity时，没有创建新实例，而是回调了Main2Activity的onNewIntent方法。对于standard和singleTop，如无特别操作，新建的实例都会压入默认任务栈，上面两次启动Activity都是在默认的任务栈中。那么对于这种类型的Activity，我们可以让他们启动在另一个任务中么？答案是肯定的。我们在启动Main2Activity时，Intent可以设置Flag：1intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 根据官方文档，当设置了FLAG_ACTIVITY_NEW_TASK之后，会使用一个新的任务来承接要启动的Activity，但是实际情况是这样么？还是MainActivity-&gt;Main2Activity-&gt;Main2Activity的启动顺序，打印任务栈，发现还是只有一个任务栈，Main2Activity表现的和没有加Flag时一模一样。而出现这种情况的原因就是我们没有设置Main2Activity的taskAffinity。 taskAffinity: 每个Activity都有一个taskAffinity，表示这个Activity在启动时如果需要选择任务栈，那么选择的依据就是taskAffinity，为什么说如果需要选择呢？这是因为standard和singleTop模式下，即便设置了taskAffinity参数，Activity在启动后会直接进入到启动它的Activity所在的栈，而不会考虑根据taskAffinity去选择，除非在启动时给intent添加FLAG_ACTIVITY_NEW_TASK FLAG，这相当于给了Activity选择任务栈的权利，taskAffinity也会生效。而singleTask和singleInstance在整个系统中是单例，所以天生在启动时需要遍历所有任务栈，判断当前是否存在实例，如果有实例，则将已存在实例的上方Activity弹出，回调onNewIntent。 将上面manifest修改如下，给Main2Activity添加taskAffinity12345678910111213141516&lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=&quot;.Main2Activity&quot; android:label=&quot;@string/title_activity_main2&quot; android:launchMode=&quot;singleTop&quot; android:taskAffinity=&quot;com.test&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot; /&gt; 测试流程MainActivity-&gt;Main2Activity-&gt;Main2Activity，打印所有任务栈，这里给出打印任务栈代码，打印出每个任务栈的Activity数量、affiliatedTaskId、栈底Activity、栈顶Activity。1234567891011public static void printActivities(AppCompatActivity activity)&#123; ActivityManager activityManager = (ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.AppTask&gt; appTasks = activityManager.getAppTasks(); for (int i = 0; i &lt; appTasks.size(); i++) &#123; Util.print(&quot;numActivities: &quot; + appTasks.get(i).getTaskInfo().numActivities + &quot;\n&quot;); Util.print(&quot;affiliatedTaskId: &quot; + appTasks.get(i).getTaskInfo().affiliatedTaskId + &quot;\n&quot;); Util.print(&quot;baseActivity: &quot; + appTasks.get(i).getTaskInfo().baseActivity + &quot;\n&quot;); Util.print(&quot;topActivity: &quot; + appTasks.get(i).getTaskInfo().topActivity + &quot;\n&quot;); &#125; Util.print(&quot;================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n&quot;);&#125; 结果如下12345678910111204-29 00:39:30.563 8113-8113/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 00:39:30.567 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 287 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;04-29 00:39:33.104 8113-8113/study.zgq.com.androidstudy D/nanwei: total tasks: 204-29 00:39:33.108 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 288 baseActivity: Main2Activity topActivity: Main2Activity04-29 00:39:33.110 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 287 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;04-29 00:39:34.099 8113-8113/study.zgq.com.androidstudy D/nanwei: +++++++++++++&gt;&gt;&gt;&gt;new intent04-29 00:39:35.653 8113-8113/study.zgq.com.androidstudy D/nanwei: total tasks: 204-29 00:39:35.656 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 288 baseActivity: Main2Activity topActivity: Main2Activity04-29 00:39:35.661 8113-8113/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 287 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt; 可以看出，第一次启动Main2Activity后有两个任务栈，Main2Activity于一个新的任务栈中，且处于前台。再次启动Main2Activity，发现两个任务栈状态均未改变，但是回调了Main2Activity的onNewIntent。那么，我们在第二个栈中重新启动MainActivity呢？也就是MainActivity-&gt;Main2Activity-&gt;Main2Activity-&gt;MainActivity的启动顺序，这里是结果123456789101104-29 00:57:33.090 8522-8522/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 00:57:33.093 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 290 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;04-29 00:57:35.830 8522-8522/study.zgq.com.androidstudy D/nanwei: total tasks: 204-29 00:57:35.832 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 291 baseActivity: Main2Activity topActivity: Main2Activity04-29 00:57:35.835 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 290 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;04-29 00:57:38.594 8522-8522/study.zgq.com.androidstudy D/nanwei: total tasks: 204-29 00:57:38.597 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 291 baseActivity: Main2Activity topActivity: MainActivity04-29 00:57:38.602 8522-8522/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 290 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt; 可以看出来，在第二个任务栈中新创建了一个MainActivity。那么，我们可以将新创建的MainActivity压入第一个任务栈么？答案也是可以的：先修改manifest，给MainActivity指定taskAffinity：12345678910111213141516&lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:taskAffinity=&quot;com.test.main&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=&quot;.Main2Activity&quot; android:label=&quot;@string/title_activity_main2&quot; android:launchMode=&quot;singleTop&quot; android:taskAffinity=&quot;com.test&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot; /&gt; 同时在从Main2Activity启动MainActivity时添加1intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 还是按照MainActivity-&gt;Main2Activity-&gt;Main2Activity-&gt;MainActivity的启动顺序，看结果123456789101104-29 01:08:54.490 8840-8840/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 01:08:54.493 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 292 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;04-29 01:08:57.141 8840-8840/study.zgq.com.androidstudy D/nanwei: total tasks: 204-29 01:08:57.145 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 293 baseActivity: Main2Activity topActivity: Main2Activity04-29 01:08:57.148 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 292 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;04-29 01:09:00.084 8840-8840/study.zgq.com.androidstudy D/nanwei: total tasks: 204-29 01:09:00.089 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 292 baseActivity: MainActivity topActivity: MainActivity04-29 01:09:00.090 8840-8840/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 293 baseActivity: Main2Activity topActivity: Main2Activity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt; 可以看出来，在初始task内重新创建了一个MainActivity。 上面我们使用了一个Flag：FLAG_ACTIVITY_NEW_TASK，其实还有一个常见的Flag是FLAG_ACTIVITY_CLEAR_TOP，顾名思义，在启动Activity时，如果目标栈内已经有了实例，那么会弹出其上的所有Activity，然后回调onNewIntent方法(Activity launchMode为singleTop)或者销毁栈内的实例以及其上面的实例，重新创建新实例（Activity launchMode为standard）。举例如下：有MainActivity和Main2Activity，launchMode都是standard，启动顺序MainActivity-&gt;Main2Activity-&gt;MainActivity，其中MainActivity-&gt;Main2Activity是直接调用启动，Main2Activity-&gt;MainActivity时intent添加flag：FLAG_ACTIVITY_CLEAR_TOP。12345678910111213141504-29 22:49:51.307 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onCreate04-29 22:49:51.687 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume04-29 22:49:54.863 19805-19805/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 22:49:54.866 19805-19805/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 308 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔04-29 22:49:56.152 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onPause04-29 22:49:56.680 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onStop04-29 22:49:57.132 19805-19805/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 22:49:57.135 19805-19805/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 308 baseActivity: MainActivity topActivity: Main2Activity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔04-29 22:49:58.135 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onCreate04-29 22:49:58.167 19805-19805/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume04-29 22:49:59.280 19805-19805/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 22:49:59.284 19805-19805/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 308 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔 从上面可以看出来，standard模式的activity被带有FLAG_ACTIVITY_CLEAR_TOP的intent重新启动时，重新经历一次完整的生命周期，也就是说会弹出自身以及其上的所有activity，并重新创建一个新的实例，这也迎合了standard模式在任何情况下都会重新创建一个新实例。接着上面的例子，如果MainActivity launchMode是singleTop，那么结果是12345678910111213141504-29 22:43:57.198 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onCreate04-29 22:43:57.597 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume04-29 22:44:00.439 19471-19471/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 22:44:00.444 19471-19471/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 307 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔04-29 22:44:01.589 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onPause04-29 22:44:02.151 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onStop04-29 22:44:02.692 19471-19471/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 22:44:02.694 19471-19471/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 307 baseActivity: MainActivity topActivity: Main2Activity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔04-29 22:44:03.967 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onNewIntent04-29 22:44:03.968 19471-19471/study.zgq.com.androidstudy D/nanwei: ------------&gt;&gt;MainActivity onResume04-29 22:44:05.160 19471-19471/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 22:44:05.165 19471-19471/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 307 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔 可见singleTop模式的activity在被带有FLAG_ACTIVITY_CLEAR_TOP的intent启动时，会弹出其上所有activity，并回调onNewIntent，而不会创建新实例。这也迎合了singleTop可以（注意，只是可以）维持一个实例的特性。需要注意的是，FLAG_ACTIVITY_CLEAR_TOP起作用的是离栈顶最近的Activity，什么意思呢？比如当前栈内从低向上为A-A-A-B，然后B通过FLAG_ACTIVITY_CLEAR_TOP启动A，那么结果是A-A-A。 singleTask和singleInstance我们知道，假设有launchMode为singleTask的Activity1，如果任务栈中已经有了一个Activity1的实例，那么当重新要启动一个新的Activity1时，不会创建新的实例，而会将Activity1上的所有Activity全部弹出栈，然后回调onNewIntent。也就是说，同一个栈中，只能有一个Activity1的实例。那么，如果不同栈中呢？能同时各出现一个实例么？答案是否定的，为什么呢？因为如果要使同一个Activity的多个实例处于不同任务栈中，那么这个Activity势必要有多个不同的taskAffinity，而Android是不支持多个taskAffinity的，这也违反task的设计理念。所以singleTask的Activity在系统中唯一实例。需要提醒的是，官方文档中对于singleTask的解释：”系统创建一个新的任务栈和一个新的activity实例，将activity实例放在栈底“，上面这句话其实是有待商榷的，因为他的实现是有限制的，如果我们仅仅将Activity的launchMode设置为singleTask，那么在启动时，并不会像上面所说，创建新的任务栈然后放入栈底，二是和standard模式一样，直接创建一个新的放入栈顶。如下例：MainActivity是standard模式，Main2Activity是singleTask模式，启动顺序MainActivity-&gt;Main2Activity。12345604-29 23:15:20.774 21777-21777/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 23:15:20.779 21777-21777/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 316 baseActivity: MainActivity topActivity: MainActivity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔04-29 23:15:23.071 21777-21777/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 23:15:23.075 21777-21777/study.zgq.com.androidstudy D/nanwei: numActivities: 2 affiliatedTaskId: 316 baseActivity: MainActivity topActivity: Main2Activity ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔 从结果可以看出，Main2Activity的表现和standard模式一致，那么怎么才能出现文档的情况呢？那就是设置Main2Activity的taskAffinity，可以说，taskAffinity是判断是否创建新任务栈的唯一考量标准。 而singleInstance和singleTask的特性基本一致，区别在于，singleInstance是唯一一个存在于任务栈的activity，不可能有其他的activity，比如有MainActivity(standard)和Main2Activity(singleInstance)，MainActivity启动Main2Activity，结果是12345604-29 23:31:36.685 22677-22677/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 23:31:36.690 22677-22677/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 318 baseActivity: MainActivity topActivity: MainActivity04-29 23:31:36.691 22677-22677/study.zgq.com.androidstudy D/nanwei: ================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔04-29 23:31:40.102 22677-22677/study.zgq.com.androidstudy D/nanwei: total tasks: 104-29 23:31:40.104 22677-22677/study.zgq.com.androidstudy D/nanwei: numActivities: 1 affiliatedTaskId: 319 baseActivity: Main2Activity topActivity: Main2Activity================================&gt;&gt;&gt;&gt;&gt;&gt;&gt;启动分隔 可以看出，taskAffinityId发生了变化，也即是说，启动Main2Activity后，新建了一个新的任务栈，然后把Main2Activity放入栈底。 总结 standard模式任何时候都会重新创建实例，包括被FLAG_ACTIVITY_CLEAR_TOP启动时 对于能维护一个单例的模式，在使用FLAG_ACTIVITY_CLEAR_TOP时，都会回调onNewIntent，singleTop具有（注意，只是具有，并不是肯定是只有一个实例）维持同一个实例的特性，singleTask和singleInstance都是单例 taskAffinity和singleInstance是考量是否创建新任务栈的唯二参考]]></content>
  </entry>
  <entry>
    <title><![CDATA[java虚拟机结构]]></title>
    <url>%2F2019%2F05%2F05%2Fjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[pc寄存器 虚拟机栈 栈帧 随着方法调用创建，随着方法结束 可以在堆中分配 局部变量表 操作数栈，真正的计算发生在这里 当前方法所属类的运行时常量池 堆 本地方法栈 c stack 方法区 内存共享 堆的逻辑部分，可以不实现垃圾回收 运行时常量池 加载类或接口到虚拟机后，就会创建运行时常量池]]></content>
  </entry>
  <entry>
    <title><![CDATA[单例]]></title>
    <url>%2F2019%2F05%2F03%2F%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[什么是单例模式单例模式可以使一个类只有一个对象，能减少频繁创建对象的时间和空间开销。单例模式需要注意的点 构造方法私有 如果是延迟加载，对象实例需要私有； 注意线程安全 单线程单例单线程模式下一个典型的单例模式代码如下：12345678910public class SingleInstance1 &#123; private static SingleInstance1 instance; private SingleInstance1() &#123;&#125; public static SingleInstance1 getInstance()&#123; if (instance == null) &#123; instance = new SingleInstance1(); &#125; return instance; &#125;&#125; 单线程下是没问题的，但多线程下会出现创建出多个实例的情况。 多线程单例上面的代码无法保证线程安全，解决方法也很简单，加锁12345678910public class SingleInstance2 &#123; private static SingleInstance2 instance; private SingleInstance2()&#123;&#125; public synchronized static SingleInstance2 getInstance()&#123; if (instance == null) &#123; instance = new SingleInstance2(); &#125; return instance; &#125;&#125; 加锁固然简单，但是也带来了性能的损耗，每次请求实例时都要请求锁，且如果两个线程同时请求获得对象实例时，要排队等待。其实呢，为了保证线程安全，也就是保证不会出现多个实例，我们只要对instance = new SingleInstance2()加锁即可123456789101112public class SingleInstance3 &#123; private volatile static SingleInstance3 instance; private SingleInstance3() &#123;&#125; public static SingleInstance3 getInstance()&#123; if (instance == null) &#123; //1 synchronized (SingleInstance3.class)&#123; //2 instance = new SingleInstance3(); //3 &#125; &#125; return instance; &#125;&#125; 但是这样呢有重新暴露出了线程安全的问题，比如线程A在代码1处判断为空后，资源让给线程B，线程B在1处同样判断为空后，资源返回给A，A获得锁，创建实例返回，B获得资源然后获得锁，同样还是会重新创建实例。怎么解决呢？就是在获得锁之后，重新进行一次空判断。1234567891011121314public class SingleInstance3 &#123; private volatile static SingleInstance3 instance; private SingleInstance3() &#123;&#125; public static SingleInstance3 getInstance()&#123; if (instance == null) &#123; synchronized (SingleInstance3.class)&#123; if (instance == null) &#123; instance = new SingleInstance3(); //1 &#125; &#125; &#125; return instance; &#125;&#125; 上面的代码看似完美，其实还是有隐藏问题，什么问题呢？问题出在instance = new SingleInstance3()这行代码上，其实new一个新对象并不是一个原子操作，是分步的： memory=allocate()分配对象的内存空间。 createInstance()初始化对象 instance=memory 设置instance指向刚分配的内存大致来讲就是上面三步，但是由于java指令重排序优化的存在，会导致第二步和第三步没有绝对的先后顺序，在实例运行过程中，完全有可能出现1-&gt;3-&gt;2的顺序，那么表现在上面的代码中是什么情况呢：线程A执行到代码1处，先分配对象内存空间，再将instance指向刚分配的空间，然后资源让给线程B，线程B检查instance时候为空，判断结果是非空，直接返回使用，这时返回的是还未完全初始化好的实例，使用的话肯定会出错。解决办法是使用volatile修饰instance，volatile的重要作用就是禁止指令重排序，保证不会出现1-&gt;3-&gt;2的执行顺序，同时volatile保证在写之前会同步最新的数据 happens-beforevolatile变量规则：这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[死锁知识点]]></title>
    <url>%2F2019%2F05%2F03%2F%E6%AD%BB%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[什么是死锁两个线程分别是线程1和线程2。线程1执行过程中，先获得对象a的锁，然后要再获得b的锁才能继续执行代码；而线程2正巧相反，先获得对象b的锁，然后要再获得a的锁才能继续执行代码。这时，两个线程都等着对方解锁，才能继续执行，这时，两个线程就进入等待状态，最终不会有线程执行。这就变成了死锁。 简单的死锁代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class DeadLockTest implements Algorithm &#123; public Object object1 = new Object(); public Object object2 = new Object(); @Override public void execut() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Utils.printString(&quot;=====&gt;&gt;thread 1 running&quot;); Lock1.test(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; Utils.printString(&quot;=====&gt;&gt;thread 2 running&quot;); Lock2.test(); &#125; &#125;).start(); &#125; public static class Lock1 &#123; public static synchronized void test()&#123; try &#123; Utils.printString(Thread.currentThread().getName() + &quot; get lock1&quot;); Thread.sleep(500); Utils.printString(Thread.currentThread().getName() + &quot; try to get lock2&quot;); Lock2.test(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static class Lock2 &#123; public static synchronized void test()&#123; try &#123; Utils.printString(Thread.currentThread().getName() + &quot; get lock2&quot;); Thread.sleep(1000); Utils.printString(Thread.currentThread().getName() + &quot; try to get lock1&quot;); Lock1.test(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果123456=====&gt;&gt;thread 1 running=====&gt;&gt;thread 2 runningThread-0 get lock1Thread-1 get lock2Thread-0 try to get lock2Thread-1 try to get lock1]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于注解应该知道的]]></title>
    <url>%2F2019%2F05%2F03%2F%E5%85%B3%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%2F</url>
    <content type="text"><![CDATA[什么是注解其实注解并不复杂，使用注解一定会有三个过程：定义注解，使用注解，读取注解。我们一步一步来看： 定义注解定义没什么好说的12345@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Six&#123; String name() default &quot;nanwei&quot;;&#125; 使用@interface定义注解 @Target和@Retention是元注解，就是注解的注解。。。。。，一共四种 Target表示注解的作用目标，看代码 123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125; ElementType是一个枚举类，包括type，field，method等常见的注解目标 Retention定义注解的保留策略 123@Retention(RetentionPolicy.SOURCE) //注解仅存在于源码中，在class字节码文件中不包含@Retention(RetentionPolicy.CLASS) // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得，@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到，正常来说定义在运行时才能发挥大作用 Document：说明该注解将被包含在javadoc中，生成java文档的时候会用到 Inherited：说明子类可以继承父类中的该注解，这里要注意的是，仅类的注解可以被集成，接口的不行，类内的变量和方法也不行 定义值，关键字default表默认值，仅支持基本类型和String，不支持Object，因为注解参数是一种编译时常量，那时候还没有对象呢，这算是java的一个设计缺陷吧，不知道以后会不会改进 使用注解使用注解就很简单了，Override什么的我们也经常用，上面我们自己定义的也一样用12345678public class Student implements Algorithm&#123; @Six(name=&quot;666&quot;) public String name; public void setName(String name)&#123; this.name = name; &#125;&#125; 我们看到name这个类变量有一个Six注解，参数666，好了，我们新建一个Student类，打印它的名字：12Student student = new Student();Utils.printString(&quot;=======&gt;&gt;&gt;&gt;1: &quot; + student.name); 结果1=======&gt;&gt;&gt;&gt;1: null 好像这个注解并没有起什么作用，这是因为，这个注解虽然被编译进了class文件，加载类之后也进入了运行时，但是因为我们没有做解析这个注解的操作，所以没有生效，那么怎么解析呢？使用反射，这就是解析注解这一步 解析注解1234567891011121314151617181920public class SixProcessor &#123; public static Student process(Student student) &#123; Field[] fields = student.getClass().getFields(); for (int i = 0; i &lt; fields.length; i++) &#123; Six six = fields[i].getAnnotation(Six.class); if (six != null)&#123; try &#123; student.getClass().getMethod(&quot;setName&quot;, String.class).invoke(student, six.name()); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return student; &#125;&#125; 可以看到，上面对Student对象的所有类变量遍历，检查是否有Six注解，如果有，则把注解的参数值赋给Student的name：12SixProcessor.process(student);Utils.printString(&quot;=======&gt;&gt;&gt;&gt;2: &quot; + student.name); 结果是1=======&gt;&gt;&gt;&gt;2: 666 注解有什么作用呢基于上述注解的特性，注解的主要作用有： 编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】]]></content>
  </entry>
  <entry>
    <title><![CDATA[new的时候发生了什么]]></title>
    <url>%2F2019%2F04%2F09%2Fnew%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[类加载器ClassLoader是负责加载类的对象。ClassLoader类是一个抽象类，给定一个类的二进制名（任何一个类都有一个根据JLS规范定义的String类型的二进制名，ClassLoader中使用该名进行加载，其实在jni开发中，用的也是这个，详见jni tips），典型的策略是将二进制名转换成文件名然后从文件系统读取class文件。每个class都包含一个classloader的引用，数组类型的class不是有classloader创建的，而是在运行时由java runtime自动创建，数组类型获取classloader时，返回的是数组元素的类型。如果数组元素是基本类型或者是由bootstrap classloader加载的类（比如rt.jar包），那么没有classloader。如下代码： 1234567891011121314Utils.printString(&quot;string class: &quot; + String.class);Utils.printString(&quot;string class classloader: &quot; + String.class.getClassLoader());int[] intArr = &#123;0,4,1&#125;;Utils.printString(&quot;int array class: &quot; + intArr.getClass());Utils.printString(&quot;int array classloader: &quot; + intArr.getClass().getClassLoader());String[] stringArr = &#123;&quot;545&quot;&#125;;Utils.printString(&quot;string array class loader: &quot; + stringArr.getClass());Utils.printString(&quot;string array class loader: &quot; + stringArr.getClass().getClassLoader());ClassLoaderTest[] tests = &#123;new ClassLoaderTest()&#125;;Utils.printString(&quot;refre array class: &quot; + tests.getClass());Utils.printString(&quot;refre array class loader: &quot; + tests.getClass().getClassLoader()); 输出12345678string class: class java.lang.Stringstring class classloader: nullint array class: class [Iint array classloader: nullstring array classloader: class [Ljava.lang.String;string array classloader: nullrefre array class: class [Lcom.zgq.java.ClassLoaderTest;refre array classloader: sun.misc.Launcher$AppClassLoader@4b67cf4d 由上面得到结论 数组类型的ClassLoader是其元素的ClassLoader，如果元素ClassLoader为空，那么数组ClassLoader也为空 由于String在rt.jar包中，是有bootstrap加载的，所以getClassLoader返回空 int数组的class类型是[I，java语言规范中，[表示数组类型，I表示int 程序中继承classloader来实现自己的classloader，这样可以延用jvm的动态加载机制。类加载器常用于安全管理机制，保证安全域。ClassLoader使用代理模式来寻找类或者资源，每个ClassLoader都有一个父ClassLoader，当要请求查找一个新的类或者资源时，ClassLoader的实例自身在搜索前，会让父ClassLoader先去查找。jvm内建的ClassLoader叫bootstrap classloader，这个加载器没有父加载器，但是可以作为其他类加载器的父引用。支持同步加载的类加载器叫parallel capable class loader，这样的类加载器在初始化的时候需要注册方法ClassLoader.registerAsParallelCapable，注意ClassLoader默认注册了改方法，但是，他的子类如果想支持同步还要重新注册。某些条件下，代理模型并不是严格分级的，ClassLoader需要支持并发，否则加载类的过程可能引起死锁。详见loadClass方法。一般情况下，jvm从本地文件系统加载类，比如在UNIX系统下，会直接从CLASSPATH环境变量指定的路径中加载。但是，有时候类文件是从其他方法比如网络上下载下来，这时我们可以使用defineClass方法将byte数组转换成类文件。新定义的类可以通过Class.newInstance创建实例。自定义类加载器，需要注意两个方法，一个是defineClass，是一个final方法，由ClassLoader定义，这个方法把我们读入的字节数组转换成Class对象。另一个是要覆写findClass方法，这个方法会在委托失败后被调用：123456789101112class NetworkClassLoader extends ClassLoader &#123; String host; int port; public Class findClass(String name) &#123; byte[] b = loadClassData(name); return defineClass(name, b, 0, b.length); &#125; private byte[] loadClassData(String name) &#123; // load the class data from the connection . . . &#125;&#125; 这个类加载器的加载流程为：因为没有指定父加载器，所以会先由bootstrap class loader加载，bootstrap class loader加载失败后再由NetworkClassLoader定义的findClass加载类 数组的类数组类型的ClassLoader有可能是bootstrapclassloader，也可能是用户自定义ClassLoader。如果元素类型为C的数组已经被初始化过，也就是说已经有classLoader加载过元素类型为C的数组，那么，这时候已经有了该元素类型的数组类型，等再次创建该元素类型的数组时，不需要创建新的数组类型。1234//这时JVM已经有了一个class为[Ljava.lang.string的数组类型String[] stringArr = &#123;&quot;545&quot;&#125;;//这时JVM不会再创建一个[Ljava.lang.string的类型String[] stringAr1 = &#123;&quot;444&quot;&#125;; 如果数组元素是引用类型，那么也会按照一般规则向上递归，加载所有父类。 JVM根据数组元素类型和数组的维度(注意是维度，不是长度，一维数组是[,二维数组是[[)创建数组类型 如果数组元素是引用类型，那么结果数组类型的ClassLoader和元素的ClassLoader一致，否则就是bootstrap ClassLoader 任何情况下，JVM都将(1)里的ClassLoader作为数组类型的初识ClassLoader 如果数组元素是引用类型，那么数组类型的访问权限由元素的访问权限决定，否则就是public 类的加载过程类从被加载到JVM中开始，到卸载为止，整个生命周期包括加载、连接、初始化、使用、卸载，其中连接又分为三步：验证、准备、解析。 官方文档在这里，java虚拟机规范第五章详细讲了类加载过程的几个阶段，章首有一段非常概括的话：java虚拟机动态的加载、链接和初始化类和接口。加载是虚拟机根据特定的名称查找类或者接口的二进制表示，然后从这个二进制表示创建类或接口的过程。链接是为了让类或者接口能被虚拟机执行，而将类或接口并入虚拟机运行时的过程。类或接口的初始化过程就是执行类或接口的初始化方法。文档从5个方面阐述了类和接口的加载过程： 运行时常量池，虚拟机从类或接口的二进制表示中获取字符引用，其实就是使用class文件中的常量池表构建运行时常量池。 虚拟机启动时是怎样的加载、链接、初始化过程 类或者接口的二进制表现是如何被类加载器加载并创建类和接口 详细解释链接过程 类和接口的初始化过程 绑定本地方法的概念 运行时常量池虚拟机的内存结构中，有块逻辑区域叫方法区，方法区是可供各个线程共享的运行时内存区域。方法区与传统语言中编译代码存储区非常相似，存储了每个类的结构信息，例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，还有一些特殊函数，比如类、实例、接口的初始化函数。方法区是堆的逻辑组成部分，但是简单的虚拟机可以不实现垃圾回收与压缩，方法区大小可以固定也可以动态扩展，但如果方法区内存不足，会报OutOfMemoryError。在创建类或接口时，虚拟机会根据类或接口的二进制表示中的常量池表来构造运行时常量池,运行时常量池初始时都是符号引用，这些符号是按照以下方法在类或接口的二进制表示中得出的，以类或接口的名称为例： 类或接口的符号引用来自常量池表中的CONSTANT_Class_info，这种引用提供类或接口的名称 对于非数组的类或接口，这个名称就是类或接口的二进制名称 对于n维数组，会以n个[开头，后面跟数组元素类型 如果数组元素类型是基本类型，有对应的字段描述符，比如int以I表示 如果数组元素类型是引用类型，则以L加上元素的二进制名称，并以;结束 类或接口中的字段的符号引用来自类或接口的二进制表示中的CONSTANT_Filedref_info结构，这种引用包括了字段名称和描述符，以及指向字段所属类或接口的符号引用此外还有方法、方法句柄、方法类型以及调用点限定符的符号引用，这里不在赘述…..需要注意的是字符串常量，字符串常量是指向String类实例的引用，它来自类或接口的二进制表示中的CONSTANT_String_info结构。CONSTANT_String_info给出了由Unicode码点序列组成的字符串常量。java规定，相同的字符串常量，也就是包含同一份Unicode码点序列的常量，必须指向同一个String实例。此外，如果在任意字符串上调用String.intern方法，那么其返回的String实例，必须和直接以常量形式出现的字符串实例完全相同，即下式永远为true：1(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;; 这里要注意的是字符串的创建方式对引用值的影响，举例如下：123456789//这样创建的字符串，会先检查方法区中字符串常量池中是否有值相等的实例，如果有，直接返回那个实例的引用给a，否则创建一个值为test的实例，再将引用返回给aString a = &quot;test&quot;;String b = &quot;test&quot;;Utils.printString(&quot;a == b is&quot; + (a == b));//这样创建的字符串，会先在堆上创建一个String实例，引用地址返回给c，然后JVM会去方法区中的字符串常量池查看是否有&quot;test&quot;字符串的对象，没有的话就分配一个空间来存放&quot;test&quot;，并将其空间地址存入堆中new出来的对象中；直接将那个实例存入堆中new出来的对象中String c = new String(&quot;test&quot;);String d = new String(&quot;test&quot;);Utils.printString(&quot;c == d is&quot; + (c == d));Utils.printString(&quot;a == c is&quot; + (a == c)); 所以上面代码结果123a == b is truec == d is falsea == c is false 而上面intern方法的作用就是，如果字符串常量池中存在值相等的字符串实例，则返回，否则在字符串常量池中创建一个实例并返回。 虚拟机启动引导类加载器（boostrap class loader）创建一个初始类，然后虚拟机链接该初始类，初始化它并调用他的void main(String[] args)方法 创建和加载如果要创建标记为N的类或接口C，需要在java虚拟机的方法区上为C创建与虚拟机实现相匹配的内部表示。C的创建是由另一个类D触发的，它通过自己的运行时常量池引用了C，比如D中包含C的引用。当然，反射或者一些特殊方法也可能触发。类加载器L可能直接定义或委托其他类加载器的方式来创建C，如果L直接定义了C，那么说L是C的定义加载器。而类加载器在加载时，有可能将加载请求委托给别的类加载器完成，那么这时候可以说是L导致了C的加载，或者说L是C的初始加载器。虚拟机运行时，类或者接口不仅仅由它的名称来确定，而是由名称和类加载器共同确定D触发创建C，如果D是由引导类加载器加载，那么C也由引导类加载器加载，如果D由用户自定义类加载器加载，那C也由用户自定义类加载器加载。也就是说两者一致。 链接链接类或接口包括验证和准备类或接口，它的直接父类，它的直接父接口，它的元素类型（如果是一个数组）。解析这个类或者接口的符号引用是可选的。java虚拟机允许灵活的选择链接时机，但必须抱枕 链接前成功加载过 初始化前成功验证和准备过 当程序执行某个可能直接或间接链接一个类或接口的工作时，而在链接过程中出错，那错误的抛出点应该在执行动作的点虚拟机没有强制规定解析符号引用的时机，可以在使用到类或接口的符号引用时才去逐一解析（延迟解析），也可以在验证类的时候就解析每个引用（预先解析）。 验证确保类或者接口的二进制表示在结构上是正确的。验证静态约束和结构化约束，见4.9节。如果虚拟机尝试验证类或接口，但因为抛出LinkageError或LinkageError子类的实例而导致失败，则之后对此类的验证总会因为相同原因失败。 准备准备阶段的任务是创建类或者接口的静态字段，并用默认值初始化这些字段。这个阶段不会执行任何的虚拟机字节码指令。解析 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那么引用的目标一定是已经存在于内存中 解析是根据运行时常量池里的符号引用来动态决定具体值的过程。或者说解析就是把符号引用转换成直接引用的过程： 运行时常量池里字段的符号引用作为字段的”唯一标识符“（class+NameAndType），确定其是什么引用类型，从而由jvm定位到该类的结构体的内存地址 运行时常量池里字段的符号引用作为方法的”唯一标识符“（class+NameAndType），确定改方法是哪个类的，再根据NameAndType从方法表中找到对应的方法同理还有类和接口解析，普通方法解析……其至于这个过程发生了什么，参照知乎收藏。这里先不展开描述。初始化初始化对类和接口来说，就是执行它的初始化方法。到了这个阶段才真正开始执行类中定义的Java程序代码（或者说是字节码）。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。 tip]]></content>
  </entry>
  <entry>
    <title><![CDATA[null是什么]]></title>
    <url>%2F2019%2F04%2F09%2Fnull%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[null是什么我们会围绕这几个问题进行探讨 null属于什么类型 null是某个具体的实例么 null是什么 null在内存中怎么表示我们从null属于什么类型说起 在Java Language Specification chapter4–Types, Values, and Variables中有介绍.java中数据有两种类型，基本类型和引用类型，基本类型又分NumericType和boolean，NumericType就包括我们常说的整型（int，long，short，byte，char）以及浮点型（float，double）。那么除了这两种类型之外，JLS里着重说了null这种特殊的类型。 There is also a special null type, the type of the expression null (§3.10.7, §15.8.1), which has no name.Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type.The null reference is the only possible value of an expression of null type.The null reference can always be assigned or cast to any reference type (§5.2, §5.3, §5.5).In practice, the programmer can ignore the null type and just pretend that null is merely a special literal that can be of any reference type. 这里说null是一种特殊的类型，这个类型表示它的字面意思null，并且没有名称。因为null类型没有名称，所以我们不能声明一个null类型的对象，也不能把别的类型转换成null类型。null类型唯一可能的值就是null引用，虽然有点拗口，理解成，null表示的就是他的字面意思就好了。null引用可以赋给任何引用类型，也可以转换成任意引用类型。程序员就把null看成字面意思就好了。所以null究竟是什么类型JLS已经说清楚了，针对上面的介绍我写了一个类验证了下12345678910111213141516171819public class NullTest implements Algorithm &#123; @Override public void execut() &#123; ((Anything)null).printStatic(); Utils.printString(&quot;&quot; + ((Anything)null)); ((Anything)null).print(); &#125; public static class Anything &#123; public static void printStatic()&#123; Utils.printString(&quot;in static&quot;); &#125; public void print()&#123; Utils.printString(&quot;in not static&quot;); &#125; &#125;&#125; 上面程序的运行结果是12345678910in staticnullException in thread &quot;main&quot; java.lang.NullPointerException at com.zgq.java.NullTest.execut(NullTest.java:14) at com.zgq.Main.main(Main.java:15) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144) 可见静态方法是可以输出的，因为是类的方法，而null转对象结果还是null。用null去调实例方法自然要报空指针。说到这第二个问题就很明显了，null显然不是某个具体的示例。那么，null是什么呢？这个问题很难直接回答，或者说很难按照正常的逻辑去回答，我们在学java的时候，会有一种感觉，一切都是对象，一切且有源头，任何对象任何类我都能从源码去一窥一二，可是null不行，我们无法直接拿出证据去精确的描述它，但是我们可以更实际一些的从他的作用来分析null是什么： java中，null == null是永远返回true的 对于非空引用t，t.equals(null)返回false null是一切引用类型的初始值 null用来表示不存在的对象 null表示未知的值 null表示某种情况的终点 HashMap中的key和value都可以是null，但这就带来一个问题：假设一个map，key和value都是Integer，map中包含一个键值对4-null，那么map.get(4)返回值是null，如果map中没有键值4，那么返回值还是null，这就产生语义冲突。当然java的HashTable是不存在这个问题的，这里不细说。 null在内存里是什么样的？我们从其他方面侧面看下1String s = null; 上面这行代码做的唯一一件事就是给s分配一个引用的内存空间，可能是32位，也可能64位，和硬件及java版本有关，这里不会给null分配任何的内存空间，因为null不是一个具体的对象。它像一个占位符一样表示这个引用还没有指向具体的对象。可能这个占位符就是个0，谁知道呢？ 以下为个人想法，首先null这种特殊的引用类型在内存中肯定是存在的（废话），但是怎么存在的呢？我们看下equals方法 123 public boolean equals(Object obj) &#123; return (this == obj);&#125; 我们知道t.equals(null)返回false，可见对null的equals判断是在运算符中做的，线索断了，暂时未找到切入点。]]></content>
  </entry>
  <entry>
    <title><![CDATA[对于枚举enum该知道的]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%AF%B9%E4%BA%8E%E6%9E%9A%E4%B8%BEenum%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%2F</url>
    <content type="text"><![CDATA[枚举的由来首先是枚举类型的由来，在编程语言还没有引入枚举类型之前，程序员用来表示枚举类型的模式一般是声明一组具名的int常量，比如表示水果Fruit：1234public static final int APPLE_FUJI = 0;public static final int APPLE_PIPPIN = 1;public static final int ORANGE_NAVEL = 2;public static final int ORANGE_TEMPLE = 3; 这叫int枚举模式，这种模式有很多缺陷，在类型安全性和使用方便性上没有任何帮助。因为都是int类型，所以需要apple类型的时候传入orange编译器也不会报错。甚至apple和orange之间还能使用==进行比较而不会出现编译错误，这样带来的后果是灾难性的，隐藏的bug很难找出来。另外这种模式对于debug也很不方便（都是数字，没有太大用处）。也有一种模式使用String代替int，叫String枚举模式，但是导致性能问题，因为很依赖字符串操作；而且字符串书写错误也会造成很多问题，因为编译时并不会报错。 所以java1.5开始，提出了enum类型，也就是今天的主角。使用枚举写上面的代码是这样的：123456public enum Apple &#123; FUJI,PIPPIN&#125;public enum Orange &#123; NAVEL,TEMPLE&#125; 看着简单，其实内部还是挺复杂的，而且功能也非常强悍。 枚举的核心首先要明确的是枚举的本质还是int值。但是这个int值没有完全的暴露给开发者（当然可以通过ordinal获得，其实就是序数），事实上大部分情况我们都不需要这个int值。枚举类型背后的基本想法很简单，枚举就是通过公有静态final域为每个枚举常量导出实例的类。枚举没有可以访问的构造器，所以是真正的final。我们不能继承枚举，不能new枚举实例，甚至可能没有实例（如果没有生命枚举常量）。也就是说枚举是实例受控的。想要了解一个枚举背后的东西，我们反编译下，看看class文件就明白了，我们反编译下Apple枚举：可以看到，编译后的Apple其实就是一个继承了Enum的普通类，只是多了一个ACC_ENUM标志位。在看class的内容，成员变量里有两个static final变量，分别是FUJI和PIPPIN，这就是我们声明的那两个枚举变量。这两个变量都有final、static、enum标志位。当然这里的例子只是讲了最简单的枚举，枚举的巧妙用法在后面说，同时也会通过反编译获得更多的信息。 枚举的用法-方法和域枚举允许添加任意的方法和域，这使得我们可以将数据与枚举变量关联起来，这个特性会极大的增强枚举的能力。比如下面的例子123456789101112131415161718192021public enum Person &#123; MAN(20),WOMEN(15); private final int height; private Person(int height)&#123; this.height = height; &#125; public int getHeight()&#123; return height; &#125; public int getWeight()&#123; switch (this)&#123; case MAN: return height * 10; case WOMEN: return height * 5; default: break; &#125; return 0; &#125;&#125; 一个可以返回男女身高体重，还能根据类型区分计算的Person类，是不是很方便,我们反编译下看看：常量池多了一个int类型的非静态height变量，说明这是变量是要由对象维护的，哪个对象呢？自然是Person的两个实例MAN和WOMAN。这里多了两个非静态的getHeight和getWeight方法。所以说，在编译器编译过后，枚举就是一个普通类。 枚举的用法-枚举变量和行为上面介绍的方法几乎能满足所有情况了，但是还是有写情况不满足。比如下面：123456789101112131415161718192021222324252627public enum Fruit &#123; APPLE(5, 30), ORANGE(2, 40); private final int size; private final int num; Fruit(int size, int num)&#123; this.size = size; this.num = num; &#125; public int getSize()&#123; return size; &#125; public int getNum()&#123; return num; &#125; public int getTotalWeight()&#123; switch (this)&#123; case APPLE: return size * num + 1; case ORANGE: return size * num + 2; default: break; &#125; return size * num; &#125;&#125; 计算每种水果的重量的时候会根据不同水果区别计算，那么，假设，有一天新加了BANANA这个水果，但却忘了给switch增加相应的条件，那么返回结果必然是错的。这个时候就可以考虑使用抽象方法12345678910111213141516171819202122232425262728public enum Fruit &#123; APPLE(5, 30)&#123; @Override int getCustomWeight(int size, int num) &#123; return size * num + 5; &#125; &#125;, ORANGE(2, 40)&#123; @Override int getCustomWeight(int size, int num) &#123; return size * num + 6; &#125; &#125;; private final int size; private final int num; Fruit(int size, int num)&#123; this.size = size; this.num = num; &#125; abstract int getCustomWeight(int size, int num); public int getSize()&#123; return size; &#125; public int getNum()&#123; return num; &#125;&#125; 这样在声明新的枚举常量时必须实现这个抽象方法，也就不会忘了。一看到这个抽象方法，直觉告诉我们，既然编译后都是普通类，有需要实现抽象方法，那肯定会有新的类产生了，反编译看下果然，编译后生成了三个内部类，其中前两个分别实现了抽象方法，因为javap不能直接反编译内部类，所以这里无法判断这两个内部类的继承关系，不过应该是继承了外部类，因为下图猜测的：Fruit拥有的两个实例类型都还是Fruit，所以是Fruit$1和Fruit$2分别继承了Fruit并实现了抽象方法，也就是说具体起作用的是这两个实现类。另外由于Fruit是抽象类，所以还需要一个Fruit$3还继承实现它。 枚举策略通过上面的分析介绍，我们知道，当希望将枚举常量与数据以及行为联系起来时，可以通过switch语句，缺点是不够安全，可能忘了相应的case，也可以通过抽象方法，但是这可能会导致大量样板代码的出现，比如12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public enum Fruit &#123; APPLE(5, 30)&#123; @Override int getCustomWeight(int size, int num) &#123; return size * num + 5; &#125; &#125;, APPLE_1(5, 30)&#123; @Override int getCustomWeight(int size, int num) &#123; return size * num + 5; &#125; &#125;, ORANGE(2, 40)&#123; @Override int getCustomWeight(int size, int num) &#123; return size * num + 6; &#125; &#125;; private final int size; private final int num; Fruit(int size, int num)&#123; this.size = size; this.num = num; &#125; abstract int getCustomWeight(int size, int num); public int getSize()&#123; return size; &#125; public int getNum()&#123; return num; &#125; public int getTotalWeight()&#123; switch (this)&#123; case APPLE: return size * num + 1; case ORANGE: return size * num + 2; default: break; &#125; return size * num; &#125;&#125; 这里Apple和Apple_1的重量计算方式一模一样，但又不得不都实现一遍，这就是缺陷，那么这时候枚举策略的代码方式就有用了123456789101112131415161718192021222324252627public enum Flower &#123; Rose_Red(Pricetype.Rose),Rose_Yellow(Pricetype.Rose),Tulip(Pricetype.Tulip); private Pricetype pricetype; private Flower(Pricetype pricetype)&#123; this.pricetype = pricetype; &#125; public int getTotalMoney(int num) &#123; return pricetype.price(num); &#125; private enum Pricetype &#123; Rose&#123; @Override int price(int num) &#123; return num * 5; &#125; &#125;, Tulip &#123; @Override int price(int num) &#123; return num * 6; &#125; &#125;; abstract int price(int num); &#125;&#125; 几个方法valueOf:valueOf让我们根据枚举常量的String名得到枚举常量，Enum类里有实现12345678910public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType,String name) &#123; //Class类里专门为枚举类维护了一个map，存储String与Enum的键值对 T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException(&quot;Name is null&quot;); throw new IllegalArgumentException( &quot;No enum constant &quot; + enumType.getCanonicalName() + &quot;.&quot; + name);&#125; values:遍历所有枚举，顺序是序数，该方法在编译时生成 end]]></content>
  </entry>
  <entry>
    <title><![CDATA[volatile]]></title>
    <url>%2F2019%2F04%2F07%2Fvolatile%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[生产者消费者模式]]></title>
    <url>%2F2019%2F04%2F07%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者问题能够让我们对并发编程的理解加深。生产者消费者模式，主要探讨的问题是，两个线程（生产者与消费者），一块共享区域，生产者负责生产同时操作共享区域，消费者负责消费同时操作共享区域，在这个过程中，生产者与消费者没有任何耦合，互相不关心对方的行为，那么这种情况下，考虑如下场景：假如共享区域有商品5个，消费者消耗一个商品后去检查数量时，消费者期待的是还剩下4个，但是由于没有做线程并发协作，在消耗完商品后的时间点，生产者刚好生产好一个商品并要将商品数量+1，在+1之后，消费者才去检查数量，这时候的数量还是5与他的期望不符，这就是问题所在，我们讨论的也都是要解决这个问题。当然，除了上述假设情况之外，我们还得考虑，共享区域的数据变化如何阻塞及唤醒线程 如果共享数据区已满的话，阻塞生产者继续生产数据放置入内 如果共享数据区为空的话，阻塞消费者继续消费数据其实说到底，就是要实现线程同步，java中实现线程同步的方法主要有 Sychronized，对应的要使用Object的wait和notify机制 Lock，对应的要使用Lock的Condition的await/signal机制另外，使用BlockingQueue也能实现生产者消费者模式 wait notify机制java的Object类里有这么几个方法至关重要 wait该方法用来将当前线程置入休眠状态，直到接到这个对象调用了notify或者notifyAll，或者超过一个指定的超时时长。当前线程必须拥有这个对象的monitor，也就是必须获得这个对象的锁才能调用，否则会报java.lang.IllegalMonitorStateException错误。该方法会将当前线程（就是获得锁的那个，假设为线程A）放进这个对象的wait set中，并且线程A会放弃所有获取对该对象锁的主张，线程A停止执行并进入休眠，直到下面四个情况之一出现： 其他线程调用该对象的notify，并且线程A刚好被选中唤醒（是否被选中与操作系统实现有关） 其他线程调用该对象的notifyAll 其他线程打断线程A，中断线程会抛出InterruptedException异常，因此，sleep和wait都要catch或者抛出这个异常 指定的超时时长已经过去，如果超时时长为0，那么线程会直接进入休眠线程A被唤醒后会和其他被唤醒的线程竞争获得对象锁，一旦成功获得锁，线程A的锁信息就会全部记录下来，然后线程A就可以从wait中返回，并继续执行下去。wait只能出现在循环中，因为唤醒的时候可能还是不满足执行条件如果在线程wait前或者wait中被打断，那么会抛出一个InterruptedException异常，并且直到对象锁状态被重新存储后才会抛出。在调用 wait()之前，线程必须要获得该对象的对象监视器锁，即只能在同步方法或同步块中调用 wait()方法。调用wait()方法之后，当前线程会释放锁。如果调用wait()方法时，线程并未获取到锁的话，则会抛出IllegalMonitorStateException异常，这是以个RuntimeException。如果再次获取到锁的话，当前线程才能从wait()方法处成功返回。 wait(long timeout)timeout时间后会唤醒线程，重新竞争锁。timeout是最长时间，具体时长会有误差 wait(long timeout, long nanos)文档里说是为了更精确的唤醒时间1000000*timeout+nanos，但是代码里这么写的（java 1.8）,看不出来哪里精确了 12345678910111213public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( &quot;nanosecond timeout value out of range&quot;); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout);&#125; notify()在等待队列中唤醒一个线程，选择规则由系统具体实现，被唤醒的线程要和其他线程公平竞争，重新获得锁才能继续执行下去。该方法只能在当前线程获得锁的情况下才能调用，也就是说必须在Sychronized代码中。一次只能有一个线程拥有对象的监视器。 notifyAll该方法与 notify ()方法的工作方式相同，重要的一点差异是：notifyAll 使所有原来在该对象上 wait 的线程统统退出WAITTING状态，使得他们全部从等待队列中移入到同步队列中去，等待下一次能够有机会获取到对象监视器锁。wait notify实现的生产者消费者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.zgq.java;import com.zgq.Algorithm;import com.zgq.Utils;import java.util.Objects;import java.util.concurrent.locks.Lock;/** * Created by zgq on 2019/4/6. */public class ProducerConsumer implements Algorithm&#123; public static final Object LOCK = new Object(); public static int count = 0; public static final int FULL = 10; @Override public void execut() &#123; for (int i = 0; i &lt; 5; i++)&#123; new Thread(new Producer(&quot;producer&quot; + i)).start(); &#125; for (int i = 0; i &lt; 5; i++)&#123; new Thread(new Consumer(&quot;consumer&quot; + i)).start(); &#125; &#125; public static class Producer implements Runnable &#123; private String name; public Producer(String name)&#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; synchronized (LOCK) &#123; Utils.printString(name + &quot; lock&quot;); try &#123; while (count &gt;= FULL) &#123; Utils.printString(name + &quot; wait&quot;); LOCK.wait(); &#125; Thread.sleep(500); count++; Utils.printString(name + &quot; product 1 &quot; + &quot; now is &quot; + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; LOCK.notifyAll(); Utils.printString(name + &quot; unlock&quot;); &#125; &#125; &#125; &#125; &#125; public static class Consumer implements Runnable &#123; public String name; public Consumer(String name)&#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; synchronized (LOCK) &#123; Utils.printString(name + &quot; lock&quot;); try &#123; while (count &lt;= 0) &#123; Utils.printString(name + &quot; wait&quot;); LOCK.wait(); &#125; Thread.sleep(1000); count--; Utils.printString(name + &quot; consume 1 &quot; + &quot; now is &quot; + count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; LOCK.notifyAll(); Utils.printString(name + &quot; unlock&quot;); &#125; &#125; &#125; &#125; &#125;&#125; Lock使用Lock实现消费者生产者模式与wait-notify相差不多，Lock中Condition的await/signalAll可以达到相同的效果，Lock具体用法这里不深究，具体可以看下篇博客。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.zgq.java;import com.zgq.Algorithm;import com.zgq.Utils;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created by zgq on 2019/4/6. */public class ProducerConsumer1 implements Algorithm &#123; public static final Lock LOCK = new ReentrantLock(); public static Condition NOTFULL = LOCK.newCondition(); public static Condition NOTEMPTY = LOCK.newCondition(); public static int count = 0; public static final int FULL = 10; @Override public void execut() &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Producer(&quot;producer&quot; + i)).start(); &#125; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Consumer(&quot;consumer&quot; + i)).start(); &#125; &#125; public static class Producer implements Runnable &#123; private String name; public Producer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; LOCK.lock(); Utils.printString(name + &quot; lock&quot;); try &#123; while (count &gt;= FULL) &#123; Utils.printString(name + &quot; wait&quot;); NOTFULL.await(); &#125; Thread.sleep(20); count++; Utils.printString(name + &quot; product 1 &quot; + &quot; now is &quot; + count); NOTEMPTY.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; LOCK.unlock(); Utils.printString(name + &quot; unlock&quot;); &#125; &#125; &#125; &#125; public static class Consumer implements Runnable &#123; public String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; LOCK.lock(); Utils.printString(name + &quot; lock&quot;); try &#123; while (count &lt;= 0) &#123; Utils.printString(name + &quot; wait&quot;); NOTEMPTY.await(); &#125; Thread.sleep(50); count--; Utils.printString(name + &quot; consume 1 &quot; + &quot; now is &quot; + count); NOTFULL.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; LOCK.unlock(); Utils.printString(name + &quot; unlock&quot;); &#125; &#125; &#125; &#125;&#125; BlockingQueue实现BlockingQueue是一个接口，LinkedBlockingDeque是他的一个实现类，我们看下部分实现代码123456789101112public E takeFirst() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; E x; while ( (x = unlinkFirst()) == null) notEmpty.await(); return x; &#125; finally &#123; lock.unlock(); &#125;&#125; 其实就是lock实现 实现这里用了BlockingQueue的具体实现类LinkedBlockingDeque。链表实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.zgq.java;import com.zgq.Algorithm;import com.zgq.Utils;import java.util.Random;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created by zgq on 2019/4/6. */public class ProducerConsumer2 implements Algorithm &#123; public static BlockingQueue storage = new LinkedBlockingDeque&lt;&gt;(); public static final int FULL = 10; @Override public void execut() &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Producer(&quot;producer&quot; + i)).start(); &#125; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Consumer(&quot;consumer&quot; + i)).start(); &#125; &#125; public static class Producer implements Runnable &#123; private String name; public Producer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; try &#123; Thread.sleep(20); if (storage.size() &lt; FULL) &#123; Random random = new Random(); int k = random.nextInt(); storage.add(k); &#125; Utils.printString(name + &quot; product 1 &quot; + &quot; now is &quot; + storage.size()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static class Consumer implements Runnable &#123; public String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; try &#123; Thread.sleep(50); if (storage.size() &gt; 0) &#123; storage.take(); &#125; Utils.printString(name + &quot; consume 1 &quot; + &quot; now is &quot; + storage.size()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 可以看出，使用BlockingQueue来实现生产者-消费者很简洁，这正是利用了BlockingQueue插入和获取数据附加阻塞操作的特性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程安全(1)-Sychronized]]></title>
    <url>%2F2019%2F04%2F07%2FSychronized%2F</url>
    <content type="text"><![CDATA[java锁java的锁机制并不复杂，谈到锁一般会提到关键字Sychronized和类Lock以及cas策略，提到锁的分类会提到可重入锁、可中断锁、公平锁/非公平锁、乐观锁/悲观锁等等，其实了解了原理之后，一切都会豁然开朗。我们一步一步来。 线程安全在了解锁机制之前，我们得先清除为什么会有锁，原因是保证线程安全。在编程中，当多个线程都要对某一变量进行操作时，我们必须保证这些线程在自己操作后所得的结果是正确的，这就是线程安全。而在java中，根据线程安全强度由强至弱排序，将操作共享数据氛围以下五类：不可变：数据不可变，线程安全也就无从谈起绝对线程安全：几乎无法实现相对线程安全：我们通常说的线程安全线程兼容：值对象本身不是线程安全的，但是我们可以通过调用手段达到安全。线程对立：无论何种情况，无论调用端使用何种方式，都无法使用并发代码，因为java天生支持多线程，所以这个思想无用所以我们在java中说的并发同步指的就是相对线程安全和线程兼容这两个概念。 java中线程安全的实现方式互斥同步：就是我们常说的锁机制非阻塞同步：CAS无同步方案 Sychronized偏向锁，轻量级锁与重量级锁的区别与膨胀 Sychronized重量级锁首先是关键字Sychronized，这是java中最早的也是最常用的锁，这个锁的原理是什么呢？首先，java中对象在内存中存储时分为三块区域，对象头，实例数据，对齐补充，对象头中对象哈希吗，分代年龄，指向锁记录的指针，指向重量级锁的指针等等。我们今天只关注指向重量级锁的指针。该指针指向一个由c++实现的monitor类的对象，每个对象实例都有一个monitor实例，monitor中记录着当前占有该对象的线程，以及等待中的线程，这就是对象的wait方法和notify方法生效的原因。对下面代码中的SychronizedTest类编译出来的class文件进行反编译，命令javap -verbose，查看有同步代码块的print和print1方法，如下图（注意，只有方法中有使用Sychronized同步的代码块才会有这两个code，直接修饰方法不会有，但是会使用ACC_SYNCHRONIZED标志位,比如代码里的print1方法）关于这两条指令的作用，我们直接参考JVM规范中描述：monitorenter:1234Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor&apos;s entry count is zero, then tries again to gain ownership. 这段话的大概意思为： 每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。2.如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权 monitorexit:12The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so. 这段话的大概意思为：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。 我们再来看一下同步方法的反编译结果：从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。 Sychronized使用Sychronized可以对对象加锁，也可以对类加锁，至于怎么生效主要看1.修饰的是什么，这个影响到竞争的是对象锁还是类锁；2.a对象的锁、b对象的锁以及类的锁之间不存在竞争冲突，具体表现在：对对象加锁，那么只有该对象进入同被Sychronized修饰的方法时才会去竞争锁对类加锁或者修饰静态方法，那就是对类加锁，这时候，所有该类的对象进入Sychronized修饰的静态方法时都需要先竞争类锁，也就是所谓的类锁对所有对象生效其实说了这么多，总结起来无非3句话1.对象锁是由对象维护的，类锁是由类的对象维护的，两者并不冲突。这里的不冲突表现在，当Sychronized修饰的静态方法被锁定时，Sychronized修饰的非静态方法仍可以进入，未被Sychronized修饰的方法也可以进入。2.只有请求同一个锁的时候才会发生同步问题3.代码块只会锁定代码块，其余部分可以被其他线程调用 那么Sychronized怎么使用呢？下面是使用Sychronized实现两种加锁方式，并不会发生冲突123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.zgq.java;import com.zgq.Algorithm;import com.zgq.Utils;/** * Created by zgq on 2019/4/6. */public class SychronizedTest implements Algorithm &#123; private SychronizedTest test1; private SychronizedTest test2; private static int count = 5; public SychronizedTest()&#123;&#125; @Override public void execut() &#123; test1 = new SychronizedTest(); new Thread(new Test1(&quot;thread 1&quot;, test1)).start(); new Thread(new Test2(&quot;thread 2&quot;, test1)).start(); new Thread(new Test3(&quot;thread 3&quot;, test1)).start(); &#125; public void print(String name) throws InterruptedException &#123; synchronized(this) &#123; Utils.printString(name + &quot; in and sleep&quot;); Thread.sleep(1000); count--; Utils.printString(name + &quot; run count = &quot; + count); &#125; &#125; public static synchronized void print1(String name) throws InterruptedException &#123; Utils.printString(name + &quot; in and sleep&quot;); Thread.sleep(2000); count--; Utils.printString(name + &quot; run count = &quot; + count); &#125; public void print2(String name) throws InterruptedException &#123; Utils.printString(name + &quot; in and sleep&quot;); Thread.sleep(3000); count--; Utils.printString(name + &quot; run count = &quot; + count); &#125; private static class Test1 implements Runnable &#123; private String name; private SychronizedTest test; private Test1(String name, SychronizedTest test) &#123; this.name = name; this.test = test; &#125; @Override public void run() &#123; try &#123; test.print1(name); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class Test2 implements Runnable &#123; private String name; private SychronizedTest test; private Test2(String name, SychronizedTest test) &#123; this.name = name; this.test = test; &#125; @Override public void run() &#123; try &#123; test.print(name); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class Test3 implements Runnable &#123; private String name; private SychronizedTest test; private Test3(String name, SychronizedTest test) &#123; this.name = name; this.test = test; &#125; @Override public void run() &#123; try &#123; test.print2(name); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面代码最终输出123456thread 1 in and sleepthread 2 in and sleepthread 3 in and sleepthread 2 run count = 4thread 1 run count = 3thread 3 run count = 2 没有同步，可见非同步方法、同步方法、静态同步方法之间因为不会竞争同一锁，所以不会出现同步问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[制作抖音视频]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%88%B6%E4%BD%9C%E6%8A%96%E9%9F%B3%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[起因短视频在近两年大火，尤其抖音快手等，一个庞大的新媒体流量入口已然成型，刚好工作中接触短视频较多，就想自己运营个抖音号，本来以为市场上已有的一些手机app应该可以满足需求，没想到不是模板固定就是体验太差，又或者输出视频清晰度不够，就干脆拿一些用过的视频工具来做了 工具 iMovie：主要用来截取片段，当然FFmpeg也完全可以胜任，但是视觉化的iMovie或者其他商业软件会更方便 ffmpeg：主要用来裁剪视频添加水印FFmpeg 官网 https://ffmpeg.org/ffmpeg.html 命令基本公式ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}... 滤镜 文档 https://ffmpeg.org/ffmpeg-filters.html ffmpeg的滤镜使用的是libavfilter，几个连续的滤镜成为filtergraphs，ffmpeg有Simple filtergraphs和Complex filtergraphs两种 Simple filtergraphs 只有一个输入和一个输出，且输入输出类型相同 指令-vf，是-filter:v的简称，v即video。 tip：-af是音频滤镜，全称-filter:a即audio Complex filtergraphs 多个输入输出 指令-filter_complex 过程 下载下来电影后，用tunesKit video cutter或者ffmpeg进行大致的片段选取，这一步主要是为了减少剪辑文件的大小 如果需要转格式，使用ffmpeg或者aimersoft video converter ultimate 使用iMovie进行细致的剪辑，输出视频 如果视频比例不合适，比如16：9，这种在抖音里看起来显得有点扁，屏幕利用率较低，可以先进行裁剪 ffmpeg -i source.mp4 -vf crop=1440:1080:240:0 output.mp4 -i 表示输入文件 -vf 简单滤镜图 crop是一个裁剪滤镜，https://ffmpeg.org/ffmpeg-filters.html#crop， 需要四个参数，1440:1080:240:0分别指输出视频的宽，高，源视频内容在输出视频中的位置，原点是视频左上角 使用ffmpeg将视频比例改为16：9，多余地方黑色填充 ffmpeg -i source.mp4 -vf pad=1920:3413:0:1150:black -y output.mp4 -pad: https://ffmpeg.org/ffmpeg-filters.html#pad-1， 文档解释：Add paddings to the input image, and place the original input at the provided x, y coordinates.意思很明显了，pad就是padding -y: Overwrite output files without asking 加水印 ffmpeg -i source.mp4 -vf &quot;movie=overlay.png,scale=480:50[watermask];[in][watermask] overlay=200:2000[out]&quot; -y out.mp4 -movie: Read audio and/or video stream(s) from a movie container,使用scale进行缩放，输出第一次结果watermask，中括号中为label，ffmpeg中使用[]打标表示某一个流，可以在后面进行引用 [in]:primary input，指代主输入流 [watermask]，第一个滤镜的产出名字，当然名字可以随便取 overlay:It takes two inputs and has one output. The first input is the “main” video on which the second input is overlaid,打水印的主要操作]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex系列(1)-环境与工具]]></title>
    <url>%2F2018%2F11%2F29%2FWeex%E7%B3%BB%E5%88%97-1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[什么是WeexWeex官网的一句话介绍：Weex 是一个使用 Web 开发体验来开发高性能原生应用的框架。Weex是由阿里巴巴开发的，基于先进Web技术，使用同一套代码来构建 Android、iOS 和 Web 应用。具体来讲，在集成了 WeexSDK 之后，你可以使用 JavaScript 和现代流行的前端框架来开发移动应用。 支持的前端框架 Vue.js Rax 环境搭建 关于环境，官网介绍已经非常详细了需要注意的是 在 package.json 中，已经配置好了几个常用的 npm script，分别是： build: 源码打包，生成 JS Bundle dev: webpack watch 模式，方便开发 serve: 开启HotReload服务器，代码改动的将会实时同步到网页中 Weex 官方提供了 weex-toolkit 的脚手架工具来辅助开发和调试，通过install -g weex-toolkit安装后就可以使用weex命令来创建weex工程了 Demo 创建一个Weex项目weex create awesome-project执行完命令后，在 awesome-project 目录中就创建了一个使用 Weex 和 Vue 的模板项目。 开启服务npm start执行完命令后，根据终端提示访问相应网站即可即时浏览效果，使用weex官方app playground也能在手机上进行预览 客户端安装包打包 添加或移除平台 12weex platform add iosweex platform add android 12weex platform add iosweex platform add android 查看平台列表weex platform list 运行 123weex run iosweex run androidweex run web 这样运行会直接打出客户端包并进行安装，因此需要提前配置好ios或android的开发环境 输出客户端工程 12npm run pack:iosnpm run pack:android 执行完命令后，在项目中会生成一个新的文件夹platforms，工程就放在这个文件夹中。 目录结构需要重点关注的几个文件或文件夹（待续） configs/config.js package.json Native端的集成输出客户端工程后，可以非常直观的看出Weex SDK的使用方式，但是，我们大部分情况并不是使用输出的工程继续开发，那么怎么接入weex到既有项目呢？ 集成sdk集成sdk的坑有点多，这里要着重说一下Android集成，主要参考Android集成Weex sdk 中文官网中参考代码12345compile &apos;com.android.support:recyclerview-v7:23.1.1&apos;compile &apos;com.android.support:support-v4:23.1.1&apos;compile &apos;com.android.support:appcompat-v7:23.1.1&apos;compile &apos;com.alibaba:fastjson:1.1.46.android&apos;compile &apos;com.taobao.android:weex_sdk:0.5.1@aar&apos; 注意上面的weex_sdk版本是0.5.1，这本来是没有问题的，但是因为weex在0.10.0版本之后全面支持vue2.0，而前面文档中weex create命令创建出来的项目是基于vue2.0的，这会导致在加载编译出的jsbundle时会报错ReferenceError: Vue is not defined而英文文档就没有这个问题，英文文档给出的版本是0.18.0，改成0.18.0后虽然能解决上面的问题，但是在load本地jsbundle时又出现失败的错误，所以我使用的是0.16.0。目前weex的版本迭代还是比较频繁的，但是不建议使用最新的，问题会比较多。 示例代码 仓库地址 编译jsbundle 命令npm run build其实就是运行package.json内定义得build脚本，运行成功后将dist文件夹复制到客户端工程（或者放在云端动态加载），然后使用weex实例进行渲染即可，这个在示例代码中有所体现]]></content>
      <tags>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnyTest-Introductin]]></title>
    <url>%2F2018%2F11%2F03%2FAnyTest-Introduction%2F</url>
    <content type="text"><![CDATA[AnyTest这是什么这是一个非常有意思的希望能够提高学生或者文字记忆者效率的一款应用。这款app基于MVP模式，使用Realm进行数据存储，使用RxJava完成异步调用，使用lombok减少代码量，使用butterknife进行view绑定，使用dagger2完成依赖注入，可以说这个项目是使用了相对来说比较新潮的技术来开发的，这也是我做这个项目的初衷，就是接触更多的技术。如果你也对这些项目有兴趣，不防在这里集中的了解一下。 为什么做在我还未成为一名coder之前，有一次因为工作原因，需要记忆大量的题目，题目类型都是比较常见的填空题选择题之类，但是因为题库的书不便于随身携带，就萌发写一个app的想法，希望这个app可以解析文档，并将题目内容完整的存储在app上，并且按照题目类别以不同方式进行展示和交互，帮助记忆，这就是AnyTest的由来。 有什么特点 解析文档把文档整理成类似这个文件之后放入sd卡中，打开app点击‘+’号选择该文件即可进行解析。文档解析是基于字符的，对文档格式要求较高。 支持题目类型目前支持填空题、判断题、单选题、多选题以及简答题，每种题目都支持交互学习，支持收藏功能 任务管理可以设置文档是否进入学习状态每个解析的文档都可以单独设置每日学习量查看最近一周的学习记录支持每个文档的答题正确率这个项目用了什么 MVP模式googlesamples/android-architecture这个仓库中对google推崇的MVP模式有非常相近的介绍。 RealmRealm是一个移动端的存储方案，区别于传统sqlite的表的概念，Realm中的增删改查都是针对对象的，也就是说，你查询的结果直接就是一个对象，非常的便捷。Realm中的对象会有多种状态，用于分辨是否可进行修改等操作。另外，Realm还提供了方便的数据库检索app，更加直观的查看当前的数据库内容。 Dagger2Dagger2依赖注入的神器，Dagger2相对于Dagger也有很大提升。 lomboklombok自动生成代码的神器，远离get和set RxJavaRxJava butterknifebutterknife这个app能做什么]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>AnyTest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-collection]]></title>
    <url>%2F2018%2F02%2F27%2Fjava-collection%2F</url>
    <content type="text"><![CDATA[Java集合 重要的接口 List（有序、可重复）List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。 Set（无序、不能重复）Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。 Map（键值对、键唯一、值不唯一）Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。 对比如下 List，允许重复元素 ArrayList:基于数组实现 Vector:基于数组实现，方法都是同步的(Synchronized),是线程安全的 LinkedList:基于链表实现，两者都有序 Set，不允许有重复值 HashSet基于HashMap实现，只不过Key-Value里面的value都是同一个object，因为是基于hashmap（散列表）实现，所以自然是无序的 TreeSet基于TreeMap实现，只不过Key-Value里面的value都是同一个object，因为是基于TreeMap（红黑树）实现，所以自然是有序的 Map，键值对，key唯一，value可重复 HashMap：最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。因为键对象不可以重复，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的。 resize时为什么要乘以2，或者说为什么capacity是2的次幂 对hashcode取模的时候用的位操作符&amp;，hashcode &amp; length-1，如果不是2的次幂，那么length-1的二进制表示中很有可能有0位，那么位与运算后，这个位置永远为0，hash冲突概率增加 resize时乘以2的话，在取模的时候，相当于比原来多了一位，在重新寻址的时候，只要看多出来的一位是0还是1即可，是0的话位置不变，是1的话新的索引位置就是老索引加上老的长度c Hashtable:与HashMap类似，也是散列表实现，是HashMap的线程安全版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。 TreeMap：基于红黑树实现，实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，因为无法比较，非同步的 LinkedHashMap：保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。这是因为LinkedHashMap中的Node有before和after两个引用，分别指向前一个和后一个节点 ConcurrentHashMap：线程安全，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。java1.7和1.8的实现有很大区别，见https://www.cnblogs.com/study-everyday/p/6430462.html hashmap在java1.7和1.8的区别 JDK1.7中使用一个Entry数组来存储数据，用key的hashcode取模来决定key会被放到数组里的位置，如果hashcode相同，或者hashcode取模后的结果相同（hash collision），那么这些key会被定位到Entry数组的同一个格子里，这些key会形成一个链表。在hashcode特别差的情况下，比方说所有key的hashcode都相同，这个链表可能会很长，那么put/get操作都可能需要遍历这个链表，也就是说时间复杂度在最差情况下会退化到O(n)。 JDK1.8中使用一个Node数组来存储数据，但这个Node可能是链表结构，也可能是红黑树结构，如果插入的key的hashcode相同，那么这些key也会被定位到Node数组的同一个格子里。如果同一个格子里的key不超过8个，使用链表结构存储。如果超过了8个，那么会调用treeifyBin函数，将链表转换为红黑树。那么即使hashcode完全相同，由于红黑树的特点，查找某个特定元素，也只需要O(log n)的开销。也就是说put/get的操作的时间复杂度最差只有O(log n)。听起来挺不错，但是真正想要利用JDK1.8的好处，有一个限制：key的对象，必须正确的实现了Compare接口，如果没有实现Compare接口，或者实现得不正确（比方说所有Compare方法都返回0）。那JDK1.8的HashMap其实还是慢于JDK1.7的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[floor-ceiling-round]]></title>
    <url>%2F2018%2F02%2F09%2Ffloor-ceiling%2F</url>
    <content type="text"><![CDATA[趣味floor和ceiling为什么向下取整用floor（小于等于给定值n的最大整数），向上取整用ceiling（大于等于给定值n的最小值）。想想在一个房间里，有地板floor（代表整数m），天花板ceiling(代表m+1)，n位于地板和天花板之间，floor不就是小于等于n的最大整数么，ceiling也类似，真是形象~round是指距离最近的整数，比如11.6距离12最近，11.4距离11最近，-11.6距离-12最近，-11.4距离-11最近，需要注意的是.5这个点，.5这个点永远属于数轴右边，比如11.5距离12最近，-11.5距离-11最近 roundround是指距离最近的整数，这就涉及到.5的情况怎么处理，不管正数还是负数，round后的.5都是返回数轴右边的整数]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[search-algorithm]]></title>
    <url>%2F2018%2F02%2F08%2Fsearch-algorithm%2F</url>
    <content type="text"><![CDATA[符号表符号表的主要目的是将一个键和一个值联系起来，可以根据键获得值。我们会用多种方式实现这种数据结构，不仅能高效的插入和查找，还可以进行其他方便的操作。这里我们还会讨论java中符号表的实现。为了熟悉kotlin这里所有的算法都将使用kotlin来实现。 规则 每个键对应一个值 键值均不允许null（java中hashmap是可以为空的） 删除操作，有延时删除（先置空再删除）和即时删除（直接删除） 迭代，便利所有键 键的等价性，equals判断是否相等，如果使用了comparable接口来进行比较，那么保证equals与compareTo返回值一致。总有人问hashmap是否有序，hashmap在使用时对键没有要求，不需要实现接口Iterable，也就是说键无法比较，那么怎么可能是有序的呢 基于无序链表的顺序查找基于链表的实现，在查找时只能是顺序查找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//kt中泛型的使用class Search&lt;Key : Comparable&lt;Key&gt;,Value&gt;&#123; //如果可能为null，则需要加？修饰 private var first: Node? = null private var N: Int = 0 fun put(key: Key,value: Value)&#123; var x:Node? = first while (x != null)&#123; if (x.key!!.compareTo(key) == 0)&#123; x.value = value return &#125;else x = x.next &#125; this.first = Node(key,value, first) N++ &#125; //返回值有可能为null也需要加？修饰 fun get(key: Key): Value?&#123; var tmp = first while (tmp != null)&#123; if (tmp.key!!.compareTo(key) == 0) return tmp.value tmp = tmp.next &#125; return null &#125; fun delete(key:Key)&#123; if (first == null)&#123; return &#125; if (first?.key?.compareTo(key) == 0) &#123; first = first?.next N-- return &#125; var tmp = first var pre : Node? = null while (tmp != null)&#123; if (tmp.key.compareTo(key) == 0)&#123; pre?.next = tmp.next N-- return &#125;else&#123; pre = tmp tmp = tmp.next &#125; &#125; &#125; fun size(): Int &#123; return N &#125; //内部类，还有嵌套类，有区别，构造函数在类声明后面 inner class Node(val key: Key, var value: Value, var next: Node?)&#125; 基于无序链表的查找，未命中的查找和插入操作都需要N次比较。向一个空表中连续插入N个键需要$~\frac{N^2}{2}$次比较。所以基于无需链表的实现效率很低。 基于有序数组的二分查找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class BinarySearch(var N: Int)&#123; var keys = arrayOfNulls&lt;String&gt;(N) var values = arrayOfNulls&lt;String&gt;(N) //指示当前最后一个元素的位置 var index: Int = -1 fun put(key:String,value:String)&#123; //i指向大于key的第一个位置 val i = rank(key) //如果存在直接更新并返回 if (i&lt;=index &amp;&amp; key.compareTo(keys[i]!!) == 0)&#123; values[i] = value return &#125; //不存在key的话，将所有大于key的元素全部向后移动一位，再插入 relocation(i,index,keys,values) keys[i] = key values[i] = value index++ &#125; //这是最直接的二分查找 fun get(key:String):String?&#123; var i = rank(key,0,index) if (i&lt;=index &amp;&amp; key.compareTo(keys[i]!!) == 0)&#123; return values[i] &#125;else&#123; return null &#125; &#125; fun delete(key:String)&#123; var i = rank(key) if (key.compareTo(keys[i]!!) == 0)&#123; relocationReserv(i+1,index,keys,values) index-- return &#125; &#125; //如果表中存在key，rank方法返回key的位置，也就是小于key的键的数量 //如果表中不存在key，rank方法还是返回小于key的键的数量 //下面是递归实现 private fun rank(key:String, lo:Int, hi:Int):Int&#123; if (hi&lt;lo) return lo var mid = lo + (hi-lo)/2 val com = key.compareTo(keys[mid]!!) if (com &gt; 0) return rank(key,mid+1,hi) else if (com &lt; 0) return rank(key,lo,mid-1) return mid &#125; //迭代实现 private fun rank(key: String):Int&#123; var lo = 0 var hi = index while (lo &lt;= hi)&#123; var mid = lo+(hi-lo)/2 var com = key.compareTo(keys[mid]!!) if (com == 0) return mid else if (com&gt;0) lo = mid+1 else if (com&lt;0) hi = mid-1 &#125; return lo &#125; //返回一定范围内的key fun rangeKeys(loKey:String, hiKey: String): Iterable&lt;String&gt; &#123; var result = ArrayList&lt;String&gt;(N) var lo = rank(loKey) var hi = rank(hiKey) for (i in lo..hi)&#123; result.add(keys[i]!!) &#125; return result &#125; private fun relocation(start:Int, end: Int, array1: Array&lt;String?&gt;, array2: Array&lt;String?&gt;)&#123; val max = array1.size-1 for (i in end downTo start)&#123; if (i &lt; max)&#123; array1[i+1] = array1[i] array2[i+1] = array2[i] &#125; &#125; &#125; private fun relocationReserv(start:Int,end: Int, array1: Array&lt;String?&gt;, array2: Array&lt;String?&gt;)&#123; val max = array1.size-1 for (i in start..end)&#123; if (i&lt;=max)&#123; array1[i-1] = array1[i] array2[i-1] = array2[i] &#125; &#125; array1[end] = null array2[end] = null &#125;&#125; 二分查找很快，在N个键的有序数组中进行二分查找最多需要(lgN+1)次比较（无论是否成功）。插入一个新元素在最坏的情况下要访问数组~2N次，因此向一个空符号表中插入N个元素在最坏情况下需要访问$~N^2$次数组。也就是说，基于有序数组实现的符号表插入效率低下，这是一个缺陷。 基于链表和有序数组的符号表实现比较 二叉查找树要支持高效的插入操作，需要支持二分查找的链式结构，但单链表显然无法满足，因为二分查找的高效来自于可以通过索引快速的入得任何数组的中间元素，但得到链表中间元素的唯一方法就是遍历。将二分查找和链表的灵活性结合起来，我们需要更复杂的数据结构，就是二叉查找树。 二叉树在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。二叉树的根结点所在的层数为1，根结点的孩子结点所在的层数为2，以此下去。深度是指所有结点中最深的结点所在的层数。二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其叶子结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为log2n+1。深度为k的完全二叉树，至少有2^（k-1)个节点，至多有2^k-1个节点。二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态：(1)空二叉树(2)只有一个根结点的二叉树(3)只有左子树(4)只有右子树(5)完全二叉树注意：尽管二叉树与树有许多相似之处，但二叉树不是树的特殊情形。 二叉树类型 完全二叉树 满二叉树 平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。相关术语树的结点：包含一个数据元素及若干指向子树的分支；孩子结点：结点的子树的根称为该结点的孩子；双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点；祖先结点: 从根到该结点的所经分支上的所有结点；子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙；结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；树的深度：树中最大的结点层结点的度：结点子树的个数树的度： 树中最大的结点度。叶子结点：也叫终端结点，是度为 0 的结点；分枝结点：度不为0的结点；有序树：子树有序的树，如：家族树；无序树：不考虑子树的顺序；遍历顺序遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。如何记忆三种遍历：注意，DLR是先根次序遍历，即判断先中后的方式是看何时访问双亲节点，而LR永远都是先左后右的顺序。二叉树实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230package com.zgq;public class BST &lt;Key extends Comparable&lt;Key&gt;,Value&gt;&#123; private Node root; private class Node&#123; private Key key; private Value value; private int N; private Node left,right; private Node(Key key,Value value,int N)&#123; this.key = key; this.value = value; this.N = N; &#125; &#125; public void put(Key key, Value value)&#123; root = put(root,key,value); &#125; private Node put(Node root,Key key,Value value)&#123; if (root == null)&#123; return new Node(key,value,1); &#125; int cmp = key.compareTo(root.key); if (cmp &gt; 0)&#123; root.right = put(root.right,key,value); &#125;else if (cmp &lt; 0)&#123; root.left = put(root.left,key,value); &#125;else &#123; root.value = value; &#125; root.N = sizeOf(root.left) + sizeOf(root.right) + 1; return root; &#125; public Value get(Key key)&#123; return get(root,key); &#125; private Value get(Node root, Key key)&#123; if (root == null) return null; int cmp = key.compareTo(root.key); if (cmp &gt; 0) return get(root.right,key); else if (cmp &lt; 0) return get(root.left,key); else return root.value; &#125; public int size()&#123; return sizeOf(root); &#125; private int sizeOf(Node root)&#123; if (root == null) return 0; return root.N; &#125; public Value max()&#123; return max(root).value; &#125; private Node max(Node root)&#123; if (root == null) return null; if (root.right == null) return root; return max(root.right); &#125; public Value min()&#123; return min(root).value; &#125; private Node min(Node root)&#123; if (root == null) return null; if (root.left == null) return root; return min(root.left); &#125; public void delete(Key key)&#123; delete(root,key); &#125; //删除节点并返回根节点 private Node delete(Node root,Key key)&#123; if (root == null) return null; int cmp = key.compareTo(root.key); //在右子树中进行删除，同时保证root的右节点指向删除后得根节点 if (cmp &gt; 0) root.right = delete(root.right,key); else if (cmp &lt; 0) root.left = delete(root.left,key); else &#123; //如果找到节点，则分步删除 //左子树为空，则返回右子树根节点 if (root.left == null) return root.right; //右子树为空，则返回左子树根节点 if (root.right == null) return root.left; //左右都不为空，则将右子树中最小的节点copy到要删除节点root的位置，同时新root的左子树链接原root的左子树，新root的右子树链接删除最小节点后得右子树 Node t = root; root = min(root.right); root.left = t.left; root.right = deleteMin(root.right); &#125; root.N = sizeOf(root.left) + sizeOf(root.right) + 1; return root; &#125; public void deleteMin()&#123; root = deleteMin(root); &#125; private Node deleteMin(Node root)&#123; if (root.left == null) return root.right; root.left = deleteMin(root.left); root.N = sizeOf(root.left) + sizeOf(root.right) + 1; return root; &#125; public void deleteMax()&#123; root = deleteMax(root); &#125; //删除最大节点并返回根节点 private Node deleteMax(Node root)&#123; if (root.right == null) return root.left; //递归实现 root.right = deleteMax(root.right); root.N = sizeOf(root.left) + sizeOf(root.right) + 1; return root; &#125; public Key floor(Key key)&#123; return floor(root,key).key; &#125; private Node floor(Node root, Key key)&#123; if (root == null) return null; int cmp = key.compareTo(root.key); if (cmp == 0) return root; else if (cmp &lt; 0) &#123; return floor(root.left, key); &#125; Node t = floor(root.right,key); if (t != null) return t; else return root; &#125; public Key ceiling(Key key)&#123; return ceiling(root,key).key; &#125; private Node ceiling(Node root, Key key)&#123; if (root == null) return null; int cmp = key.compareTo(root.key); if (cmp == 0) return root; else if (cmp &gt; 0) &#123; return ceiling(root.right, key); &#125; Node t = ceiling(root.left,key); if (t != null) return t; else return root; &#125; //返回比key小的节点数量 public int rank(Key key)&#123; return rank(root,key); &#125; private int rank(Node root, Key key)&#123; if (root == null) return 0; int cmp = key.compareTo(root.key); if (cmp &lt; 0) return rank(root.left,key); //注意这里，当key比root节点大时，返回root的子节点数量+对root右子树做rank操作的结果+1 else if (cmp &gt; 0) return 1 + sizeOf(root.left) + rank(root.right,key); else return sizeOf(root.left); &#125; //返回排名为k的元素，从0开始排 public Key select(int k)&#123; return select(root,k).key; &#125; private Node select(Node root, int k)&#123; if (root == null) return null; int t = sizeOf(root.left); if (t &lt; k) return select(root.right,k-t-1); else if (t &gt; k) return select(root.left,k); else return root; &#125; //范围查找操作 //返回所有键，无序 public Iterable&lt;Key&gt; keys()&#123; return keys(min(),max()); &#125; //返回lo到hi之间的所有键 public Iterable&lt;Key&gt; keys(Key lo,Key hi)&#123; Queue&lt;Key&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); keys(root,queue,lo,hi); return queue; &#125; private void keys(Node root, Queue&lt;Key&gt; queue,Key lo,Key hi)&#123; if (root == null) return; int cmpLo = lo.compareTo(root.key); int cmpHi = hi.compareTo(root.key); if (cmpLo &lt;= 0 &amp;&amp; cmpHi &gt;= 0)&#123; queue.add(root.key); &#125; if (cmpLo &lt; 0)&#123; keys(root.left,queue,lo,hi); &#125; if (cmpHi &gt; 0)&#123; keys(root.right,queue,lo,hi); &#125; &#125; public void printAllLDR()&#123; printAllLDR(root); System.out.print(&quot;\n&quot;); &#125; private void printAllLDR(Node root)&#123; if (root.left != null) &#123; printAllLDR(root.left); &#125; System.out.print(&quot;*&quot; + root.key + &quot;*&quot;); if (root.right != null) &#123; printAllLDR(root.right); &#125; &#125;&#125; 使用二叉查找树的算法运算时间取决于树的形状，而树的形状右取决于键被插入的先后顺序。在最好的情况下，N个节点的数是完全平衡的，每条空链到根节点的距离都是lgN。但是在最坏的情况下，搜索路径上可能有N个节点。二叉查找树和快排有极高的相似度，根节点就是快排的切分元素。 性质 在由N个随机键构造的二叉查找树中，查找命中平均所需比较次数~2lgN（约1.39lgN）。 在由N个随机键构造的二叉查找树中，插入操作和查找未命中平均所需比较次数~2lgN（约1.39lgN）。性能分析 在一棵二叉查找树中，所有操作在最坏情况下所需时间都和树的高度成正比。 二叉树的优势还在于其支持高效的rank(),select(),delete()以及范围查找操作。 某些最坏的情况下仍有恶劣的性能。平衡查找树在一个含有N个节点的树中，我们希望树高为lgN，这样就能保证每次查找都能在树高次比较中结束，就像二分查找一样。但是在动态插入中保证树的完美平衡代价很大，这节将要解决这个问题。23查找树一颗完美平衡的23查找树中的所有空节点到根节点的距离都是相同的 查找，与二叉树类似 插入：插入操作较为麻烦，在二叉树中插入时，我们是先做一个查找，如果未命中，则把新节点挂在树的底部，这样的影响是树无法保证完美平衡性。使用23树可以避免这种情况。插入过程详解 未命中查找结束与一个2节点，把2节点转换成3节点，再将新节点保存在其中即可。 树中只含有3节点，]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[颜色空间]]></title>
    <url>%2F2018%2F02%2F08%2Fcolor-space%2F</url>
    <content type="text"><![CDATA[RGB、YUV和HSV颜色空间模型https://www.cnblogs.com/justkong/p/6570914.html kiwiplayer的视频增强算法中，luma方法是将rgb颜色转换为yuv颜色空间来计算的。 采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V分量，那么这样表示的图像就是黑白灰度图像。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algorithm-question]]></title>
    <url>%2F2018%2F01%2F27%2Falgorithm-question%2F</url>
    <content type="text"><![CDATA[主键都相同，选择排序和插入排序谁快选择排序：比较N*(N-1)/2,交换0；插入排序：比较N-1，交换0；插入排序更快 逆序数组，插入排序与选择排序选择排序：比较N(N-1)/2,交换N-1；插入排序：比较N\(N-1)/2,交换N*(N-1)/2；插入排序更快]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort-algorithm]]></title>
    <url>%2F2018%2F01%2F23%2Fsort-algorithm%2F</url>
    <content type="text"><![CDATA[选择排序一般用于小型数组1234567891011public static void selection(Comparable[] a)&#123; for (int i = 0; i &lt; a.length; i++)&#123; int min = i; for (int j = i + 1 ; j &lt; a.length; j++)&#123; if (a[min].compareTo(a[j]) &gt; 0)&#123; min = j; &#125; &#125; exch(a,min,i); &#125;&#125; 插入排序一般用于小型数组1234567public static void insertion(Comparable[] a)&#123; for (int i = 0; i &lt; a.length - 1; i++)&#123; for (int j = i ; j &gt; 0 &amp;&amp; a[j-1].compareTo(a[j]) &gt; 0 ; j--)&#123; exch(a,j-1,j); &#125; &#125;&#125; 希尔排序内循环是插入排序，第一个for循环相当于完成了所有h有序数组的插入排序。比较顺序是： 第一个h有序数组的前一位插入排序 第二个h有序数组的前一位插入排序直到第h个有序数组的前一位插入排序 第一个h有序数组的前两位插入排序直到第h个有序数组的前两位插入排序 同理，直到第h个有序数组的所有位数插入排序 下面程序中的h不断减小直到为1，这个时候数组就是有序的了。这个程序中，h = 3*h +1,即1，4，13·····，这个序列叫递增序列，递增序列的选择有很多，可以在运行时计算得到，也可以保存在数组中。递增序列的选择会直接影响希尔排序的性能，在普通情况下，h = 3*h +1足够满足我们。希尔排序的优势在于可以处理中型数组，且不会占用额外的空间。希尔排序与选择排序和插入排序相比，希尔排序也可以用于大型数组。123456789101112public static void shell(Comparable[] a)&#123; int h = 1; int N = a.length; while(h &lt; N/3) h = h*3 + 1; while (h&gt;=1) &#123; for (int i = h; i &lt; N; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; a[j].compareTo(a[j-h]) &lt; 0; j -= h) exch(a,j,j-h); &#125; h = h/3; &#125;&#125; 归并排序归并排序，时间复杂度为NlogN，它的主要缺点是需要额外空间，切额外空间的大小与N成正比。123456789101112131415161718192021222324252627282930public class Merge &#123; private static Comparable[] aux; public static void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; sort(a, 0, a.length - 1); &#125; //自顶向下递归进行归并排序 private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; sort(a,lo,lo + (hi - lo)/2); sort(a,lo + (hi - lo)/2 + 1,hi); merge(a,lo,hi,lo + (hi - lo)/2); &#125; //归并方法 private static void merge(Comparable[] a, int lo, int hi, int mid)&#123; for (int i = lo; i &lt;= hi; i++)&#123; aux[i] = a[i]; &#125; int i = lo; int j = mid + 1; for (int k = lo; k &lt;= hi; k++)&#123; if (j &gt; hi) a[k] = aux[i++]; else if (i &gt; mid) a[k] = aux[j++]; else if (aux[i].compareTo(aux[j])&gt;=0) a[k] = aux[j++]; else if (aux[i].compareTo(aux[j])&lt;0) a[k] = aux[i++]; &#125; &#125;&#125; 归并排序的优化 对于小规模的数组不再递归，而使用简单的选择排序或者插入排序，因为这两种排序在小规模数组上速度很可能比归并快，一般情况下可以将归并排序缩短10%到15%。在子数组长度小于一定值时（这里是4），使用插入排序。 1234567891011121314151617private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; if ((hi - lo) &lt; 4)&#123; insertion(a, lo, hi); return; &#125; sort(a,lo,lo + (hi - lo)/2); sort(a,lo + (hi - lo)/2 + 1,hi); merge(a,lo,hi,lo + (hi - lo)/2);&#125;public static void insertion(Comparable[] a, int lo, int hi)&#123; for (int i = lo + 1; i &lt;= hi; i++)&#123; for (int j = i ; j &gt; lo &amp;&amp; a[j-1].compareTo(a[j]) &gt; 0 ; j--)&#123; exch(a,j-1,j); &#125; &#125;&#125; 归并时两个子数组，如果左半边的最大值小于右半边的最小值，那么不用归并 1234567891011private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; if ((hi - lo) &lt; 4)&#123; insertion(a, lo, hi); return; &#125; sort(a,lo,lo + (hi - lo)/2); sort(a,lo + (hi - lo)/2 + 1,hi); if (a[lo + (hi - lo)/2].compareTo(a[lo + (hi - lo)/2 + 1]) &lt; 0) return; merge(a,lo,hi,lo + (hi - lo)/2);&#125; 为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。 下面代码是实现。实现的核心在于： 1) 每一层递归中，不论是使用插入排序，还是因为左半边右半边已经有序不需要归并，还是需要归并，都要保证dest的正确有序。2) 进入下一层递归时，源数组和辅助数组角色交换。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Merge &#123; public static void sort(Comparable[] a)&#123; Comparable[] aux = a.clone(); //注意，要把a放在dest位置上，否则源数组会少一次归并操作 sort(aux,a,0, a.length - 1); &#125; private static void sort(Comparable[] src, Comparable[] dest, int lo, int hi)&#123; if (hi &lt;= lo) return; if ((hi - lo) &lt; 4)&#123; //注意，小数组的插入排序要在dest上进行 insertion(dest, lo, hi); return; &#125; //在进行下一层归并时，交换源数组和辅助数组，避免复制操作 sort(dest,src,lo,lo + (hi - lo)/2); sort(dest,src,lo + (hi - lo)/2 + 1,hi); if (src[lo + (hi - lo)/2].compareTo(src[lo + (hi - lo)/2 + 1]) &lt; 0) &#123; //如果从源数组判断此次不需要归并，那么也将相应位置元素copy到dest，即保证dest的元素正确有序 System.arraycopy(src,lo,dest,lo,hi - lo + 1); return; &#125; //归并排序时保证dest的正确有序，这样在返回上一层归并时，这里的dest可以作为上一层的辅助数组 merge(src,dest,lo,hi,lo + (hi - lo)/2); &#125; private static void merge(Comparable[] src, Comparable[] dest, int lo, int hi, int mid)&#123; int i = lo; int j = mid + 1; for (int k = lo; k &lt;= hi; k++)&#123; if (j &gt; hi) dest[k] = src[i++]; else if (i &gt; mid) dest[k] = src[j++]; else if (src[i].compareTo(src[j])&gt;=0) dest[k] = src[j++]; else if (src[i].compareTo(src[j])&lt;0) dest[k] = src[i++]; &#125; &#125; public static void insertion(Comparable[] a, int lo, int hi)&#123; for (int i = lo + 1; i &lt;= hi; i++)&#123; for (int j = i ; j &gt; lo &amp;&amp; a[j-1].compareTo(a[j]) &gt; 0 ; j--)&#123; exch(a,j-1,j); &#125; &#125; &#125;&#125; 上面的是自顶而下的归并，还有自底向上的归并。递归实现的归并排序是算法设计中分治思想的典型应用，即将一个大问题分解成小问题分别解决，再用小问题的答案来解决大问题。在自顶而下的递归中就是这样，在每一次递归中，都降低了数组长度，最后用最深处的微型数组归并结果，反过来求上层递归的答案。其实，由于我们知道上层递归是如何使用下层递归的结果的，所以这里的归并排序可以不使用递归，利用循环，自底向上，先将卫星数组归并，比如先归并长度为1的数组，再归并长度为2的长度为4的，这样下去，将整个数组归并。这样的代码量更少。12345678910public static void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; int N = a.length; for (int sz = 1; sz &lt; N; sz *= 2)&#123; for (int lo = 0; lo &lt; N - sz; lo = lo+sz*2)&#123; int hi = min(lo+sz*2-1,N-1); merge(a,lo,hi,lo + (hi-lo)/2); &#125; &#125;&#125; 基于比较的排序算法我们讨论的都是基于比较的排序算法，这些算法的复杂度有上限。命题：没有任何基于比较的算法能够保证使用少于lg(N!)~NlgN次比较将长度为N的数组排序。证明：首先假设没有重复的主键，因为任何排序算法都应该能够处理这种情况。使用二叉树表示所有的比较。上图是N=3的比较树，叶子节点表示排序完成，内部节点表示a[i]和a[j]的一次比较操作，左子树表示a[i]小于a[j]时进行的其他比较，右子树表示a[i]大于a[j]时的其他比较。从根节点到叶子节点的所有路径表示在实际排序中，可能遇到的所有比较。比较树中至少应该有N!个叶子节点，因为长度为N的数组，共有N!中排列方式，如果某个比较树的叶子节点小于N!,那么肯定有一些排列顺序被遗漏，基于这个比较树的算法在使用时，对于某些输入就无法正确的排序。在排序算法中，我们通常关心比较的次数，而最多比较次数就是比较树的高度。高为h的二叉树最多叶子节点$2^h$，比较树中的叶子节点（就是所有的比较路径）数量N!,那么就有$N!\log{N!}$上面的式子告诉我们在设计排序算法时所能达到的最佳效果。即比较次数最低是NlgN。 快速排序归并排序虽然将算法时间复杂度降低到NlogN，但是需要一个与N成正比的辅助栈，而快排则避免了这个缺点，快排是原地排序，只需要一个很小的辅助栈。快排的优点： 时间复杂度为NlogN 原地排序，只需要一个很小的辅助栈 内循环比大多数排序都要小 归并和希尔排序比快排慢，原因就是他们在内循环中还有移动复制操作。缺点： 脆弱，在实现时要非常小心才能避免低劣的性能，许多错误都能导致快排的性能只有平方级别。比如在切分不平衡时可能导致快排极为低效，例如第一次从最小元素切分，第二次从第二小元素切分，这样每次只能移动一个元素，导致一个大数组需要切分很多次，事实上，这种极端情况下会比较$$\frac{1}{2}N^2$$次，我们可以在快排前将数组打乱以避免这种情况。 快排效率依赖切分数组的效果，最好的情况是每次都能将数组对半分。12345678910111213141516171819202122232425262728public class Quick &#123; public static void sort(Comparable[] a)&#123; sort(a,0,a.length-1); &#125; private static void sort(Comparable[] a, int lo, int hi)&#123; if (lo&gt;=hi) return; int j = partition(a,lo,hi); sort(a,lo,j-1); sort(a,j+1,hi); &#125; private static int partition(Comparable[] a, int lo, int hi)&#123; Comparable tmp = a[lo]; //因为lo位置的元素作为切分元素，所以这里本可以设置为lo+1，之所以设置为lo，是为了后面的先++lo做准备 int lf = lo; //同理这里设置为hi+1，是为后面先--ri做准备 int ri = hi + 1; while(true)&#123; //先判断界限，避免溢出，不停循环至第一个大于切分元素的位置 while (++lf &lt;= hi &amp;&amp; tmp.compareTo(a[lf]) &gt; 0); while (--ri &gt;= lf &amp;&amp; tmp.compareTo(a[ri]) &lt; 0); if (lf&gt;=ri) break; exch(a,lf,ri); &#125; exch(a,lo,ri); return ri; &#125; 算法改进 切换到插入排序，在微型数组长度较短的情况下，使用插入排序比继续递归要快，一般长度在5-15之间(大多数基于递归的排序都可以这样做)。 1234567891011121314private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &gt; lo + 10) insertion(a,lo,hi); if (lo&gt;=hi) return; int j = partition(a,lo,hi); sort(a,lo,j-1); sort(a,j+1,hi);&#125;private static void insertion(Comparable[] a, int lo, int hi)&#123; for (int i = lo; i &lt;= hi; i++)&#123; for (int j = i; j &gt; lo &amp;&amp; a[j].compareTo(a[i]) &gt; 0; j--)&#123; exch(a,i,j); &#125; &#125;&#125; 三取样切分，使用子数组中一小部分元素的中位数来切分，人们发现将取样大小设为3并用大小居中的元素切分效果最好。还可以将切分元素放在数组末尾作为哨兵来去掉数组边界检查。 123456789101112131415161718192021private static int partition(Comparable[] a, int lo, int hi)&#123; int x = median(a,lo,lo+1&gt;a.length-1?a.length-1:lo+1,lo+2&gt;a.length-1?a.length-1:lo+2); Comparable tmp = a[x]; exch(a,x,lo); int lf = lo; int ri = hi + 1; while(true)&#123; while (++lf &lt;= hi &amp;&amp; tmp.compareTo(a[lf])&gt;0); while (--ri &gt;= lf &amp;&amp; tmp.compareTo(a[ri]) &lt; 0); if (lf&gt;=ri) break; exch(a,lf,ri); &#125; exch(a,lo,ri); return ri;&#125;private static int median(Comparable[] x, int a, int b, int c)&#123; return x[a].compareTo(x[b])&gt;0 ? (x[a].compareTo(x[c])&gt;0 ? (x[b].compareTo(x[c]) &gt; 0 ? b : c):a) : (x[a].compareTo(x[c])&gt;0 ? a : (x[b].compareTo(x[c]) &gt; 0 ? c : b));&#125; 三项切分快速排序 对于包含大量重复元素的数组，使用三项切分将排序时间从线性对数降低到线性级别。性能优于普通快排123456789101112131415161718public static void sort3Ways(Comparable[] a, int lo, int hi)&#123; if (lo&gt;=hi) return; Comparable tmp = a[lo]; int i = lo+1; //始终等于tmp的最左位置 int lt = lo; //一次循环结束后，gt刚好在等于tmp的最右位置 int gt = hi; while(i&lt;=gt)&#123; int m = tmp.compareTo(a[i]); if (m&gt;0) exch(a,i++,lt++); //这里的i没有+1，是因为从右边换过来的item大小未知，需要在进行一次比较 else if (m&lt;0) exch(a,i,gt--); else i++; &#125; sort3Ways(a,lo,lt-1); sort3Ways(a,gt+1,hi);&#125; 12345private static void exch(Comparable[] source,int i, int j)&#123; Comparable tmp = source[j]; source[j] = source[i]; source[i] = tmp;&#125; 优先队列队列中的元素有优先级，最大有限队列，最小优先队列。以最大优先队列为例，这样的数据结构要求支持两种操作，删除最大元素和插入元素，这里我们学习基于二叉堆数据结构的一种优先队列的经典实现方式，用数组保存元素并按照一定条件排序，以高效的实现删除最大元素和插入元素操作。插入一列元素后一个一个的删除最小元素，就可以完成排序，堆排序算法就是源于优先队列的实现 实现数组实现（无序）参考下压栈的实现，插入时直接将元素插入到数组内，删除最大值时使用一个内循环获得最大元素，然后将最大元素与边界元素互换并删除最大元素。 数组实现（有序）插入时将所有较大元素向右移动一格保持数组有序，这样最大元素始终在边界 链表表示与数组实现类似，要么插入耗时删除高效，要么插入高效删除耗时 使用无序实现是惰性方法，我们仅在需要的时候才找出最大元素，使用有序实现是积极方法，在插入时保证有序。对于简单的队列和栈，所有操作都可以在常数时间内完成，而优先队列的最坏情况会达到线性时间。而基于数据结构堆的实现能保证插入和删除操作都能更快的执行。 二叉堆数据结构二叉堆的定义：当一个二叉树的每个节点都大于等于他的两个子节点，它被称为堆有序，就是二叉堆。根节点最大 数组实现二叉堆位置k的节点的父节点的位置是$\biggl\lfloor\frac{k}2\biggr\rfloor$，而他的两个子节点分别是2k和2k+1。这样在数组中使用索引在树中移动，很方便。根节点在数组索引为1的位置（不使用第一个位置）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MaxPQ &#123; private Comparable[] pq; private int N = 0; public MaxPQ(int maxN)&#123; pq = new Comparable[maxN + 1]; &#125; //插入操作，先插入到二叉堆最后位置，再上浮，保证堆有序 public void insert(Comparable a)&#123; pq[++N] = a; swim(N); &#125; //当元素比父节点大时，上浮保证堆有序 private void swim(int k)&#123; while(k&gt;1 &amp;&amp; pq[k].compareTo(pq[k/2]) &gt; 0)&#123; exch(k,k/2); k = k/2; &#125; &#125; //当元素比子节点小时，下潜保证堆有序 private void sink(int k)&#123; while (2*k&lt;=N)&#123; int j = 2*k; if (j&lt;N &amp;&amp; pq[j].compareTo(pq[j+1]) &lt; 0) j++; //如果父节点不比子节点小，结束循环 if (pq[k].compareTo(pq[j])&gt;0) break; exch(k,j); k = j; &#125; &#125; //删除最大节点分两步，现将最后的节点与首节点交换，再下潜首节点 public Comparable delMax()&#123; Comparable max = pq[1]; exch(1,N--); pq[N+1] = null; sink(1); return max; &#125; private void exch(int a, int b)&#123; Comparable tmp = pq[a]; pq[a] = pq[b]; pq[b] = tmp; &#125;&#125; 对于一个含有N个元素的基于堆的优先队列，插入操作只需不超过lgN+1次比较，删除最大元素需要不超过2lgN次比较。 优化二叉堆 调整数组大小 索引优先队列，暂不研究 堆排序我们可以把任意优先队列变成一种排序方法：将所有元素插入一个最小优先队列，再重复删除最小元素即可。我们基于堆实现一种排序方法。 基于堆的排序 用数组实现堆，首先将所有元素直接插入数组中 将前半部分元素倒序做下潜操作 从最后一个元素开始逐个做下潜操作12345678910111213141516171819202122232425262728public void sort(Comparable[] a)&#123; //N是有效元素大小（除去首位） int N = a.length-1; for (int i = N/2; i &gt;= 1; i--)&#123; sink(a,i,N); &#125; //将首位与最后一个交换，交换后，N减1（这是因为交换后最大元素已经在最后了，之后的操作与最后的最大元素无关），再做sink操作， while(N&gt;1)&#123; exch(a,N--,1); sink(a,1,N); &#125;&#125;private void exch(Comparable[] pq,int a, int b)&#123; Comparable tmp = pq[a]; pq[a] = pq[b]; pq[b] = tmp;&#125;private void sink(Comparable[] pq,int k,int N)&#123; while (2*k&lt;=N)&#123; int j = 2*k; if (j&lt;N &amp;&amp; pq[j].compareTo(pq[j+1]) &lt; 0) j++; if (pq[k].compareTo(pq[j])&gt;0) break; exch(pq,k,j); k = j; &#125;&#125; 堆排序优化先下沉再上浮：在下沉过程中可以将较大的元素直接放入堆底，再将其上浮，这样可以减少比较次数。堆排序是目前已知的唯一能够同时最优利用空间和时间的方法。在最坏的情况下也能保证2NlgN次比较和恒定的额外空间。 各算法对比]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析]]></title>
    <url>%2F2018%2F01%2F21%2Falgorithm-analysis%2F</url>
    <content type="text"><![CDATA[算法分析一个程序开始运行到结束需要多少时间，需要使用多少内存，都需要进行算法分析，以求算法达到相对优的性能。算法的时间复杂度和空间复杂度合称为算法的复杂度。 时间复杂度时间频度一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 时间复杂度在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 一般情况下，$f(n)=N^b(\log{N})^c$ 时间频度不同，但时间复杂度可能相同。如：T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。 指数阶0(2n)，显然，时间复杂度为指数阶0(2n)的算法效率极低，当n值稍大时就无法应用。 求时间复杂度 如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。1234567x=91; y=100;while(y&gt;0)&#123; if(x&gt;100) &#123; x=x-10; y--; &#125; else x++;&#125; 解答： T(n)=O(1)，这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到n没有?没。这段程序的运行是和n无关的，就算它再循环一万年，我们也不管他，只是一个常数阶的函数 当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)(其实就是时间频度的最高阶,低阶忽略)决定的。12345x=1;for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x++; 该程序段中频度最大的语句是第五行x++，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析第五行的执行次数：则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3) 算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。在数值A[0..n-1]中查找给定值K的算法大致如下：1234i=n-1;while(i&gt;=0&amp;&amp;(A[i]!=k)) i--;return i; 此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。 其实在进行算法时间复杂度分析时，我们是假设与输入状态无关的，如果无法保证这一点，那就应该对算法做一下处理： (1)对最坏情况下的性能保证(2)使用随机化算法、操作序列、均摊分析等方法，详见算法p125 时间复杂度评价性能有两个算法A1和A2求解同一问题，时间复杂度分别是T1(n)=100n2，T2(n)=5n3。 （1）当输入量n＜20时，有T1(n)＞T2(n)，后者花费的时间较少。 （2）随着问题规模n的增大，两个算法的时间开销之比5n3/100n2=n/20亦随着增大。即当问题规模较大时，算法A1比算法A2要有效地多。 它们的渐近时间复杂度O(n2)和O(n3)从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。 空间复杂度一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。 固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。一个算法所需的存储空间用f(n)表示。S(n)=O(f(n)) 其中n为问题的规模，S(n)表示空间复杂度。 两者关系在实际算法实现中，时间和空间复杂度通常处于相对立的形势，经常会出现牺牲空间提高时间情况。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atom_tips]]></title>
    <url>%2F2018%2F01%2F10%2Fatom-tips%2F</url>
    <content type="text"><![CDATA[1 快捷键 ctrl+tab切换标签页 ctrl+w 关闭当前标签页，ctrl+k ctrl+w关闭所有标签页 ctrl+shift+\ 切换到目录树，并定位到当前文件,在目录树中切换文件，按右箭头即可打开并回到工作区 ctrl+k ctrl+left arrow 或者 ctrl+k ctrl+right arrow可以在目录树和工作区切换]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2018%2F01%2F08%2Falgorithm%2F</url>
    <content type="text"><![CDATA[1 开平方求常数a的开平方，其实就是对于函数$f(x) = x^2 -a$求解$f(x) = 0$的$x$。这个函数在$x&gt;0$时单调递增，可以使用牛顿法逐步逼近。如图所示，先取一个值$x_0$,假设$x_0$是解，判断$x_0$不是解之后，使用$x_0$点的倒数求$x_1$，以此方式逐渐逼近正解。示例代码如下：123456789static double sqrt(double s)&#123; //当所求解与小于该值时，认为已求得正解 double err = 1E-15; double t = s; while(Math.abs(t - s/t) &gt; err)&#123; t = (t + s/t)/2; &#125; return t;&#125; 2 float的表示方法java中flaot采用IEEE 754标准，四字节32位0-31，分为三部分，符号位，指数位，尾数位。|符号位 | 指数位 | 尾数位 ||——-|——-|——-|| 1bit | 8 bit | 23 bit|(1).符号位(S)：最高位（31位）为符号位，表示整个浮点数的正负，0为正，1为负；(2).指数位(E)：23-30位共8位为指数位。根据IEEE754说明，指数的底数可能为2或者10(java中使用2)，规定指数位减去127为指数，取值范围：-127~128，表达式为：$2^{E−127}$。另外，标准中，还规定了，当指数位8位全0或全1的时候，浮点数为非正规形式（这个时候尾数不一样了），所以指数位真正范围为：-126~127。(3).尾数位(M)：0-22位共23位为尾数位，表示小数部分的尾数，即形式为1.M或0.M，至于什么时候是1，什么时候是0，则由指数和尾数共同决定。 小数部分最高有效位是1的数被称为正规（规格化）形式。小数部分最高有效位是0的数被称为非正规（非规格化）形式，其他情况是特殊值。 最终float的值 = $(-1)^{S} \cdot 2^{E-127} \cdot (1.M)$。所以java中的float这样表示，以8.25为例：首先将8.25转换为二进制1000.01，注意转换过程中整数部分与小数部分的区别，表示称二进制的科学计数法为$1.0001\cdot2^3$，也就是说,任何一个数都的科学计数法表示都为$1.xxxx\cdot2^3$，因为任何情况下，首位必为1，所以就省略首位1，将xxxx作为尾数位，所以虽然尾数位是23位，其实表示的是24位。然后指数3+127=130，把130转换成二进制保存在指数位。符号位为1。所以8.25在内存中的表达就是：这样就能解释float的精度问题了，float的有效位数由尾数位决定，23位尾数加上省略的尾数位最高位1，共24位，$2^24 = 16777216$，也就是说最高有效位数8位，但是16777216并不能覆盖所有8位数，所有最高有效位数是7位。另外，由于在计算过程中会出现四舍五入的情况，所以，在float中，前六位是绝对精确地，第七位可能不精确。总结，float有效位数7位，精确度6位。 3 判断素数原理：合数的最小质因子一定小于等于它的平方根。1234567static boolean isPrime(int n)&#123; if (n &lt; 2) return false; for (int i = 2; i * i &lt;= n; i++)&#123; if (n%i == 0) return false; &#125; return true;&#125; 4 调和数列与调和级数调和数列是自然数的倒数构成的数列，其前n项和就是调和级数。求调和级数直接便利求和 5 补码计算原理在计算机中，所有的数都是按照补码来存储并计算的，那么什么是补码呢？要完美的理解补码，就要完全抛开课本上以及博客上的关于原码高位不变低位取反加一的论调，并不是说他们是错的，只是取反加一以及最高位作为符号位的说法更适合计算方便，事实上计算机的计算方式确实是高位不变低位取反加一，但这种理解并不准确，相反完全增加了理解补码计算的难度。那么如何理解补码呢？首先，要理解模。以钟表为例，假如现在是三点，如果要求将时间回退五个小时，你会怎么办？两种方法： 顺时针拨动时针7格 逆时针拨动时针5格 第二个方法理解起来非常简单，回退嘛，那就逆时针，这里要着重说的是第一种，为什么顺时针也能达到逆时针的效果呢？其实，顺时针拨动7格，就是拨动(12-5)格，这里的12就是模，模的存在，将处于模之内的数构成一个环，环内的数都可以通过正向增长或逆向增长的方式变为环内的另一个数(其实就是取膜运算%)。若数超过模，那么就做取模处理，所以值永远小于模。如果时钟的例子不明朗，那么以十进制为例，以10为模，那么，6加7是3，6减3也是3，这就是模10的“环”。那么计算机中为什么要利用模来进行计算呢？因为计算机中只有加法计算，没有减法，任何减法运算都必须转换为加上一个负数来进行。这就带来一个问题，怎么表示这个负数，并且保证计算结果正确呢？这个时候就要使用补码了。现在知道，模有两个性质： 存在一个环，当数持续增长到溢出时，会回到最小值 模内的数无论做多少次加减，其值始终小于模，模类似一个极值 利用上述两个性质，我们可以将计算机的减法运算简化。在模的范围内，两个相加等于的模得数互为补数，以模10为例，1和9，2和8都互为补数，那么，模范围内的减法$a-b$就可以变换为$a+b\text{的补数}$，还是以模10为例$$5-1 = 5 + (10 -1) = 14 (1)$$14溢出要取模，最终结果是4，计算正确。其实这个过程里的+10就相当于绕环一圈回到正确位置，并不影响计算结果，但也因为这一圈，消除了减法，转换成了加法计算。那么，在计算机内是如何实现的呢？计算机中实现时，牵扯到一个问题，那就是式1的(10-1)在内存中该如何表示，因为既然我们要使用$a+b\text{的补数}$的方式计算，那么$b\text{的补数}$必定要满足两个要求： 避开减法运算，不能像式1那样还存在减法 在二进制中能直接通过位运算得到补数 于是，大牛们想到了一个完美的办法，映射。我们知道，长度为n的二进制数范围是$\left[0,2^n-1\right]$(后面成为集合Z)，共$2^n$个数,模为$2^n$。现在我们要表示$\left[-2^{n-1},2^{n-1}-1\right]$这个范围的数，也就是要把$\left[-2^{n-1},2^{n-1}-1\right]$内所有的数刚好映射到$\left[0,2^n-1\right]$上。主要分两部分： 对于在$\left[0,2^{n-1}-1\right]$范围内的数，可以保持原样(这个对应求补码的正数不变) 对于在$\left[-2^{n-1},0\right)$的数，使用补数映射到Z上，即对于x，在Z上有$2^n-\left|x\right|$与之对应，也就是说负数用她的绝对值的补数来表达。这也解释了为什么$-2^{n-1}$可以使用$1000 0000 …$这样的二进制来表达，因为刚好映射上了啊！这个映射过程其实刚好对应求负数补码的过程：符号位不变并取反加一，但是事实上，在补码的计算中，并不存在符号位。 那么，实际计算中，补码如何起作用呢？在上面的十进制例子中，式1，5-1的计算变换为5 + (10 -1)，加10相当于绕环一圈，计算结果14溢出取模后结果是4。也就是说，使用补数进行计算，只要真实结果没有溢出，那么可以直接拿补数相加的结果作为真实结果。回到二进制，在任意的二进制加减法中，因为使用了上述原理(就是补码)计算，所以补码的计算结果可以直接作为正确结果。需要注意的是，不同于上述十进制的例子，在计算机中，如果补码计算结果在$\left[0,2^{n-1}-1\right]$内，那么，所得结果即为正确答案，如果补码计算结果在$\left[-2^{n-1},0\right)$内，那么，所得结果需要做一个反向映射才是正确答案，但是内存中存储的始终是未做反向映射的那个值。举例来说：在8位计算机中，要把$\left[-128,127\right]$映射到$\left[0,255\right]$上，那么30-100其实就是30+(256-100) = 186,注意内存中始终存储的是186，但是当我们要读出来这个数时，cpu做了反映射 256-186 = 70，70就是所求的正确答案。 tip：其实映射的过程就是一个函数，函数图像为： 函数值为补码，x为真实值，内存中按照补码存储，需要真实值时做反映射。 所谓的符号位与取反加一我们知道，书本中说到补码的时候，都会从遵从原码反码补码的顺序，好像这三者是有着递进关系的，实际上并不是这样。但是我们所说的映射过程和由原码求补码是有一定关联的，下面以8位二进制为例作出解释。首先8位二进制在内存中共有0000 0000到1111 1111共256中情况，可以表示[-128,127]的范围，根据上述的映射原理，这个范围要分两个部分对待[-128,0)和[0,127]：对于数字2，2位于上图右半部分，补码映射函数是$f(x) = x$，其实这个函数映射关系就对应了书本上的正数的补码不变，所以补码是0000 0010,注意这个过程中并没有通过原码=&gt;补码来转换，而是直接用了映射，刚好对应。对于数字-2，-2位于上图左半部分，补码映射函数$f(x) = 256 - \left|x\right|$，具体计算是什么样呢？ 1234561 0000 0000 - 0000 0010= 1111 1111 + 0000 0001 - 0000 0010= (1111 1111 - 0000 0010) + 0000 0001= (1000 0000 + 0111 1111 - 0000 0000 - 0000 0010) + 0000 0001//第一个括号表示高位不变，第二个括号表示低位取反，最后加一= (1000 0000 - 0000 0000) + (0111 1111 - 0000 0010) + 0000 0001 这说明所谓的取反加一并没有什么神秘，只是二进制中求补数的一种便捷的分配算法而已。 关于反码我们知道，书本中说到补码的时候会从反码讲解过来，好像补码由反码加一而来，其实这么理解并不合适。上面已经说过补码的映射原理，其实求反码也是一个映射过程。还是以8位二进制为例，求反码的过程其实就是求原数字关于255的补数(对应到补码的模来理解，只不过这里的模是255)。 对于-2，反码计算 123451111 1111 - 0000 0010= 1111 1111 - 0000 0010= (1000 0000 + 0111 1111 - 0000 0000 - 0000 0010)//第一个括号表示高位不变，第二个括号表示低位取反，同样取反的言论只是一个计算而已，真正起作用的是求补数= (1000 0000 - 0000 0000) + (0111 1111 - 0000 0010) 那么求反码的过程还是把[-127,127]映射到[0,255]上。但是8位是可以表示256个数的，而模为255的时候只能表示255个数。多出一个怎么办？我们观察到，[-127,-1]会映射到[128，254]上，那反码255，也就是1111 1111表示什么呢？实际上，1111 1111在加一就是0000 0000，在反码计算中，这两个都可能代表0，一个是所谓的+0，一个是所谓的-0。也就是说，相比于补码，由于反码的模范围比它要表达的数范围大1，模的环出现了”裂缝”，被两个0打断，这也是计算机中补码优于反码计算的原因。 以2-2为例，解释两个0的现象 12342-2= 0000 0010 + 1111 1111 - 0000 0010= 0000 0010 + 1111 1101= 1111 1111 5 int溢出根据补码的映射与模环的理解，对于int的溢出后的值，可以这样求，int最大值2147483647： 比如2147483648，位于图像左半边，根据映射关系2147483648表示(2147483648 - 4294967296) = -2147483648 比如2147483649，位于图像左半边，根据映射关系2147483649表示(2147483649 - 4294967296) = -2147483647 比如4294967297，先取模4294967297%4294967296为1，位于图像右半边，根据映射关系4294967297表示1 关于int溢出例子Math.abs(-2147483648) = 2147483648，2147483648溢出，根据环，最后结果为-2147483648 6 String的intern()7 1/0与1.0/0.0前者是devide by zero异常，后者是无限大。1/0出现异常的原因是，1除以0在计算机中无法计算，除法过程会无限持续，另外，即使默认1/0结果是无限大或者NAN也不行，因为在int中没有定义正无穷负无穷和nan，整数是有限的。1.0/0.0结果是无穷大，这是因为float中的0并不完全是0，根据float在内存中的表达方式，0.0是极其接近0的一个小值，所以首先这个除法过程是可以进行的。另外在float中也定义了正负无穷，所以有结果。 8 float的三个值正无穷，负无穷，NaN。1.0/0.0 = POSITIVE_INFINITY(正无穷),It is equal to the value returned by Float.intBitsToFloat(0x7f800000).-1.0/0.0 = NEGATIVE_INFINITY(负无穷),It is equal to the value returned by Float.intBitsToFloat(0xff800000).0.0/0.0 = NaNPOSITIVE_INFINITY - POSITIVE_INFINITY = NaN另外需要注意的是，Float的MAX_VALUE和MIN_VALUE表示的是float所能表示的最大正数和最小正数(不是最小的负数) double也有相似的三个值。 9 负整数除法和模-14/3 = -4 余 -214/-3 = -4 余 2-14/-3 = 4 余 -2遵循向零取整：什么意思呢？比如两个正数10和4相除，商2.5，向零取整为2，那么余10-42 = 2；同理，在负数加入进来后，也遵循向零取整，如 -14/3，商-4.67，向零取整-4，那么余-14-(-43) = -2;再如14/-3商-4.67，向零取整-4，余14-(-3 * -4) = 2; 负数的模与上面同理。 10 位运算符1&amp; | ^ 11 求整数的二进制字符串1234567public static String getBanaryString(int n)&#123; String result = &quot;&quot;; for(int i = n; i &gt;= 1 ; i /= 2)&#123; result = i%2 + result; &#125; return result;&#125; 12 递归计算ln(N!)这个比较简单123456public static double calLn(int n)&#123; if(n == 1)&#123; return 0; &#125; return calLn(n-1) + Math.log(n);&#125; 13 递归计算二项分布算法4中的程序123456789public static double bino(int n, int k, double p)&#123; if(n == 0 &amp;&amp; k == 0)&#123; return 1; &#125; if(n &lt; 0 || k &lt; 0)&#123; return 0; &#125; return p*bino(n-1,k-1,p) + (1-p)*bino(n-1,k,p);&#125; 在出口出增加$n]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java小贴士]]></title>
    <url>%2F2018%2F01%2F08%2Fjava-tips%2F</url>
    <content type="text"><![CDATA[1 值传递与引用传递12345678910111213141516171819202122232425262728int num = 10;String str = &quot;hello&quot;//第一个例子：基本类型void foo(int value) &#123; value = 100;&#125;foo(num); // num 没有被改变//第二个例子：引用类型void foo(String text) &#123; text = &quot;windows&quot;;&#125;foo(str);// str 也没有被改变，这个过程其实是先分配一块内存并创建一个新的引用text，再将text指向了str的值hello，text = &quot;windows&quot;这个操作又将text指向了值为windows的对象，因此str没有改变。第三个第四个例子也可以这样理解。//第三个例子：提供了改变自身方法的引用类型StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder.append(&quot;4&quot;);&#125;foo(sb); // sb 被改变了，变成了&quot;iphone4&quot;。//第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。StringBuilder sb = new StringBuilder(&quot;iphone&quot;);void foo(StringBuilder builder) &#123; builder = new StringBuilder(&quot;ipad&quot;);&#125;foo(sb); // sb 没有被改变，还是 &quot;iphone&quot;。 2 变量的存储位置3 defaultjava8中，新增一个关键字default，它允许接口中的方法拥有方法体,实现该接口的类bu可以不实现该方法。这个关键字在集合框架中使用过。12345public interface Default &#123; default public void method()&#123; System.out.println(&quot;method in interface&quot;); &#125;&#125; 123456789101112public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 4 transient被transient修饰的变量不会被序列化 5 volatilecas技术的应用，在ConCurrentHashMap中的使用 6 锁机制synchronized与lock 7 线程间通信轮询joincountdownlatchCyclicBarrier返回结果 futuretask 8如果在一个线程计算过程中不允许有更大的本地方法栈，那么JVM就抛出StackOverflowError 如果本地方法栈可以动态地扩展，并且本地方法栈尝试过扩展了，但是没有足够的内容分配给它，再或者没有足够的内存为线程建立初始化本地方法栈，那么JVM抛出的就是OutOfMemoryError。 9 handler机制A. Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分组成的。B. Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。C. Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。D. 当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。 E. 当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。 10 activity栈管理AMS activitymanagerservice 负责activityrecord taskrecord activitystack都是ams抽象出来的概念 11 网络okhttp 12 concurrenthashmap13 IPC14 FutureFutureTask 实现了Future和Runnable，FutureTask本质还是一个runnable，但是FutureTask中有Callable的引用，在线程执行run时，会调用call，所以对于FutureTask来说，真正的执行位置是callable AsyncTask也是使用了Future，有两个线程池，一个用于真正执行，有核心线程数和最大线程数的限制，另一个维护一个队列用于给任务排序。AsyncTask是序列执行任务的。一个应用中所有的AsyncTask共享同一个线程池。 15 访问修饰符类访问修饰符有default和public两种，public是任何其他类都可以访问，default是只有包内可以访问，包内指同一级目录方法和成员变量访问修饰符有public、protected、default、private四种：其中public是任何类都能访问到，protected是子类可以访问，default是包内可以访问，private是是有类内部可以访问需要特殊注意的是内部类内部类不管是普通内部类还是静态内部类都可以访问外部类的所有变量 16 类型转换12short i = 1;i = i + 1; 上面代码有问题么？答案是有，需要强制类型转换 17 &amp; &amp;&amp;Java中&amp;&amp;和&amp;都是表示与的逻辑运算符，都表示逻辑运输符and，当两边的表达式都为true的时候，整个运算结果才为true，否则为false。&amp;&amp;的短路功能，当第一个表达式的值为false的时候，则不再计算第二个表达式；&amp;则两个表达式都执行。&amp;可以用作位运算符，当&amp;两边的表达式不是Boolean类型的时候，&amp;表示按位操作。 18 面向对象]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中boolean类型的大小]]></title>
    <url>%2F2018%2F01%2F08%2Fboolean-size-in-java%2F</url>
    <content type="text"><![CDATA[在Java中，int，float，double等基本类型所占字节大小都有明确说明，唯独boolean类型没有，那么boolean类型的大小究竟是多少呢？ Java SE Specification(java 8)先看java官方规范中怎么说，规范网址，下面是摘抄： The boolean TypeAlthough the Java Virtual Machine defines a boolean type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on boolean values. Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine int data type. The Java Virtual Machine does directly support boolean arrays. Its newarray instruction (§newarray) enables creation of boolean arrays. Arrays of type boolean are accessed and modified using the byte array instructions baload and bastore (§baload, §bastore). In Oracle’s Java Virtual Machine implementation, boolean arrays in the Java programming language are encoded as Java Virtual Machine byte arrays, using 8 bits per boolean element. The Java Virtual Machine encodes boolean array components using 1 to represent true and 0 to represent false. Where Java programming language boolean values are mapped by compilers to values of Java Virtual Machine type int, the compilers must use the same encoding.尽管java定义了boolean类型，但并没有提供更多的支持，也没有任何一种jvm有专用于boolean的虚拟机指令，事实上，java程序中的boolean都被编译成int类型，也就是说，单个的boolean类型在编译后占4个字节。jvm并不直接支持boolean类型的数组，boolean类型的数组其实是byte类型的数组，也就是说，boolean类型的数组编译后每个boolean元素是一个byte，也就是1个字节。boolen数组中使用1表示true，0表示false，需要注意的是，虽然在数组中使用byte表示boolena，但是一旦将其取出，那么走出数组的boolean必须转换成int类型，这在boolena数组的baload, bastore中有所体现。 #### 操作码baloadThe arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index must be of type int. Both arrayref and index are popped from the operand stack. The byte value in the component of the array at index is retrieved, sign-extended to an int value, and pushed onto the top of the operand stack. 将数组的某一byte元素取出转为int类型并push到栈上 操作码bastoreThe arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index and the value must both be of type int. The arrayref, index, and value are popped from the operand stack. The int value is truncated to a byte and stored as the component of the array indexed by index.将int类型数据截断为byte类型，并存储在在数组内 为什么这么设计the JVM uses a 32-bit stack cell, used to hold local variables, method arguments, and expression values. Primitives that are smaller than 1 cell are padded out, primitives larger than 32 bits (long and double) take 2 cells. This technique minimizes the number of opcodes, but does have some peculiar side-effects (such as the need to mask bytes). Primitives stored in arrays may use less than 32 bits, and there are different opcodes to load and store primitive values from an array. Boolean and byte values both use the baload and bastore opcodes, which implies that boolean arrays take 1 byte per element. opcodes就是操作码，也叫机内码，指令序列等，用来告诉CPU需要执行哪一条指令，上面的bastore就是操作码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[daydream_media_app]]></title>
    <url>%2F2018%2F01%2F03%2Fdaydream-media-app%2F</url>
    <content type="text"><![CDATA[图片视频格式的检测 将Texture按宽高比降采样，假设图片比例是1:1，那么用于检测格式的texture大小是16x16.检测的方式是按照三色值差异， 以判断左右格式为例，左右两部分相对应的像素分别进行比较 •遍历后得到八组diff值，diff值累加后求平均作为左右格式判断依据，如果小于经验值，这可认为是左右格式 x = pixel.x /= range.x y = pixel.y /= range.y z = pixel.z /= range.z diff = (x1-x2,y1-y2,z1-z2) range是最亮像素与最暗像素的差值 然后所得diff值的平方相加即为总差异值，总差异值除以判断的像素数量为单个像素差异值R，取R的元素的平均值用于比较同理得上下格式的判断结果 同理可得上下格式的差异值SIMILARITY_THRESHOLD 经验值，0.025，差异值低于改值即为stereo图片 手柄拖拽屏幕的实现2.1 三个事件：OnBeginDrag OnDrag OnEndDrag 2.2 四元数：求模N(q) = |q| = x2 + y2 + z2 + w2 求共轭q=(-x, -y, -z, w)根据定义易得：(hk) = kh;(在屏幕旋转时有用，后面讲到) 求逆对于向量逆的定义, q-1 =q/|q|2对于单位四元素，分母为1，q-1 = q =(-x, -y, -z, w) 无交换律，有结合律 unity里的四元数都是单元四元数，莫均为一，所以共轭与逆一致 2.3 四元数逆在旋转中的意义问题：将空间点P(1,0,1)绕轴(0,1,0)旋转90度，将会得到点(1,0,-1) 张国强 &gt; MediaApp技术点 &gt; 1获.PNG •使用四元数计算过程如下：将点P四维化为 (1,0,1,0) 四元数 q = ( (0,1,0)sin45 , cos45) 计算 qpq-1可得结果P` •q-1 = (-(0,1,0)sin45,cos45) = ((0,1,0)sin-45,cos-45)即四元数的逆是按同一旋转轴反方向旋转同一角度 2.4 拖拽屏幕效果：屏幕始终与双眼平行，看向屏幕时视线与屏幕垂直，拖拽过程中光标在屏幕上的位置不变 2.4.1 实现拖拽//根据光标的方向得到绕x轴和y轴的旋转角，余弦定理，根据旋转角得到四元数，仅计算水平角度和垂直角度（具体实现未给出，可自行计算）Quaternion yawPitchRotation = CalculateControllerYawPitchRotation(eventData);//根据新的光标四元数和上一次的光标四元数，得到新的屏幕的旋转四元数，Quaternion.Inverse(lastYawPitchRotation)会使屏幕先回到上一次旋转之前的状态，再乘以新的光标四元数，就是屏幕新的位置，这样就使光标在屏幕上的点的位置不变，yawPitchRotationDelta 可理解为旋转偏差量Quaternion yawPitchRotationDelta = yawPitchRotation Quaternion.Inverse(lastYawPitchRotation);transform.parent.localRotation = yawPitchRotationDelta transform.parent.localRotation; yawPitchRotation：当前帧手柄相对于相机的旋转 lastYawPitchRotation：上一帧手柄相对于相机的旋转 yawPitchRotationDelta：两帧之间旋转差值 Quaternion.Inverse：取逆 2.4.2 矫正扭转 光标的旋转是一个点的四元数，把点的旋转应用在面上时，由于面与旋转轴的夹角，各部分在旋转相同角度下位移不同，会出现扭转，所以如果要保证屏幕始终平行两眼，在拖拽完成后要进行矫正 Vector3 eulerAngles = transform.parent.localRotation.eulerAngles;eulerAngles.z = 0.0f;lastFinalRotation = Quaternion.Euler(eulerAngles);lastYawPitchRotation = yawPitchRotation;if (enableRotation){transform.parent.localRotation = lastFinalRotation;} 3.屏幕反光的实现•两个元素，灯光颜色和强度•颜色：计算平均颜色，播放时，每隔多帧计算一次 blit 4x4，得4x4的texture，计算三色的平均值•强度：设定两个高度临界值，当屏幕位置低于最低值时，灯光完全消失，在临界值之间时，灯光强度与屏幕高度和light高度有关，当屏幕位置大于最高值时，灯光亮度只与light高度有关float intensity =Mathf.Clamp01((y - heightMin) / (heightMax - heightMin));]]></content>
  </entry>
  <entry>
    <title><![CDATA[unity中使用shader增强视频]]></title>
    <url>%2F2018%2F01%2F03%2Frenderer-texture-with-shader%2F</url>
    <content type="text"><![CDATA[使用shader对视频texture做特效处理该功能主要在片元着色器中实现，考虑到是移动设备，因此要兼顾考虑效果和性能。在shader中的实现，这里只展示像素增强算法，关于shader的结构请看其他 变量_MainTex当前渲染的texture _MainTex_TexelSize_MainTex_TexelSize这个变量的从字面意思是主贴图 _MainTex 的像素尺寸大小，是一个四元数，是 unity 内置的变量，它的值为 Vector4(1 / width, 1 / height, width, height) _ColorBoost自定义关于亮度、对比度、饱和度、色弱调整的参数1&quot;_ColorBoost&quot;,(_brightness, cont, _saturate, _daltonize * 10f)); _Sharpen自定义关于锐化的参数1&quot;_Sharpen&quot;,(sharpen, _sharpenDepthThreshold, _sharpenClamp, _sharpenRelaxation) shader1234567891011121314151617181920212223242526272829303132333435363738394041uniform sampler2D _MainTex;uniform float4 _MainTex_TexelSize;uniform float4 _ColorBoost;uniform float4 _Sharpen;float getLuma(float3 rgb) &#123; const float3 lum = float3(0.299, 0.587, 0.114); return dot(rgb, lum);&#125;void beautifyPassFast(v2f i, inout half3 rgbM) &#123; half2 xInc = half2(_MainTex_TexelSize.x, 0); half2 yInc = half2(0, _MainTex_TexelSize.y); half lumaM = getLuma(rgbM); half3 rgbN = tex2D(_MainTex, saturate(i.uv + yInc)).rgb; half3 rgbS = tex2D(_MainTex, saturate(i.uv - yInc)).rgb; half3 rgbW = tex2D(_MainTex, saturate(i.uv - xInc)).rgb; half lumaN = getLuma(rgbN); half lumaW = getLuma(rgbW); half lumaS = getLuma(rgbS); half maxLuma = max(lumaN,lumaS); maxLuma = max(maxLuma, lumaW); half minLuma = min(lumaN,lumaS); minLuma = min(minLuma, lumaW) - 0.000001; half lumaPower = 2 * lumaM - minLuma - maxLuma; half lumaAtten = saturate(_Sharpen.w / (maxLuma - minLuma)); rgbM *= 1.0 + clamp(lumaPower * lumaAtten * _Sharpen.x, -_Sharpen.z, _Sharpen.z); // 3. Vibrance half3 maxComponent = max(rgbM.r, max(rgbM.g, rgbM.b)); half3 minComponent = min(rgbM.r, min(rgbM.g, rgbM.b)); half sat = saturate(maxComponent - minComponent); rgbM *= 1.0 + _ColorBoost.z * (1.0 - sat) * (rgbM - getLuma(rgbM)); // 5. Final contrast + brightness rgbM = (rgbM - halves) * _ColorBoost.y + halves; rgbM *= _ColorBoost.x;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb_tips]]></title>
    <url>%2F2018%2F01%2F02%2Fadb-tips%2F</url>
    <content type="text"><![CDATA[修改系统文件以修改hosts为例首先手机需要root adb root adb remount adb push 将修改过的hosts文件push进去]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFT 和 DTFT]]></title>
    <url>%2F2017%2F12%2F31%2FDFT-and-DTFT%2F</url>
    <content type="text"><![CDATA[几种傅立叶变换 连续时间周期信号:处理时间连续并且具有周期性的信号，其频域上离散，非周期。 连续时间非周期信号:处理时间连续但是不具有周期性的信号，其频域上连续，非周期。 离散时间非周期信号:处理时间离散，不具有周期性的信号，其频域上连续，有周期性。 离散时间周期信号:处理时间离散，具有周期性的信号，对应离散时间傅里叶变换其频域上离散，有周期性。 关于时域是否离散与频域周期性的关系为什么时域离散，频域周期，时域连续，频域非周期呢？如果你的频域是离散的，那么就有一个最小的分辨频率，这个自然对应了时域的最大波长，即时域的周期性。反之同理。如果你的时域是离散的，那就有一个最小的波长。这个波长就对应频域的最高频率。所有高于这个频率的信息，都要被alias、反褶到低频去。即频域的周期性。 离散时间傅立叶变换离散时间傅里叶变换（英语：Discrete-time Fourier Transform，简称：DTFT）是傅里叶变换的一种。它将以离散时间nT（其中，T为采样间隔）作为变量的函数（离散时间信号）变换到连续的频域，即产生这个离散时间信号的连续频谱，值得注意的是这一频谱是周期的，周期为$2\pi$。 离散傅立叶变换理解从理论上来说，上述四种变换基本囊括我们能遇到的信号种类。但是在数字信号处理里面，我们接触的都是离散时间的信号，所以前两种连续时间的傅里叶变换用不到。剩下的两种变换中，DFT与离散时间周期信号的变换非常类似，有何原因？在数字信号处理中，信号是要交给计算机进行处理的，这其中涉及到对数字信号的进行处理交给计算机以及计算机的算法设计，对于一般的离散时间信号而言，从数学上直接用DTFT会非常利于分析信号的频域特征，但问题是目前的机器不能表达一个无限长的序列，也不能表达连续的频域特征。因此我们才需要DFT，也就是说DTFT是给人用的，而DFT是给机器用的。DFT相较于DTFT，主要有两处不同，一点是变无限为有限，是因为机器无法表示无限长的序列，只能处理有限长序列。另一点是频域采样，关于采样，是理解DFT的重点。 频域采样我们前面提到离散非周期序列的傅里叶变换(DTFT)在频域上是连续的，这连续的频域特征机器是无法表达的，因此我们需要对它进行采样。又由于频域上具有周期性，只需要对2pi长度的区间采样即可。那么应该采多少个点呢？类似于Nyquist采样定理的做法，我们得出采样的点数M≥N即可(N表示该序列的长度)，为了方便起见只需取M=N。由此，DFT的两个引入动机就清楚了:它是对无限长序列截断成有限长序列，进行DTFT以后再在频域采样。那么为何DFT的形式和离散时间周期信号的傅里叶变换形式类似呢？注意到，有限长序列经过周期延拓即可变为周期信号，因此他们之间的相似性也不言而喻了。不过需要注意的是DFT对有限长序列均可以用，但离散时间周期信号的傅里叶变换只能处理周期信号，这是本质的不同。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客建立]]></title>
    <url>%2F2017%2F12%2F27%2Fbuild-blog-on-github%2F</url>
    <content type="text"><![CDATA[遇到的问题公式打开mathjax如果使用了主题，在主题的_config.yml中打开mathjax12345# MathJax Supportmathjax: enable: true per_page: true cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 在文档Front-matter中启用mathjax这是为了渲染快，因为没有公式的文档不需要渲染123456---title: 卷积与傅立叶date: 2017-12-26 21:46:15tags:mathjax: true--- latex与markdown冲突：参照latex与markdown语法冲突解决比如latex中的下标符号_，markdown会先识别为斜体，这样公式就不能渲染了，以及\转义会影响latex换行的识别，对于这种情况，两种方法解决： 将公式中的替换为转义\即可，但是这样做，虽然生成的网页正常，但是markdown preview的时候会出错； 修改renderer引擎的转义定义:1234// 取消`\`转义（注意：这里的修改与上面链接中修改有区别）:escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,// 取消`_`转义：em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, Atom可以实时预览公式安装 latex 预览packagectlr + shift + x Markdown语法GitHub Markdown 语法 hexo 文章 hexo new android开发 草稿 创建草稿：hexo new draft 制作抖音视频 发布草稿：hexo publish 制作抖音视频 同步到github hexo d 如果丢失github权限 ssh-add github_rsa]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积与傅立叶]]></title>
    <url>%2F2017%2F12%2F26%2Fconvolution-introduction%2F</url>
    <content type="text"><![CDATA[卷积函数定义：设:$f(x)$, $g(x)$ 是R1上的两个可积函数，作积分$${\int_{-\infty}^{\infty}}f(\tau)\ast\,g(x-\tau)\,\mathrm{d}\tau$$ 可以证明，关于几乎所有的实数$x$，上述积分是存在的。这样，随着$x$的不同取值，这个积分就定义了一个新函数$h(x)$，称为函数$f$与$g$的卷积，记为$h(x)=(f\ast\,g)(x)$。容易验证，$(f\ast\,g)(x)=\,(g\ast\,f)(x)$，并且 $(f\ast\,g)(x)$ 仍为可积函数。这就是说，把卷积代替乘法，$L1(R1)$空间是一个代数，甚至是巴拿赫代数。离散表达：$$y(n) = \sum_{i=-\infty}^{\infty}x(i)h(n-i) = x(n)\ast\,h(t)$$ 理解首先要明确，卷积只在线性时不变系统起作用，所以我们接下来的讨论均在此条件下进行。线性时不变系统： 线性系统：系统的输入和输出具有线性关系 时不变系统：系统的参数不随时间而变化，即不管输入信号作用的时间先后，输出信号响应的形状均相同，仅是从出现的时间不同，与系统状态无关。 物理意义：对于输入信号$f(τ)$,响应函数$g(τ)$，在t时刻的输出信号即为两者的卷积： $${\int_{-\infty}^{\infty}}f(\tau)g(t-\tau)\,\mathrm{d}\tau$$该式与上面公式区别仅在于改变了变量符号为时间t，主要为了便于理解。 离散情况那么，为什么将两个时间信号这样积分，或者说求卷积就是t时刻的输出信号呢？举例来说：第一年，小明存入100元钱，年利率是5%，按复利计算（即将每一年所获利息加入本金，以计算下一年的利息），那么在五年之后他能拿到的钱数是$100(1+5\%)^5$，如此类推，第二年存入100，四年后能拿到$100(1+5\%)^4$，连续存五年，列表如下： 本金 第一年 第二年 第三年 第四年 第五年 $\small100$ $\small100(1+5\%)^1$ $\small100(1+5\%)^2$ $\small100(1+5\%)^3$ $\small100(1+5\%)^4$ $\small100(1+5\%)^5$ $\small100$ $\small100(1+5\%)^1$ $\small100(1+5\%)^2$ $\small100(1+5\%)^3$ $100(1+5\%)^4$ $\small100$ $\small100(1+5\%)^1$ $\small100(1+5\%)^2$ $\small100(1+5\%)^3$ $\small100$ $\small100(1+5\%)^1$ $\small100(1+5\%)^2$ $\small100$ $\small100(1+5\%)^1$ $\small100$ 最终，在第五年小明拿到钱：$$\small100(1+5\%)^1 + 100(1+5\%)^2 + 100(1+5\%)^3 + 100(1+5\%)^4 + 100(1+5\%)^5$$对应到上面的离散公式：$$\sum_{i=0}^{5}x(i)h(5-i)$$其中，$x(i) = 100$,$h(5-i) = {(1+5)}^{5-i}$ 这里计算结果即为在第五年拿到的总钱数，也是小明存钱函数（输入信号）$x(i) = 100$与复利计算函数（响应函数）$h(i) = {(1+5)}^{i}$ 的卷积结果。 连续情况初次看到卷积积分公式时，对于将两个关于$x$的函数在$τ$上积分不理解，这也直接导致对卷积数学意义和物理意义的理解偏差。举例，假如有响应函数$h(t)$,那么对于输入信号$f(t)$，在时刻T，将两者反褶相乘积分，画图举例 （） 其实，$τ$也是时间，只是我们在积分公式中，给定了时刻$t$。而给定t意味着输入信号与响应函数的相对位置确定，这就然后让$τ$在 $(-\infty,t]$ 上积分，我们知道积分可以看作无数个值的累加，那么从左往右的累加过程，就是 $(-\infty,t]$ 中所有时刻输入信号在响应函数作用下对t时刻输出信号的累加，这就是卷积。那么为什么会出现$τ$、$t-τ$、$τ+(t-τ)$刚好是t的看似巧妙的情况呢？这是因为，如果当前时间为t，那么在0时刻的输出信号在t时刻的响应函数就是$h(t-0)$,同样的，在τ时刻的输出信号在t时刻的响应函数就是$h(t-τ)$,没有什么数学上的巧合与美丽，只有实际的应用与计算。其实写到这里，已经觉得是在说废话了。 假设在一个线性时不变系统中，输入信号$x(t)$, 冲击信号$h(t)$,那么输出信号即为$x(t)\ast\,h(t)$，其步骤为： 变换变量$t$为$τ$ 冲击信号反褶 $h(-τ)$ 时移 $h(t-τ)$ 相乘 $x(τ)h(t-τ)$ 积分 这是卷积计算的步骤，很好理解，很好计算，这里权作记录。 矩阵卷积矩阵的卷积与一维离散卷积类似，只是反转平移的过程变为将响应矩阵旋转180度，这样刚好形成$f(τ)h(t-τ)$。比如，现有矩阵A，B：$${A} = \left(\begin{matrix} 1 &amp; 2 \ 3 &amp; 4 \end{matrix} \right)\,\,\,\,\,\,{B} = \left(\begin{matrix} 5 &amp; 6 \ 7 &amp; 8 \end{matrix} \right)$$变化矩阵B，三种方法： 直接旋转180 沿对角线分别反转 同时反转行和列三种方法只是利用了矩阵基本性质，不赘述。假设B翻转后得矩阵C：$${C} = \left(\begin{matrix} 8 &amp; 7 \ 6 &amp; 5 \end{matrix} \right)$$那么，AB卷积的过程就是是将AC矩阵对应位置的元素相乘，并将结果累加，在图像处理中经常用到这种方法。AB卷积结果为：$$5\cdot8+6\cdot7+7\cdot6+8\cdot5 = 164$$在深度学习中，矩阵卷积应用广泛，具体可参考 – 矩阵卷积 卷积定理卷积定理是傅立叶变换满足的一个重要性质。卷积定理指出，函数卷积的傅立叶变换是函数傅立叶变换的乘积。具体分为时域卷积定理和频域卷积定理，时域卷积定理即时域内的卷积对应频域内的乘积；频域卷积定理即频域内的卷积对应时域内的乘积，两者具有对偶关系。若 $$f_1(t)\leftrightarrow\,F_1(\omega)$$ $$f_2(t)\leftrightarrow\,F_2(\omega)$$$F$ 表示傅里叶变换。则时域卷积定理：$$F(f_1(t)\ast\,f_2(t)) = F_1(\omega)F_2(\omega)$$频域卷积定理：$$F[f_1(t)f_2(t)] = \frac{1}{2\pi}F_1(\omega)F_2(\omega)$$卷积定理揭示了时间域与频率域的对应关系。 去卷积傅里叶傅里叶级数对于任意周期函数，都可以表示成一系列三角函数的和。那么为什么可以做这种变换呢？这可以几何或者矩阵做类比，在三维空间几何中，我们可以用$(1,0,0),(0,1,0),(0,0,1)$三个空间向量的线性组合来表示这个空间中的所有向量，这三个向量两两正交，称为三维空间向量的基。同理从矩阵的角度看，单元矩阵的每行或者每列也是两两正交，那么每一行都可以看作这个矩阵空间的基，使用这些基向量的线性叠加可以表示任意一个矩阵,如下：$$\left(\begin{matrix} 1 &amp; 0 \ 0 &amp; 1 \end{matrix} \right) = \left(\begin{matrix} 1 &amp; 0 \ 0 &amp; 0 \end{matrix} \right) + \left(\begin{matrix} 0 &amp; 0 \ 0 &amp; 1 \end{matrix} \right)$$而对于函数，数学家也发现同样的现象，使用无数个相互正交的函数可以近似的表示任意一个周期函数，问题是这无数个两两正交的函数怎么找呢，三角函数刚好完美支持，而傅里叶级数选取的这个基函数就是三角函数,事实上，傅里叶级数可以有多种变化方式，三角函数只是其中一种。三角函数的正交性： 下面我们看傅里叶级数的表达，对于任意周期为T的函数，只要满足狄利赫里条件，则函数可以表达为：$$f(x) = \sum_{k=1}^\infty(a_k\,sin(kx) + b_k\,cos(kx)) + \frac{a_0}{2}$$ 其中：$$a0 = \frac{2}{T}\int{-\frac{T}{2}}^{\frac{T}{2}}f(x)dx$$ $$ak = \frac{2}{T}\int{-\frac{T}{2}}^{\frac{T}{2}}f(x)sin(kx)dx$$ $$bk = \frac{2}{T}\int{-\frac{T}{2}}^{\frac{T}{2}}f(x)cos(kx)dx$$ 关于$a_0$:将傅里叶级数两边在一个周期上同时积分，$sin$、$cos$的积分均为0，即可得$a_0$ 关于$a_n$:等式两边同时乘以$sin(nx)$再进行积分，根据三角函数正交定理，只有同频率的元素在周期上的积分才不为零： $$\int{-\frac{T}{2}}^{\frac{T}{2}}f(x)sin(kx)=\int{\frac{2}{T}}^2{a_n}\,sin(kx)^2dx$$ $$\int_{-\,\frac{T}{2}}^{\frac{T}{2}}f(x)sin(kx) = a_n\frac{T}{2}$$ 即得$a_n$同理得$b_n$傅里叶展开后，原函数与展开式，以及展开式的频谱、相位关系图，现在有了各频率下的幅值和相位，原函数的频域信息就都体现出来了： 可以看出，将展开级数沿z轴放置，从图右边看，就是频谱，从上面看就是相位，需要注意的是，由于傅里叶级数中只使用了正弦和余弦函数，因此相位永远是0或者$\pi$，另外，级数展开后得频率非连续，是一个个独立的幅值，对应的频率是原函数频率的整数倍，这样的频谱是离散的。下面的动图也有助于理解： 傅里叶级数的复数形式复数形式可以由欧拉公式变化而来，只是简单的代入，不再赘述。欧拉公式：$$e^{it} = cos(t) + isin(t)$$傅里叶复数：$$f(x) = \sum_{-\infty}^{\infty}a_ke^{jk\omega\,t}$$其中：$$ak = \frac{1}{T}\int{-\frac{T}{2}}^{\frac{T}{2}}x(t)e^{-jk\omega\,t}dt$$ 傅里叶变换傅里叶级数有其局限性，只能用于周期函数，那么对于非周期函数怎么办呢？对于非周期函数，我们可以这样思考，非周期看作周期无穷大，那么对应的$\omega$则无穷小，傅里叶级数：$$f(t) = \frac{1}{2\pi}\int{-\infty}^{\infty}F(\omega)e^{i\omega\,t}d\omega$$其中：$$F(\omega) = \int{-\infty}^{\infty}f(t)e^{-i\omega\,t}dt$$注意,第二个公式才叫做 $f(x)$ 的傅里叶变换。更重要的是，这个式子里的角频率 $\omega$ 就不是某一个频点了，它可以取频谱轴上的任意值，它是连续的！非周期的信号的频谱遍布整个频率轴！对某一点特定角频率 $\omega$ 取值，$F(\omega)$ 就是角频率 $\omega$ 在信号 $f(t)$ 中的”份量”！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理基础]]></title>
    <url>%2F2017%2F12%2F26%2Fimage_processing%2F</url>
    <content type="text"><![CDATA[锐化锐化(image sharpening)是补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像变得清晰。从频域的角度理解是增强图像的高频分量。目前主流软件锐化方式主要有全局锐化和局部锐化，本文主要涉及全局锐化，局部今后另说。 全局锐化原理：理论上来说，全局锐化是滤波算法的逆应用滤波结果 = 过滤掉图像细节的输入图像图像细节 = 输入图像 - 滤波结果锐化结果 = 输入图像 + 锐化系数 X 图像细节所以说有多少种滤波算法，就有多少中锐化算法。 锐化的核心目的是强化图像轮廓，比如人体的眼眶，帽子的帽沿，将非轮廓的地方锐化，对于增强整体的形态并无太大帮助。而全局锐化是将整个图像进行无差别增强，这也是全局锐化的不足之处。 实际应用中，简单的全局锐化可以使用Unsharp Mask(USM)算法。 $$y(n,m) = x(n,m) + \lambda\,z(n,m)$$其中，$x(n,m)$ 为输入图像，$y(n,m)$ 为输出图像，而$z(n,m)$ 为校正信号,在锐化中就是图像细节信号，一般是通过对$x$进行滤波获取。$λ$是用于控制增强效果的的一个缩放因子。在传统的USM算法中，$z(n,m)$ 一般可以通过下式获取： $$z(n,m)=4x(n,m)-x(n-1,m) -x(n +1,m)-x(n, m-1) -x(n,m+1)$$图像滤波的过程就是卷积核对图像上所有像素点及其临近像素进行对应相乘叠加的结果。如图：注意：这个对应元素相乘累加的过程，就是两个矩阵离散卷积的过程。根据卷积定理：函数卷积的傅立叶变换是函数傅立叶变换的乘积，那么我们只要使矩阵B的频谱中不包含频率 $\omega$，就能保证卷积结果中也不包含频率 $\omega$，这就是滤波的由来。 上式对应的卷积核为 局部锐化局部锐化可以弥补全局锐化的不足，将锐化的重心放在图像的边缘处（比如头发丝，脸颊），突出形体和轮廓。这就需要做出边缘检测，目前流行算法Laplician of Gaussian(LoG)，据说PS中用于Edge Dectection的高反差保留以及照片边插画的核心算法都是这个。 滤波算法根据卷积定理：函数卷积的傅立叶变换等于两个函数傅立叶变换的乘积，那么如果用于卷积的卷积核损失了高频或者低频的部分，卷积后的图像频谱相应的也会损失对应的频率，这就是滤波器的工作原理。 线性滤波器（均值滤波）线性滤波器的原始数据与滤波结果是一种算术运算，即用加减乘除等运算实现，如均值滤波器（模板内像素灰度值的平均值）、高斯滤波器（高斯加权平均值）等。由于线性滤波器是算术运算，有固定的模板，因此滤波器的转移函数是可以确定并且是唯一的（转移函数即模板的傅里叶变换）。卷积可以说是图像处理最基本的操作，但却非常有用。这个操作有两个非常关键的特点：它们是线性的，而且具有平移不变性shift-invariant。平移不变性指我们在图像的每个位置都执行相同的操作。线性指这个操作是线性的，也就是我们用每个像素的邻域的线性组合来代替这个像素。这两个属性使得这个操作非常简单，因为线性操作是最简单的，然后在所有地方都做同样的操作就更简单了。2D卷积需要4个嵌套循环4-double loop，所以它并不快，除非我们使用很小的卷积核。这里一般使用3x3或者5x5。而且，对于滤波器，也有一定的规则要求： 滤波器的大小应该是奇数，这样它才有一个中心，例如3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。 滤波器矩阵所有的元素之和应该要等于1，这是为了保证滤波前后图像的亮度保持不变。当然了，这不是硬性要求了。 如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。 对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。平滑均值滤波器$$\frac{1}{9}\left(\begin{matrix} 1 &amp; 1 &amp; 1\ 1 &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1\end{matrix} \right)$$这是一个低通滤波器，其频谱的高频部分幅值很低甚至为零，也就是说会过滤掉高频部分，结果是将图像进行平滑处理。锐化均值滤波器$$\left(\begin{matrix} -1 &amp; -1 &amp; -1\ -1 &amp; 8 &amp; -1 \ -1 &amp; -1 &amp; -1\end{matrix} \right)$$这是一个高通滤波器，其频谱的低频部分幅值很低甚至为零，也就是说会过滤掉低频部分，结果是将图像进行锐化处理。高斯滤波器高斯滤波器是低通滤波，滤波后图像被平滑的程度取决于标准差。它的输出是领域像素的加权平均，同时离中心越近的像素权重越高。因此，相对于均值滤波（mean filter）它的平滑效果更柔和，而且边缘保留的也更好。高斯滤波简单说就是卷积核的概率分布服从高斯分布。自然界里高斯分布遍布各处，使用高斯分布有一定的理由。3X3高斯卷积核：$$\frac{1}{16}\left(\begin{matrix} 1 &amp; 2 &amp; 1\ 2 &amp; 4 &amp; 2 \ 1 &amp; 2 &amp; 1\end{matrix} \right)$$5X5高斯卷积核:$$\frac{1}{273}\left(\begin{matrix} 1 &amp; 4 &amp; 7 &amp; 4 &amp; 1 \ 4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \ 7 &amp; 26 &amp; 41 &amp; 26 &amp; 7 \ 4 &amp; 16 &amp; 26 &amp; 16 &amp; 4 \ 1 &amp; 4 &amp; 7 &amp; 4 &amp; 1\\end{matrix} \right)$$非线性滤波器非线性滤波器的原始数据与滤波结果是一种逻辑关系，即用逻辑运算实现，如最大值滤波器、最小值滤波器、中值滤波器等，是通过比较一定邻域内的灰度值大小来实现的，没有固定的模板，因而也就没有特定的转移函数（因为没有模板作傅里叶变换），另外，膨胀和腐蚀也是通过最大值、最小值滤波器实现的。 对比度锐化与对比度的区别锐化可以理解为增加局部差异，增加对比度可以理解为拉开整体差异 亮度饱和度]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-MVC-Hibernate-搭建后台服务]]></title>
    <url>%2F2017%2F12%2F26%2FSpring-MVC-Hibernate%2F</url>
    <content type="text"><![CDATA[框架介绍Spring MVCSpring MVC基于传统Spring的MVC模式的开发框架。 MVC设计模式在Spring MVC中表现为 模型 - 视图 - 控制器，模型封装应用程序的数据和一般他们会组成的POJO(Plain Ordinary Java Object)简单的Java对象，视图(View)是负责呈现模型数据并且一般由它生成HTML输出，客户端浏览器来解析显示，控制器(Controller)负责处理用户的请求，并建立适当的模型，并把它传递给视图渲染。 在Spring MVC中，有一个很重要的类是DispatcherServlet，叫中央前端控制器，所有的请求都由该控制器接受并分发到到合适的处理器，处理器解析请求直接返回Response或者跳转jsp页面，这些过程都要通过中央前端处理器。如图1所示： 接收HTTP请求后，DispatcherServlet 咨询 HandlerMapping 来调用相应的控制器。该控制器接受请求并调用基于使用GET或POST方法相应的服务方法。服务方法将基于定义的业务逻辑设置模型数据，并返回视图名到DispatcherServlet.DispatcherServlet将需要帮助的ViewResolver从拾取到该请求所定义的视图。一旦视图被敲定，DispatcherServlet会传递模型数据是在浏览器上最终呈现的视图。 Spring MVC的基本使用在java web项目中，都有一个web.xml文件用于配置当前项目，在这里，我们可以通过简单的对比了解Spring MVC的作用在没有使用Spring MVC框架前， 单纯的使用servlet接受网络请求的过程是这样的 ： 配置web.xml12345678910111213141516&lt;web-app&gt;&lt;!-- 配置servlet--&gt; &lt;servlet&gt; &lt;!-- servlet名称--&gt; &lt;servlet-name&gt;Sorry&lt;/servlet-name&gt; &lt;!-- 对应servlet要指向的HttpServlet类--&gt; &lt;servlet-class&gt;moreservlets.SorryServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 映射servlet到url--&gt; &lt;servlet-mapping&gt; &lt;!--这里表示所有以/servlet/开头的请求都会由Sorry这个Servlet来处理--&gt; &lt;servlet-name&gt; Sorry &lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 不使用SpringMVC时的网络请求继承HttpServlet类，并复写doGet()，doPost()等方法来处理请求1234567public class SorryServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); String title = &quot;Invoker Servlet Disabled.&quot;; out.println(ServletUtilities.headWithTitle(title) + &quot;&lt;BODY BGCOLOR=/&quot;#FDF5E6/&quot;&gt;/n&quot; + &quot;&lt;H2&gt;&quot; + title + &quot;&lt;/H2&gt;/n&quot; + &quot;Sorry, access to servlets by means of/n&quot; + &quot;URLs that begin with/n&quot; + &quot;http://host/webAppPrefix/servlet//n&quot; + &quot;has been disabled./n&quot; + &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;); &#125; 很明显，如果需求中有很多的请求，那么web.xml文件将会变得臃肿不堪，同时也要写大量的HttpServlet类用于处理请求，不利于代码的维护。 使用Spring mvc接受网络请求是这样的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455配置web.xml文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;&lt;!-- spring 配置文件 默认是/WEB-INF/applicationContext.xml ，在这里可以配置数据库地址，数据库文件，java bean等等--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 默认是/WEB-INF/applicationContext.xml --&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- spring mvc的中央前端分发器配置，不同于纯Servlet，所有的网络请求都经过该类然后分发--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置文件，配置了beans --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 默认是/WEB-INF/[servlet名字]-servlet.xml，在这个文件里配置控制器所在的包 --&gt; &lt;param-value&gt;/WEB-INF/SpringMVC-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--同样需要映射url，参数&lt;url-pattern&gt;表示所有的请求都由SpringMVC这个中央前端控制器接受 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!--转码控制 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 定义控制器：12345678910//注解Controller表示这个类是一个控制器@Controllerpublic class AppInfoController &#123; private Logger logger = Logger.getLogger(AppInfoController.class);//RequestMapping注解表示这个方法处理 /app的请求 @RequestMapping(value = &quot;/app&quot;,method = RequestMethod.GET) public void getAppInfoById(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; response.getWriter().append(&quot;Hello World&quot;);&#125; 因此使用Spring MVC的话，只需要在web.xml文件中配置DispatcherServlet，然后通过Controller注解一个类为控制器，再通过RequestMapping注解指定某方法可以接受某一类请求即可。这是最简单的使用，Spring MVC还提供很多其他的注解方式，比如ResponseBody注解直接将函数返回值作为Response的body返回，或者直接返回jsp文件名称并跳转页面等，不在赘述。 Hibernate简介Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，并将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得我们可以使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用， 完成数据持久化的任务。 hibernate使用在引入Hibernate类库之后，需要完成两个步骤，涉及到两种文件： 1.配置Hibernatehibernate.cfg.xml 文件：这是hibernate的配置文件，在这里要做的事包括但不限于： a. 操作的数据库的地址，账户，密码 b. .配置数据库驱动 2.实体类及映射文件POJO的映射文件。例如有一个AppInfo的模型类，为了使hibernate可以将读出来的数据直接转化为对象，需要创建相对应的AppInfo.hbm.xml文件，下面以AppInfo类为例进行说明：12345678910111213141516171819//这个是AppInfo model类，要求属性私有，并提供相应的setter和getterpublic class AppInfo implements java.io.Serializable &#123; private static final long serialVersionUID = 1111111111111111111L; private long id = 0; private String appId; public void setId(long id)&#123; this.id=id; &#125; public long getId()&#123; return id; &#125; public void setAppId(String appId)&#123; this.appId = appId; &#125; public String getAppId()&#123; return appId; &#125;&#125; 对应的AppInfo.hbm.xml文件，其中id标签表示将属性id作为数据库的主键，property标签对应AppInfo类中的appId属性，其他属性以此类推123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;qiyi.vr.app.model&quot;&gt; &lt;class name=&quot;AppInfo&quot; table=&quot;app_info&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;java.lang.Long&quot;&gt; &lt;column name=&quot;id&quot; /&gt; &lt;generator class=&quot;native&quot; /&gt; &lt;/id&gt; &lt;property name=&quot;appId&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;app_id&quot; /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 注：关于hbm.xml文件的生成：在MyEclipse中，可以通过根据数据库的字段反向映射来生成hbm.xml文件，但是这样会生成两个hbm.xml文件，具体原因及使用方法未知 3.注册映射文件在hibernate.cfg.xml文件中注册上面得到的映射文件1&lt;mapping resource=&quot;qiyi/vr/app/model/AppInfo.hbm.xml&quot; /&gt; 4.hibernate与数据库的交互hibernate与数据库的交互涉及到三个比较重要的类： SessionFactory：SessionFactory实例对应一个数据存储源，其特点是1.线程安全，同一个SessionFactory可被多个线程共享2.重量级，SessionFactory需要大缓存，缓存中会存储预设的SQL语句，因此，如果只需要访问一个数据库，那么创建一个SessionFactory对象即可 Session：Session是持久化管理器，由SessionFactory生成，其特点是：1线程不安全，session代表和当前数据库之间的一次操作，尽量避免多线程共享session2.轻量级，创建session耗费的资源相对较少3.session又被称为Hibernate的一级缓存，存放当前工作单元加载的对象，使用完毕要关闭session Transaction：Transaction接口是Hibernate数据库事务接口，Hibernate进行持久化操作时必须进行事务控制，简单说就是具体的数据库操作要在开启事务后进行，然后由事务进行commit，很类似于Android FragmentManager的Transaction。12345678910@Override public long insert(AppInfo entity) throws SQLException &#123; // TODO Auto-generated method stub Session session = HibernateSessionFactory.getSession(); Transaction transaction = session.beginTransaction(); session.save(entity); transaction.commit(); session.close(); return 0; &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jni开发知识点]]></title>
    <url>%2F2017%2F12%2F26%2Fjni-tips%2F</url>
    <content type="text"><![CDATA[JavaVM和JNIEnvjni定义了两个关键的结构体，JavaVM和JNIEnv，两者都拥有指向方法表的指针，在c++中，两者是拥有指向方法表和一系列jni方法的类，Android developer中说是类，实际开发中在jni.h中发现是结构体）。javavm提供invocation interface方法，可以创建和销毁javavm，理论上每个进程可以有多个javavm，但是Android中只允许有一个。jnienv提供大部分的jni方法，native方法的第一个参数就是jnienv。jnienv使用个threadlocal存储，因此线程间无法共享。如果某一段代码中无法获得jnienv，可以共享javavm并调用GetEnv来获得当前线程的jnienv，如果当前线程没有，可以使用AttachCurrentThread创建。 注意：c和c++关于两者的声明不同，如果头文件中定义了#indef _cplusplus，那么要注意自己引用的时哪个版本。 线程所有的线程都是linux线程，有kernal管理，可以自己创建线程，并通过JNI AttachCurrentThread or AttachCurrentThreadAsDaemon方法与jni关联，没有关联的话线程无法进行jni call。如果线程已经关联，那么调用AttachCurrentThread是空操作。当把一个线程Attach到javavm时，java中会创建一个thread,并添加到main threadGroup。android不会暂停正在执行native code的线程，只会在下一次执行jni call时暂停线程。通过jni关联的线程在退出前必须调用DetachCurrentThread，也可以使用pthread_key_create并构造新的析构函数来实现相同效果，在析构函数中调用该方法。使用pthread_setspecific存储jnienv到threadlocal，这样析构函数中传入jnienv参数。 引用类的引用、field IDs和method IDs 在类unload之前都是可用的。类的unload操作很少见，但并不是不可能。注意：尽管jclass是类的引用，但jclass必须通过NewGlobalRef的操作来保护起来。 native code中，对class的操作较为耗时，比如获得成员变量，回调方法，这些操作都要先获得fieldId和methodId，从性能角度看，最好将这些id缓存下来。考虑到java的类有可能会有unload，reload的过程，可以使用以下方式在每次加载类的时候缓存id12345678910/* * We use a class initializer to allow the native code to cache some * field offsets. This native function looks up and caches interesting * class/field/method IDs. Throws on failure. */private static native void nativeInit();static &#123; nativeInit();&#125; 这样，在一个类每次加载时都会调用nativeInit，在native层相应实现方法即可。 疑问：不同类的加载时线程问题 局部引用和全局引用传递给native方法传递的参数和大部分jni返回的参数都是局部引用，这意味着这些引用在当前的native方法中可见。及时对象在本地方法返回后仍然存活，引用也是不可见的。获得全局引用的唯一方法是NewGlobalRef和NewWeakGlobalRef.常用的模式是 123jclass localClass = env-&gt;FindClass(&quot;MyClass&quot;);//reinterpret_cast c++强制类型转换jclass globalClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(localClass)); jni方法接受局部和全局引用作为参数。指向同一对象的多个引用可能值并不相等。比如，连续多次调用NewGlobalRef的结果可能不同，因此在jni中，不能用==来判断引用是否相等，而要使用IsSameObject。因此，native中，不能假设对象的引用是不变的。 jni中，不能过多的分配局部引用，如果创建过多局部引用，要手动DeleteLocalRef(一般情况这个操作由jni自己完成)。实际中最多保留十六个局部引用，如果要更多，使用EnsureLocalCapacity/PushLocalFrame 注意：jfieldIDs and jmethodIDs不是object引用，不能更改为GlobalRef。 如果调用AttachCurrentThread，运行中的代码不会自动释放局部引用知道线程结束，需要手动释放。 基本类型数组此部分需要写代码进行验证 基本类型数组可以直接进行读写操作，因为他们是由c定义的。有一组函数用于对基本类型数组操作Get&lt;PrimitiveType&gt;ArrayElements,这些函数有的返回指针，有的返回真实的元素，有的分配内存并进行拷贝。不管哪种方式，返回的原始的指针在释放前都是可见的。也就是说，如果数据没有被拷贝，数组对象就不会被释放。我们必须释放所有的数组。是否进行拷贝是通过get系列函数的iscopy来确定的。release调用时传入mode参数：mode：0:源数据： 释放copy数据：data is copied back. The buffer with the copy is freed. JNI_COMMIT源数据： 无操作copy数据：data is copied back. The buffer with the copy is not freed. JNI_ABORT源数据： the array object is un-pinned. Earlier writes are not aborted.copy数据：the buffer with the copy is freed; any changes to it are lost. JNI_COMMIT不会释放元数据，需要使用其他参数再次调用release 关于isCopy，检查是否进行了拷贝很有用，如果对数组进行了修改，这可以让我们确定自己是否需要调用带有JNI_COMMIT的release方法。 Region Calls如果仅仅是为了将数据拷贝出来或者拷贝进去，有更方便的方法：先看以前的方法：12345jbyte* data = env-&gt;GetByteArrayElements(array, NULL);if (data != NULL) &#123; memcpy(buffer, data, len); env-&gt;ReleaseByteArrayElements(array, data, JNI_ABORT);&#125; 方便的方法,还能避免忘记release,还会避免多余的拷贝env-&gt;GetByteArrayRegion(array, 0, len, buffer); 异常很多jni方法会抛出异常。比如CallObjectMethod，这时需要check异常，因为该函数的返回值可能不可用。android还不支持c++的异常，jni的Throw和throwNew会在当前线程抛出一个java异常。native方法中，通过ExceptionCheck和ExceptionOccurred捕获异常。通过ExceptionClear清理异常。 关于JNIEnvc style:JNIEnv是一个名为JNINativeInterface的结构体，里面包含了一系列方法的指针用于jni的交互，如123456789101112struct JNINativeInterface &#123; void* reserved0; void* reserved1; void* reserved2; void* reserved3; jint (*GetVersion)(JNIEnv *); jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*, jsize); jclass (*FindClass)(JNIEnv*, const char*);..... c++ style：将c的JNINativeInterface结构体进行封装，变为名为_JNIEnv的结构体，并对JNINativeInterface的方法进行封装。12345678910111213141516171819202122/* * C++ object wrapper. * * This is usually overlaid on a C struct whose first element is a * JNINativeInterface*. We rely somewhat on compiler behavior. */struct _JNIEnv &#123; /* do not rename this; it does not seem to be entirely opaque */ const struct JNINativeInterface* functions;#if defined(__cplusplus) jint GetVersion() &#123; return functions-&gt;GetVersion(this); &#125; jclass DefineClass(const char *name, jobject loader, const jbyte* buf, jsize bufLen) &#123; return functions-&gt;DefineClass(this, name, loader, buf, bufLen); &#125; jclass FindClass(const char* name) &#123; return functions-&gt;FindClass(this, name); &#125;..... 关于JavaVMc style:123456789101112//JNI invocation interface.struct JNIInvokeInterface &#123; void* reserved0; void* reserved1; void* reserved2; jint (*DestroyJavaVM)(JavaVM*); jint (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*); jint (*DetachCurrentThread)(JavaVM*); jint (*GetEnv)(JavaVM*, void**, jint); jint (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);&#125;; c++ style:1234567891011121314struct _JavaVM &#123; const struct JNIInvokeInterface* functions; //if defined(__cplusplus) jint DestroyJavaVM() &#123; return functions-&gt;DestroyJavaVM(this); &#125; jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThread(this, p_env, thr_args); &#125; jint DetachCurrentThread() &#123; return functions-&gt;DetachCurrentThread(this); &#125; jint GetEnv(void** env, jint version) &#123; return functions-&gt;GetEnv(this, env, version); &#125; jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); &#125;&#125;; 关于引用数据类型c style:123456789101112131415161718/* * Reference types, in C. */typedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak; 可见，在c中，由无类型指针void*引申出一系列的jobject c++ style:123456789101112131415161718192021222324252627282930313233/* * Reference types, in C++ */class _jobject &#123;&#125;;class _jclass : public _jobject &#123;&#125;;class _jstring : public _jobject &#123;&#125;;class _jarray : public _jobject &#123;&#125;;class _jobjectArray : public _jarray &#123;&#125;;class _jbooleanArray : public _jarray &#123;&#125;;class _jbyteArray : public _jarray &#123;&#125;;class _jcharArray : public _jarray &#123;&#125;;class _jshortArray : public _jarray &#123;&#125;;class _jintArray : public _jarray &#123;&#125;;class _jlongArray : public _jarray &#123;&#125;;class _jfloatArray : public _jarray &#123;&#125;;class _jdoubleArray : public _jarray &#123;&#125;;class _jthrowable : public _jobject &#123;&#125;;typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak; 在c++中，jobject是一个类 基本数据类型：123456789101112/* Primitive types that match up with Java equivalents. */typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 *//* &quot;cardinal indices and sizes&quot; */typedef jint jsize; 可见，jni的基本类型与c中基本类型一样，所以可以直接转换，且不用考虑释放问题。 方法的类型签名：jni使用java虚拟机的类型签名1234567891011121314151617Type Signature Java TypeZ booleanB byteC charS shortI intJ longF floatD doubleLfully-qualified-class; fully-qualified-class[type type[](arg-types)ret-type method type如long f (int n, String s, int[] arr);的签名是：(ILjava/lang/String;[I)J 关于native向java回调在回调时经常会碰到多个不同的方法的类型签名，为避免重复代码和方便,可以使用以下方法。避免直接传递基本类型，全部使用jobject作为参数，基本类型使用其封装类123456789101112131415161718192021void callBackJavaUniversal(JavaVM *gJavaVM, jobject targetObj, string nameStr, string sigStr,jobject param1, jobject param2) &#123; char *name = (char *) nameStr.data(); char *sig = (char *) sigStr.data(); JNIEnv *env = 0; if (gJavaVM != NULL) &#123; gJavaVM-&gt;AttachCurrentThread(&amp;env, 0); &#125; if (env == NULL)&#123; return; &#125; jclass javaClass = env-&gt;GetObjectClass(targetObj); jmethodID javaCallback = env-&gt;GetMethodID(javaClass, name, sig); if (param1 == NULL) &#123; env-&gt;CallVoidMethod(targetObj, javaCallback); &#125; else if (param2 == NULL)&#123; env-&gt;CallVoidMethod(targetObj, javaCallback, param1); &#125; else &#123; env-&gt;CallVoidMethod(targetObj, javaCallback, param1, param2); &#125; env-&gt;DeleteLocalRef(javaClass);&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Blog]]></title>
    <url>%2F2017%2F12%2F26%2Ffirst%2F</url>
    <content type="text"><![CDATA[first blog]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
